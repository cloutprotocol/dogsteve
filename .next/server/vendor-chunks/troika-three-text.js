"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-text";
exports.ids = ["vendor-chunks/troika-three-text"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-text/dist/troika-three-text.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/troika-three-text/dist/troika-three-text.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BatchedText: () => (/* binding */ BatchedText),\n/* harmony export */   GlyphsGeometry: () => (/* binding */ GlyphsGeometry),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   configureTextBuilder: () => (/* binding */ configureTextBuilder),\n/* harmony export */   createTextDerivedMaterial: () => (/* binding */ createTextDerivedMaterial),\n/* harmony export */   dumpSDFTextures: () => (/* binding */ dumpSDFTextures),\n/* harmony export */   fontResolverWorkerModule: () => (/* binding */ fontResolverWorkerModule),\n/* harmony export */   getCaretAtPoint: () => (/* binding */ getCaretAtPoint),\n/* harmony export */   getSelectionRects: () => (/* binding */ getSelectionRects),\n/* harmony export */   getTextRenderInfo: () => (/* binding */ getTextRenderInfo),\n/* harmony export */   preloadFont: () => (/* binding */ preloadFont),\n/* harmony export */   typesetterWorkerModule: () => (/* binding */ typesetterWorkerModule)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! troika-worker-utils */ \"(ssr)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js\");\n/* harmony import */ var webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webgl-sdf-generator */ \"(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs\");\n/* harmony import */ var bidi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bidi-js */ \"(ssr)/./node_modules/bidi-js/dist/bidi.mjs\");\n/* harmony import */ var troika_three_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! troika-three-utils */ \"(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\");\n\n\n\n\n\n/*!\nCustom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.\nOriginal MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE\n*/ function typrFactory() {\n    return  true && (self.window = self), function(r) {\n        var e = {\n            parse: function(r) {\n                var t = e._bin, a = new Uint8Array(r);\n                if (\"ttcf\" == t.readASCII(a, 0, 4)) {\n                    var n = 4;\n                    t.readUshort(a, n), n += 2, t.readUshort(a, n), n += 2;\n                    var o = t.readUint(a, n);\n                    n += 4;\n                    for(var s = [], i = 0; i < o; i++){\n                        var h = t.readUint(a, n);\n                        n += 4, s.push(e._readFont(a, h));\n                    }\n                    return s;\n                }\n                return [\n                    e._readFont(a, 0)\n                ];\n            },\n            _readFont: function(r, t) {\n                var a = e._bin, n = t;\n                a.readFixed(r, t), t += 4;\n                var o = a.readUshort(r, t);\n                t += 2, a.readUshort(r, t), t += 2, a.readUshort(r, t), t += 2, a.readUshort(r, t), t += 2;\n                for(var s = [\n                    \"cmap\",\n                    \"head\",\n                    \"hhea\",\n                    \"maxp\",\n                    \"hmtx\",\n                    \"name\",\n                    \"OS/2\",\n                    \"post\",\n                    \"loca\",\n                    \"glyf\",\n                    \"kern\",\n                    \"CFF \",\n                    \"GDEF\",\n                    \"GPOS\",\n                    \"GSUB\",\n                    \"SVG \"\n                ], i = {\n                    _data: r,\n                    _offset: n\n                }, h = {}, d = 0; d < o; d++){\n                    var f = a.readASCII(r, t, 4);\n                    t += 4, a.readUint(r, t), t += 4;\n                    var u = a.readUint(r, t);\n                    t += 4;\n                    var l = a.readUint(r, t);\n                    t += 4, h[f] = {\n                        offset: u,\n                        length: l\n                    };\n                }\n                for(d = 0; d < s.length; d++){\n                    var v = s[d];\n                    h[v] && (i[v.trim()] = e[v.trim()].parse(r, h[v].offset, h[v].length, i));\n                }\n                return i;\n            },\n            _tabOffset: function(r, t, a) {\n                for(var n = e._bin, o = n.readUshort(r, a + 4), s = a + 12, i = 0; i < o; i++){\n                    var h = n.readASCII(r, s, 4);\n                    s += 4, n.readUint(r, s), s += 4;\n                    var d = n.readUint(r, s);\n                    if (s += 4, n.readUint(r, s), s += 4, h == t) return d;\n                }\n                return 0;\n            }\n        };\n        e._bin = {\n            readFixed: function(r, e) {\n                return (r[e] << 8 | r[e + 1]) + (r[e + 2] << 8 | r[e + 3]) / 65540;\n            },\n            readF2dot14: function(r, t) {\n                return e._bin.readShort(r, t) / 16384;\n            },\n            readInt: function(r, t) {\n                return e._bin._view(r).getInt32(t);\n            },\n            readInt8: function(r, t) {\n                return e._bin._view(r).getInt8(t);\n            },\n            readShort: function(r, t) {\n                return e._bin._view(r).getInt16(t);\n            },\n            readUshort: function(r, t) {\n                return e._bin._view(r).getUint16(t);\n            },\n            readUshorts: function(r, t, a) {\n                for(var n = [], o = 0; o < a; o++)n.push(e._bin.readUshort(r, t + 2 * o));\n                return n;\n            },\n            readUint: function(r, t) {\n                return e._bin._view(r).getUint32(t);\n            },\n            readUint64: function(r, t) {\n                return 4294967296 * e._bin.readUint(r, t) + e._bin.readUint(r, t + 4);\n            },\n            readASCII: function(r, e, t) {\n                for(var a = \"\", n = 0; n < t; n++)a += String.fromCharCode(r[e + n]);\n                return a;\n            },\n            readUnicode: function(r, e, t) {\n                for(var a = \"\", n = 0; n < t; n++){\n                    var o = r[e++] << 8 | r[e++];\n                    a += String.fromCharCode(o);\n                }\n                return a;\n            },\n            _tdec:  false ? 0 : null,\n            readUTF8: function(r, t, a) {\n                var n = e._bin._tdec;\n                return n && 0 == t && a == r.length ? n.decode(r) : e._bin.readASCII(r, t, a);\n            },\n            readBytes: function(r, e, t) {\n                for(var a = [], n = 0; n < t; n++)a.push(r[e + n]);\n                return a;\n            },\n            readASCIIArray: function(r, e, t) {\n                for(var a = [], n = 0; n < t; n++)a.push(String.fromCharCode(r[e + n]));\n                return a;\n            },\n            _view: function(r) {\n                return r._dataView || (r._dataView = r.buffer ? new DataView(r.buffer, r.byteOffset, r.byteLength) : new DataView(new Uint8Array(r).buffer));\n            }\n        }, e._lctf = {}, e._lctf.parse = function(r, t, a, n, o) {\n            var s = e._bin, i = {}, h = t;\n            s.readFixed(r, t), t += 4;\n            var d = s.readUshort(r, t);\n            t += 2;\n            var f = s.readUshort(r, t);\n            t += 2;\n            var u = s.readUshort(r, t);\n            return t += 2, i.scriptList = e._lctf.readScriptList(r, h + d), i.featureList = e._lctf.readFeatureList(r, h + f), i.lookupList = e._lctf.readLookupList(r, h + u, o), i;\n        }, e._lctf.readLookupList = function(r, t, a) {\n            var n = e._bin, o = t, s = [], i = n.readUshort(r, t);\n            t += 2;\n            for(var h = 0; h < i; h++){\n                var d = n.readUshort(r, t);\n                t += 2;\n                var f = e._lctf.readLookupTable(r, o + d, a);\n                s.push(f);\n            }\n            return s;\n        }, e._lctf.readLookupTable = function(r, t, a) {\n            var n = e._bin, o = t, s = {\n                tabs: []\n            };\n            s.ltype = n.readUshort(r, t), t += 2, s.flag = n.readUshort(r, t), t += 2;\n            var i = n.readUshort(r, t);\n            t += 2;\n            for(var h = s.ltype, d = 0; d < i; d++){\n                var f = n.readUshort(r, t);\n                t += 2;\n                var u = a(r, h, o + f, s);\n                s.tabs.push(u);\n            }\n            return s;\n        }, e._lctf.numOfOnes = function(r) {\n            for(var e = 0, t = 0; t < 32; t++)0 != (r >>> t & 1) && e++;\n            return e;\n        }, e._lctf.readClassDef = function(r, t) {\n            var a = e._bin, n = [], o = a.readUshort(r, t);\n            if (t += 2, 1 == o) {\n                var s = a.readUshort(r, t);\n                t += 2;\n                var i = a.readUshort(r, t);\n                t += 2;\n                for(var h = 0; h < i; h++)n.push(s + h), n.push(s + h), n.push(a.readUshort(r, t)), t += 2;\n            }\n            if (2 == o) {\n                var d = a.readUshort(r, t);\n                t += 2;\n                for(h = 0; h < d; h++)n.push(a.readUshort(r, t)), t += 2, n.push(a.readUshort(r, t)), t += 2, n.push(a.readUshort(r, t)), t += 2;\n            }\n            return n;\n        }, e._lctf.getInterval = function(r, e) {\n            for(var t = 0; t < r.length; t += 3){\n                var a = r[t], n = r[t + 1];\n                if (r[t + 2], a <= e && e <= n) return t;\n            }\n            return -1;\n        }, e._lctf.readCoverage = function(r, t) {\n            var a = e._bin, n = {};\n            n.fmt = a.readUshort(r, t), t += 2;\n            var o = a.readUshort(r, t);\n            return t += 2, 1 == n.fmt && (n.tab = a.readUshorts(r, t, o)), 2 == n.fmt && (n.tab = a.readUshorts(r, t, 3 * o)), n;\n        }, e._lctf.coverageIndex = function(r, t) {\n            var a = r.tab;\n            if (1 == r.fmt) return a.indexOf(t);\n            if (2 == r.fmt) {\n                var n = e._lctf.getInterval(a, t);\n                if (-1 != n) return a[n + 2] + (t - a[n]);\n            }\n            return -1;\n        }, e._lctf.readFeatureList = function(r, t) {\n            var a = e._bin, n = t, o = [], s = a.readUshort(r, t);\n            t += 2;\n            for(var i = 0; i < s; i++){\n                var h = a.readASCII(r, t, 4);\n                t += 4;\n                var d = a.readUshort(r, t);\n                t += 2;\n                var f = e._lctf.readFeatureTable(r, n + d);\n                f.tag = h.trim(), o.push(f);\n            }\n            return o;\n        }, e._lctf.readFeatureTable = function(r, t) {\n            var a = e._bin, n = t, o = {}, s = a.readUshort(r, t);\n            t += 2, s > 0 && (o.featureParams = n + s);\n            var i = a.readUshort(r, t);\n            t += 2, o.tab = [];\n            for(var h = 0; h < i; h++)o.tab.push(a.readUshort(r, t + 2 * h));\n            return o;\n        }, e._lctf.readScriptList = function(r, t) {\n            var a = e._bin, n = t, o = {}, s = a.readUshort(r, t);\n            t += 2;\n            for(var i = 0; i < s; i++){\n                var h = a.readASCII(r, t, 4);\n                t += 4;\n                var d = a.readUshort(r, t);\n                t += 2, o[h.trim()] = e._lctf.readScriptTable(r, n + d);\n            }\n            return o;\n        }, e._lctf.readScriptTable = function(r, t) {\n            var a = e._bin, n = t, o = {}, s = a.readUshort(r, t);\n            t += 2, s > 0 && (o.default = e._lctf.readLangSysTable(r, n + s));\n            var i = a.readUshort(r, t);\n            t += 2;\n            for(var h = 0; h < i; h++){\n                var d = a.readASCII(r, t, 4);\n                t += 4;\n                var f = a.readUshort(r, t);\n                t += 2, o[d.trim()] = e._lctf.readLangSysTable(r, n + f);\n            }\n            return o;\n        }, e._lctf.readLangSysTable = function(r, t) {\n            var a = e._bin, n = {};\n            a.readUshort(r, t), t += 2, n.reqFeature = a.readUshort(r, t), t += 2;\n            var o = a.readUshort(r, t);\n            return t += 2, n.features = a.readUshorts(r, t, o), n;\n        }, e.CFF = {}, e.CFF.parse = function(r, t, a) {\n            var n = e._bin;\n            (r = new Uint8Array(r.buffer, t, a))[t = 0], r[++t], r[++t], r[++t], t++;\n            var o = [];\n            t = e.CFF.readIndex(r, t, o);\n            for(var s = [], i = 0; i < o.length - 1; i++)s.push(n.readASCII(r, t + o[i], o[i + 1] - o[i]));\n            t += o[o.length - 1];\n            var h = [];\n            t = e.CFF.readIndex(r, t, h);\n            var d = [];\n            for(i = 0; i < h.length - 1; i++)d.push(e.CFF.readDict(r, t + h[i], t + h[i + 1]));\n            t += h[h.length - 1];\n            var f = d[0], u = [];\n            t = e.CFF.readIndex(r, t, u);\n            var l = [];\n            for(i = 0; i < u.length - 1; i++)l.push(n.readASCII(r, t + u[i], u[i + 1] - u[i]));\n            if (t += u[u.length - 1], e.CFF.readSubrs(r, t, f), f.CharStrings) {\n                t = f.CharStrings;\n                u = [];\n                t = e.CFF.readIndex(r, t, u);\n                var v = [];\n                for(i = 0; i < u.length - 1; i++)v.push(n.readBytes(r, t + u[i], u[i + 1] - u[i]));\n                f.CharStrings = v;\n            }\n            if (f.ROS) {\n                t = f.FDArray;\n                var c = [];\n                t = e.CFF.readIndex(r, t, c), f.FDArray = [];\n                for(i = 0; i < c.length - 1; i++){\n                    var p = e.CFF.readDict(r, t + c[i], t + c[i + 1]);\n                    e.CFF._readFDict(r, p, l), f.FDArray.push(p);\n                }\n                t += c[c.length - 1], t = f.FDSelect, f.FDSelect = [];\n                var U = r[t];\n                if (t++, 3 != U) throw U;\n                var g = n.readUshort(r, t);\n                t += 2;\n                for(i = 0; i < g + 1; i++)f.FDSelect.push(n.readUshort(r, t), r[t + 2]), t += 3;\n            }\n            return f.Encoding && (f.Encoding = e.CFF.readEncoding(r, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(r, f.charset, f.CharStrings.length)), e.CFF._readFDict(r, f, l), f;\n        }, e.CFF._readFDict = function(r, t, a) {\n            var n;\n            for(var o in t.Private && (n = t.Private[1], t.Private = e.CFF.readDict(r, n, n + t.Private[0]), t.Private.Subrs && e.CFF.readSubrs(r, n + t.Private.Subrs, t.Private)), t)-1 != [\n                \"FamilyName\",\n                \"FontName\",\n                \"FullName\",\n                \"Notice\",\n                \"version\",\n                \"Copyright\"\n            ].indexOf(o) && (t[o] = a[t[o] - 426 + 35]);\n        }, e.CFF.readSubrs = function(r, t, a) {\n            var n = e._bin, o = [];\n            t = e.CFF.readIndex(r, t, o);\n            var s, i = o.length;\n            s = i < 1240 ? 107 : i < 33900 ? 1131 : 32768, a.Bias = s, a.Subrs = [];\n            for(var h = 0; h < o.length - 1; h++)a.Subrs.push(n.readBytes(r, t + o[h], o[h + 1] - o[h]));\n        }, e.CFF.tableSE = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            2,\n            3,\n            4,\n            5,\n            6,\n            7,\n            8,\n            9,\n            10,\n            11,\n            12,\n            13,\n            14,\n            15,\n            16,\n            17,\n            18,\n            19,\n            20,\n            21,\n            22,\n            23,\n            24,\n            25,\n            26,\n            27,\n            28,\n            29,\n            30,\n            31,\n            32,\n            33,\n            34,\n            35,\n            36,\n            37,\n            38,\n            39,\n            40,\n            41,\n            42,\n            43,\n            44,\n            45,\n            46,\n            47,\n            48,\n            49,\n            50,\n            51,\n            52,\n            53,\n            54,\n            55,\n            56,\n            57,\n            58,\n            59,\n            60,\n            61,\n            62,\n            63,\n            64,\n            65,\n            66,\n            67,\n            68,\n            69,\n            70,\n            71,\n            72,\n            73,\n            74,\n            75,\n            76,\n            77,\n            78,\n            79,\n            80,\n            81,\n            82,\n            83,\n            84,\n            85,\n            86,\n            87,\n            88,\n            89,\n            90,\n            91,\n            92,\n            93,\n            94,\n            95,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            96,\n            97,\n            98,\n            99,\n            100,\n            101,\n            102,\n            103,\n            104,\n            105,\n            106,\n            107,\n            108,\n            109,\n            110,\n            0,\n            111,\n            112,\n            113,\n            114,\n            0,\n            115,\n            116,\n            117,\n            118,\n            119,\n            120,\n            121,\n            122,\n            0,\n            123,\n            0,\n            124,\n            125,\n            126,\n            127,\n            128,\n            129,\n            130,\n            131,\n            0,\n            132,\n            133,\n            0,\n            134,\n            135,\n            136,\n            137,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            138,\n            0,\n            139,\n            0,\n            0,\n            0,\n            0,\n            140,\n            141,\n            142,\n            143,\n            0,\n            0,\n            0,\n            0,\n            0,\n            144,\n            0,\n            0,\n            0,\n            145,\n            0,\n            0,\n            146,\n            147,\n            148,\n            149,\n            0,\n            0,\n            0,\n            0\n        ], e.CFF.glyphByUnicode = function(r, e) {\n            for(var t = 0; t < r.charset.length; t++)if (r.charset[t] == e) return t;\n            return -1;\n        }, e.CFF.glyphBySE = function(r, t) {\n            return t < 0 || t > 255 ? -1 : e.CFF.glyphByUnicode(r, e.CFF.tableSE[t]);\n        }, e.CFF.readEncoding = function(r, t, a) {\n            e._bin;\n            var n = [\n                \".notdef\"\n            ], o = r[t];\n            if (t++, 0 != o) throw \"error: unknown encoding format: \" + o;\n            var s = r[t];\n            t++;\n            for(var i = 0; i < s; i++)n.push(r[t + i]);\n            return n;\n        }, e.CFF.readCharset = function(r, t, a) {\n            var n = e._bin, o = [\n                \".notdef\"\n            ], s = r[t];\n            if (t++, 0 == s) for(var i = 0; i < a; i++){\n                var h = n.readUshort(r, t);\n                t += 2, o.push(h);\n            }\n            else {\n                if (1 != s && 2 != s) throw \"error: format: \" + s;\n                for(; o.length < a;){\n                    h = n.readUshort(r, t);\n                    t += 2;\n                    var d = 0;\n                    1 == s ? (d = r[t], t++) : (d = n.readUshort(r, t), t += 2);\n                    for(i = 0; i <= d; i++)o.push(h), h++;\n                }\n            }\n            return o;\n        }, e.CFF.readIndex = function(r, t, a) {\n            var n = e._bin, o = n.readUshort(r, t) + 1, s = r[t += 2];\n            if (t++, 1 == s) for(var i = 0; i < o; i++)a.push(r[t + i]);\n            else if (2 == s) for(i = 0; i < o; i++)a.push(n.readUshort(r, t + 2 * i));\n            else if (3 == s) for(i = 0; i < o; i++)a.push(16777215 & n.readUint(r, t + 3 * i - 1));\n            else if (1 != o) throw \"unsupported offset size: \" + s + \", count: \" + o;\n            return (t += o * s) - 1;\n        }, e.CFF.getCharString = function(r, t, a) {\n            var n = e._bin, o = r[t], s = r[t + 1];\n            r[t + 2], r[t + 3], r[t + 4];\n            var i = 1, h = null, d = null;\n            o <= 20 && (h = o, i = 1), 12 == o && (h = 100 * o + s, i = 2), 21 <= o && o <= 27 && (h = o, i = 1), 28 == o && (d = n.readShort(r, t + 1), i = 3), 29 <= o && o <= 31 && (h = o, i = 1), 32 <= o && o <= 246 && (d = o - 139, i = 1), 247 <= o && o <= 250 && (d = 256 * (o - 247) + s + 108, i = 2), 251 <= o && o <= 254 && (d = 256 * -(o - 251) - s - 108, i = 2), 255 == o && (d = n.readInt(r, t + 1) / 65535, i = 5), a.val = null != d ? d : \"o\" + h, a.size = i;\n        }, e.CFF.readCharString = function(r, t, a) {\n            for(var n = t + a, o = e._bin, s = []; t < n;){\n                var i = r[t], h = r[t + 1];\n                r[t + 2], r[t + 3], r[t + 4];\n                var d = 1, f = null, u = null;\n                i <= 20 && (f = i, d = 1), 12 == i && (f = 100 * i + h, d = 2), 19 != i && 20 != i || (f = i, d = 2), 21 <= i && i <= 27 && (f = i, d = 1), 28 == i && (u = o.readShort(r, t + 1), d = 3), 29 <= i && i <= 31 && (f = i, d = 1), 32 <= i && i <= 246 && (u = i - 139, d = 1), 247 <= i && i <= 250 && (u = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u = 256 * -(i - 251) - h - 108, d = 2), 255 == i && (u = o.readInt(r, t + 1) / 65535, d = 5), s.push(null != u ? u : \"o\" + f), t += d;\n            }\n            return s;\n        }, e.CFF.readDict = function(r, t, a) {\n            for(var n = e._bin, o = {}, s = []; t < a;){\n                var i = r[t], h = r[t + 1];\n                r[t + 2], r[t + 3], r[t + 4];\n                var d = 1, f = null, u = null;\n                if (28 == i && (u = n.readShort(r, t + 1), d = 3), 29 == i && (u = n.readInt(r, t + 1), d = 5), 32 <= i && i <= 246 && (u = i - 139, d = 1), 247 <= i && i <= 250 && (u = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u = 256 * -(i - 251) - h - 108, d = 2), 255 == i) throw u = n.readInt(r, t + 1) / 65535, d = 5, \"unknown number\";\n                if (30 == i) {\n                    var l = [];\n                    for(d = 1;;){\n                        var v = r[t + d];\n                        d++;\n                        var c = v >> 4, p = 15 & v;\n                        if (15 != c && l.push(c), 15 != p && l.push(p), 15 == p) break;\n                    }\n                    for(var U = \"\", g = [\n                        0,\n                        1,\n                        2,\n                        3,\n                        4,\n                        5,\n                        6,\n                        7,\n                        8,\n                        9,\n                        \".\",\n                        \"e\",\n                        \"e-\",\n                        \"reserved\",\n                        \"-\",\n                        \"endOfNumber\"\n                    ], S = 0; S < l.length; S++)U += g[l[S]];\n                    u = parseFloat(U);\n                }\n                if (i <= 21) {\n                    if (f = [\n                        \"version\",\n                        \"Notice\",\n                        \"FullName\",\n                        \"FamilyName\",\n                        \"Weight\",\n                        \"FontBBox\",\n                        \"BlueValues\",\n                        \"OtherBlues\",\n                        \"FamilyBlues\",\n                        \"FamilyOtherBlues\",\n                        \"StdHW\",\n                        \"StdVW\",\n                        \"escape\",\n                        \"UniqueID\",\n                        \"XUID\",\n                        \"charset\",\n                        \"Encoding\",\n                        \"CharStrings\",\n                        \"Private\",\n                        \"Subrs\",\n                        \"defaultWidthX\",\n                        \"nominalWidthX\"\n                    ][i], d = 1, 12 == i) f = [\n                        \"Copyright\",\n                        \"isFixedPitch\",\n                        \"ItalicAngle\",\n                        \"UnderlinePosition\",\n                        \"UnderlineThickness\",\n                        \"PaintType\",\n                        \"CharstringType\",\n                        \"FontMatrix\",\n                        \"StrokeWidth\",\n                        \"BlueScale\",\n                        \"BlueShift\",\n                        \"BlueFuzz\",\n                        \"StemSnapH\",\n                        \"StemSnapV\",\n                        \"ForceBold\",\n                        0,\n                        0,\n                        \"LanguageGroup\",\n                        \"ExpansionFactor\",\n                        \"initialRandomSeed\",\n                        \"SyntheticBase\",\n                        \"PostScript\",\n                        \"BaseFontName\",\n                        \"BaseFontBlend\",\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        \"ROS\",\n                        \"CIDFontVersion\",\n                        \"CIDFontRevision\",\n                        \"CIDFontType\",\n                        \"CIDCount\",\n                        \"UIDBase\",\n                        \"FDArray\",\n                        \"FDSelect\",\n                        \"FontName\"\n                    ][h], d = 2;\n                }\n                null != f ? (o[f] = 1 == s.length ? s[0] : s, s = []) : s.push(u), t += d;\n            }\n            return o;\n        }, e.cmap = {}, e.cmap.parse = function(r, t, a) {\n            r = new Uint8Array(r.buffer, t, a), t = 0;\n            var n = e._bin, o = {};\n            n.readUshort(r, t), t += 2;\n            var s = n.readUshort(r, t);\n            t += 2;\n            var i = [];\n            o.tables = [];\n            for(var h = 0; h < s; h++){\n                var d = n.readUshort(r, t);\n                t += 2;\n                var f = n.readUshort(r, t);\n                t += 2;\n                var u = n.readUint(r, t);\n                t += 4;\n                var l = \"p\" + d + \"e\" + f, v = i.indexOf(u);\n                if (-1 == v) {\n                    var c;\n                    v = o.tables.length, i.push(u);\n                    var p = n.readUshort(r, u);\n                    0 == p ? c = e.cmap.parse0(r, u) : 4 == p ? c = e.cmap.parse4(r, u) : 6 == p ? c = e.cmap.parse6(r, u) : 12 == p ? c = e.cmap.parse12(r, u) : console.debug(\"unknown format: \" + p, d, f, u), o.tables.push(c);\n                }\n                if (null != o[l]) throw \"multiple tables for one platform+encoding\";\n                o[l] = v;\n            }\n            return o;\n        }, e.cmap.parse0 = function(r, t) {\n            var a = e._bin, n = {};\n            n.format = a.readUshort(r, t), t += 2;\n            var o = a.readUshort(r, t);\n            t += 2, a.readUshort(r, t), t += 2, n.map = [];\n            for(var s = 0; s < o - 6; s++)n.map.push(r[t + s]);\n            return n;\n        }, e.cmap.parse4 = function(r, t) {\n            var a = e._bin, n = t, o = {};\n            o.format = a.readUshort(r, t), t += 2;\n            var s = a.readUshort(r, t);\n            t += 2, a.readUshort(r, t), t += 2;\n            var i = a.readUshort(r, t);\n            t += 2;\n            var h = i / 2;\n            o.searchRange = a.readUshort(r, t), t += 2, o.entrySelector = a.readUshort(r, t), t += 2, o.rangeShift = a.readUshort(r, t), t += 2, o.endCount = a.readUshorts(r, t, h), t += 2 * h, t += 2, o.startCount = a.readUshorts(r, t, h), t += 2 * h, o.idDelta = [];\n            for(var d = 0; d < h; d++)o.idDelta.push(a.readShort(r, t)), t += 2;\n            for(o.idRangeOffset = a.readUshorts(r, t, h), t += 2 * h, o.glyphIdArray = []; t < n + s;)o.glyphIdArray.push(a.readUshort(r, t)), t += 2;\n            return o;\n        }, e.cmap.parse6 = function(r, t) {\n            var a = e._bin, n = {};\n            n.format = a.readUshort(r, t), t += 2, a.readUshort(r, t), t += 2, a.readUshort(r, t), t += 2, n.firstCode = a.readUshort(r, t), t += 2;\n            var o = a.readUshort(r, t);\n            t += 2, n.glyphIdArray = [];\n            for(var s = 0; s < o; s++)n.glyphIdArray.push(a.readUshort(r, t)), t += 2;\n            return n;\n        }, e.cmap.parse12 = function(r, t) {\n            var a = e._bin, n = {};\n            n.format = a.readUshort(r, t), t += 2, t += 2, a.readUint(r, t), t += 4, a.readUint(r, t), t += 4;\n            var o = a.readUint(r, t);\n            t += 4, n.groups = [];\n            for(var s = 0; s < o; s++){\n                var i = t + 12 * s, h = a.readUint(r, i + 0), d = a.readUint(r, i + 4), f = a.readUint(r, i + 8);\n                n.groups.push([\n                    h,\n                    d,\n                    f\n                ]);\n            }\n            return n;\n        }, e.glyf = {}, e.glyf.parse = function(r, e, t, a) {\n            for(var n = [], o = 0; o < a.maxp.numGlyphs; o++)n.push(null);\n            return n;\n        }, e.glyf._parseGlyf = function(r, t) {\n            var a = e._bin, n = r._data, o = e._tabOffset(n, \"glyf\", r._offset) + r.loca[t];\n            if (r.loca[t] == r.loca[t + 1]) return null;\n            var s = {};\n            if (s.noc = a.readShort(n, o), o += 2, s.xMin = a.readShort(n, o), o += 2, s.yMin = a.readShort(n, o), o += 2, s.xMax = a.readShort(n, o), o += 2, s.yMax = a.readShort(n, o), o += 2, s.xMin >= s.xMax || s.yMin >= s.yMax) return null;\n            if (s.noc > 0) {\n                s.endPts = [];\n                for(var i = 0; i < s.noc; i++)s.endPts.push(a.readUshort(n, o)), o += 2;\n                var h = a.readUshort(n, o);\n                if (o += 2, n.length - o < h) return null;\n                s.instructions = a.readBytes(n, o, h), o += h;\n                var d = s.endPts[s.noc - 1] + 1;\n                s.flags = [];\n                for(i = 0; i < d; i++){\n                    var f = n[o];\n                    if (o++, s.flags.push(f), 0 != (8 & f)) {\n                        var u = n[o];\n                        o++;\n                        for(var l = 0; l < u; l++)s.flags.push(f), i++;\n                    }\n                }\n                s.xs = [];\n                for(i = 0; i < d; i++){\n                    var v = 0 != (2 & s.flags[i]), c = 0 != (16 & s.flags[i]);\n                    v ? (s.xs.push(c ? n[o] : -n[o]), o++) : c ? s.xs.push(0) : (s.xs.push(a.readShort(n, o)), o += 2);\n                }\n                s.ys = [];\n                for(i = 0; i < d; i++){\n                    v = 0 != (4 & s.flags[i]), c = 0 != (32 & s.flags[i]);\n                    v ? (s.ys.push(c ? n[o] : -n[o]), o++) : c ? s.ys.push(0) : (s.ys.push(a.readShort(n, o)), o += 2);\n                }\n                var p = 0, U = 0;\n                for(i = 0; i < d; i++)p += s.xs[i], U += s.ys[i], s.xs[i] = p, s.ys[i] = U;\n            } else {\n                var g;\n                s.parts = [];\n                do {\n                    g = a.readUshort(n, o), o += 2;\n                    var S = {\n                        m: {\n                            a: 1,\n                            b: 0,\n                            c: 0,\n                            d: 1,\n                            tx: 0,\n                            ty: 0\n                        },\n                        p1: -1,\n                        p2: -1\n                    };\n                    if (s.parts.push(S), S.glyphIndex = a.readUshort(n, o), o += 2, 1 & g) {\n                        var m = a.readShort(n, o);\n                        o += 2;\n                        var b = a.readShort(n, o);\n                        o += 2;\n                    } else {\n                        m = a.readInt8(n, o);\n                        o++;\n                        b = a.readInt8(n, o);\n                        o++;\n                    }\n                    2 & g ? (S.m.tx = m, S.m.ty = b) : (S.p1 = m, S.p2 = b), 8 & g ? (S.m.a = S.m.d = a.readF2dot14(n, o), o += 2) : 64 & g ? (S.m.a = a.readF2dot14(n, o), o += 2, S.m.d = a.readF2dot14(n, o), o += 2) : 128 & g && (S.m.a = a.readF2dot14(n, o), o += 2, S.m.b = a.readF2dot14(n, o), o += 2, S.m.c = a.readF2dot14(n, o), o += 2, S.m.d = a.readF2dot14(n, o), o += 2);\n                }while (32 & g);\n                if (256 & g) {\n                    var y = a.readUshort(n, o);\n                    o += 2, s.instr = [];\n                    for(i = 0; i < y; i++)s.instr.push(n[o]), o++;\n                }\n            }\n            return s;\n        }, e.GDEF = {}, e.GDEF.parse = function(r, t, a, n) {\n            var o = t;\n            t += 4;\n            var s = e._bin.readUshort(r, t);\n            return {\n                glyphClassDef: 0 === s ? null : e._lctf.readClassDef(r, o + s)\n            };\n        }, e.GPOS = {}, e.GPOS.parse = function(r, t, a, n) {\n            return e._lctf.parse(r, t, a, n, e.GPOS.subt);\n        }, e.GPOS.subt = function(r, t, a, n) {\n            var o = e._bin, s = a, i = {};\n            if (i.fmt = o.readUshort(r, a), a += 2, 1 == t || 2 == t || 3 == t || 7 == t || 8 == t && i.fmt <= 2) {\n                var h = o.readUshort(r, a);\n                a += 2, i.coverage = e._lctf.readCoverage(r, h + s);\n            }\n            if (1 == t && 1 == i.fmt) {\n                var d = o.readUshort(r, a);\n                a += 2, 0 != d && (i.pos = e.GPOS.readValueRecord(r, a, d));\n            } else if (2 == t && i.fmt >= 1 && i.fmt <= 2) {\n                d = o.readUshort(r, a);\n                a += 2;\n                var f = o.readUshort(r, a);\n                a += 2;\n                var u = e._lctf.numOfOnes(d), l = e._lctf.numOfOnes(f);\n                if (1 == i.fmt) {\n                    i.pairsets = [];\n                    var v = o.readUshort(r, a);\n                    a += 2;\n                    for(var c = 0; c < v; c++){\n                        var p = s + o.readUshort(r, a);\n                        a += 2;\n                        var U = o.readUshort(r, p);\n                        p += 2;\n                        for(var g = [], S = 0; S < U; S++){\n                            var m = o.readUshort(r, p);\n                            p += 2, 0 != d && (P = e.GPOS.readValueRecord(r, p, d), p += 2 * u), 0 != f && (x = e.GPOS.readValueRecord(r, p, f), p += 2 * l), g.push({\n                                gid2: m,\n                                val1: P,\n                                val2: x\n                            });\n                        }\n                        i.pairsets.push(g);\n                    }\n                }\n                if (2 == i.fmt) {\n                    var b = o.readUshort(r, a);\n                    a += 2;\n                    var y = o.readUshort(r, a);\n                    a += 2;\n                    var F = o.readUshort(r, a);\n                    a += 2;\n                    var C = o.readUshort(r, a);\n                    a += 2, i.classDef1 = e._lctf.readClassDef(r, s + b), i.classDef2 = e._lctf.readClassDef(r, s + y), i.matrix = [];\n                    for(c = 0; c < F; c++){\n                        var _ = [];\n                        for(S = 0; S < C; S++){\n                            var P = null, x = null;\n                            0 != d && (P = e.GPOS.readValueRecord(r, a, d), a += 2 * u), 0 != f && (x = e.GPOS.readValueRecord(r, a, f), a += 2 * l), _.push({\n                                val1: P,\n                                val2: x\n                            });\n                        }\n                        i.matrix.push(_);\n                    }\n                }\n            } else if (4 == t && 1 == i.fmt) i.markCoverage = e._lctf.readCoverage(r, o.readUshort(r, a) + s), i.baseCoverage = e._lctf.readCoverage(r, o.readUshort(r, a + 2) + s), i.markClassCount = o.readUshort(r, a + 4), i.markArray = e.GPOS.readMarkArray(r, o.readUshort(r, a + 6) + s), i.baseArray = e.GPOS.readBaseArray(r, o.readUshort(r, a + 8) + s, i.markClassCount);\n            else if (6 == t && 1 == i.fmt) i.mark1Coverage = e._lctf.readCoverage(r, o.readUshort(r, a) + s), i.mark2Coverage = e._lctf.readCoverage(r, o.readUshort(r, a + 2) + s), i.markClassCount = o.readUshort(r, a + 4), i.mark1Array = e.GPOS.readMarkArray(r, o.readUshort(r, a + 6) + s), i.mark2Array = e.GPOS.readBaseArray(r, o.readUshort(r, a + 8) + s, i.markClassCount);\n            else {\n                if (9 == t && 1 == i.fmt) {\n                    var I = o.readUshort(r, a);\n                    a += 2;\n                    var w = o.readUint(r, a);\n                    if (a += 4, 9 == n.ltype) n.ltype = I;\n                    else if (n.ltype != I) throw \"invalid extension substitution\";\n                    return e.GPOS.subt(r, n.ltype, s + w);\n                }\n                console.debug(\"unsupported GPOS table LookupType\", t, \"format\", i.fmt);\n            }\n            return i;\n        }, e.GPOS.readValueRecord = function(r, t, a) {\n            var n = e._bin, o = [];\n            return o.push(1 & a ? n.readShort(r, t) : 0), t += 1 & a ? 2 : 0, o.push(2 & a ? n.readShort(r, t) : 0), t += 2 & a ? 2 : 0, o.push(4 & a ? n.readShort(r, t) : 0), t += 4 & a ? 2 : 0, o.push(8 & a ? n.readShort(r, t) : 0), t += 8 & a ? 2 : 0, o;\n        }, e.GPOS.readBaseArray = function(r, t, a) {\n            var n = e._bin, o = [], s = t, i = n.readUshort(r, t);\n            t += 2;\n            for(var h = 0; h < i; h++){\n                for(var d = [], f = 0; f < a; f++)d.push(e.GPOS.readAnchorRecord(r, s + n.readUshort(r, t))), t += 2;\n                o.push(d);\n            }\n            return o;\n        }, e.GPOS.readMarkArray = function(r, t) {\n            var a = e._bin, n = [], o = t, s = a.readUshort(r, t);\n            t += 2;\n            for(var i = 0; i < s; i++){\n                var h = e.GPOS.readAnchorRecord(r, a.readUshort(r, t + 2) + o);\n                h.markClass = a.readUshort(r, t), n.push(h), t += 4;\n            }\n            return n;\n        }, e.GPOS.readAnchorRecord = function(r, t) {\n            var a = e._bin, n = {};\n            return n.fmt = a.readUshort(r, t), n.x = a.readShort(r, t + 2), n.y = a.readShort(r, t + 4), n;\n        }, e.GSUB = {}, e.GSUB.parse = function(r, t, a, n) {\n            return e._lctf.parse(r, t, a, n, e.GSUB.subt);\n        }, e.GSUB.subt = function(r, t, a, n) {\n            var o = e._bin, s = a, i = {};\n            if (i.fmt = o.readUshort(r, a), a += 2, 1 != t && 2 != t && 4 != t && 5 != t && 6 != t) return null;\n            if (1 == t || 2 == t || 4 == t || 5 == t && i.fmt <= 2 || 6 == t && i.fmt <= 2) {\n                var h = o.readUshort(r, a);\n                a += 2, i.coverage = e._lctf.readCoverage(r, s + h);\n            }\n            if (1 == t && i.fmt >= 1 && i.fmt <= 2) {\n                if (1 == i.fmt) i.delta = o.readShort(r, a), a += 2;\n                else if (2 == i.fmt) {\n                    var d = o.readUshort(r, a);\n                    a += 2, i.newg = o.readUshorts(r, a, d), a += 2 * i.newg.length;\n                }\n            } else if (2 == t && 1 == i.fmt) {\n                d = o.readUshort(r, a);\n                a += 2, i.seqs = [];\n                for(var f = 0; f < d; f++){\n                    var u = o.readUshort(r, a) + s;\n                    a += 2;\n                    var l = o.readUshort(r, u);\n                    i.seqs.push(o.readUshorts(r, u + 2, l));\n                }\n            } else if (4 == t) {\n                i.vals = [];\n                d = o.readUshort(r, a);\n                a += 2;\n                for(f = 0; f < d; f++){\n                    var v = o.readUshort(r, a);\n                    a += 2, i.vals.push(e.GSUB.readLigatureSet(r, s + v));\n                }\n            } else if (5 == t && 2 == i.fmt) {\n                if (2 == i.fmt) {\n                    var c = o.readUshort(r, a);\n                    a += 2, i.cDef = e._lctf.readClassDef(r, s + c), i.scset = [];\n                    var p = o.readUshort(r, a);\n                    a += 2;\n                    for(f = 0; f < p; f++){\n                        var U = o.readUshort(r, a);\n                        a += 2, i.scset.push(0 == U ? null : e.GSUB.readSubClassSet(r, s + U));\n                    }\n                }\n            } else if (6 == t && 3 == i.fmt) {\n                if (3 == i.fmt) {\n                    for(f = 0; f < 3; f++){\n                        d = o.readUshort(r, a);\n                        a += 2;\n                        for(var g = [], S = 0; S < d; S++)g.push(e._lctf.readCoverage(r, s + o.readUshort(r, a + 2 * S)));\n                        a += 2 * d, 0 == f && (i.backCvg = g), 1 == f && (i.inptCvg = g), 2 == f && (i.ahedCvg = g);\n                    }\n                    d = o.readUshort(r, a);\n                    a += 2, i.lookupRec = e.GSUB.readSubstLookupRecords(r, a, d);\n                }\n            } else {\n                if (7 == t && 1 == i.fmt) {\n                    var m = o.readUshort(r, a);\n                    a += 2;\n                    var b = o.readUint(r, a);\n                    if (a += 4, 9 == n.ltype) n.ltype = m;\n                    else if (n.ltype != m) throw \"invalid extension substitution\";\n                    return e.GSUB.subt(r, n.ltype, s + b);\n                }\n                console.debug(\"unsupported GSUB table LookupType\", t, \"format\", i.fmt);\n            }\n            return i;\n        }, e.GSUB.readSubClassSet = function(r, t) {\n            var a = e._bin.readUshort, n = t, o = [], s = a(r, t);\n            t += 2;\n            for(var i = 0; i < s; i++){\n                var h = a(r, t);\n                t += 2, o.push(e.GSUB.readSubClassRule(r, n + h));\n            }\n            return o;\n        }, e.GSUB.readSubClassRule = function(r, t) {\n            var a = e._bin.readUshort, n = {}, o = a(r, t), s = a(r, t += 2);\n            t += 2, n.input = [];\n            for(var i = 0; i < o - 1; i++)n.input.push(a(r, t)), t += 2;\n            return n.substLookupRecords = e.GSUB.readSubstLookupRecords(r, t, s), n;\n        }, e.GSUB.readSubstLookupRecords = function(r, t, a) {\n            for(var n = e._bin.readUshort, o = [], s = 0; s < a; s++)o.push(n(r, t), n(r, t + 2)), t += 4;\n            return o;\n        }, e.GSUB.readChainSubClassSet = function(r, t) {\n            var a = e._bin, n = t, o = [], s = a.readUshort(r, t);\n            t += 2;\n            for(var i = 0; i < s; i++){\n                var h = a.readUshort(r, t);\n                t += 2, o.push(e.GSUB.readChainSubClassRule(r, n + h));\n            }\n            return o;\n        }, e.GSUB.readChainSubClassRule = function(r, t) {\n            for(var a = e._bin, n = {}, o = [\n                \"backtrack\",\n                \"input\",\n                \"lookahead\"\n            ], s = 0; s < o.length; s++){\n                var i = a.readUshort(r, t);\n                t += 2, 1 == s && i--, n[o[s]] = a.readUshorts(r, t, i), t += 2 * n[o[s]].length;\n            }\n            i = a.readUshort(r, t);\n            return t += 2, n.subst = a.readUshorts(r, t, 2 * i), t += 2 * n.subst.length, n;\n        }, e.GSUB.readLigatureSet = function(r, t) {\n            var a = e._bin, n = t, o = [], s = a.readUshort(r, t);\n            t += 2;\n            for(var i = 0; i < s; i++){\n                var h = a.readUshort(r, t);\n                t += 2, o.push(e.GSUB.readLigature(r, n + h));\n            }\n            return o;\n        }, e.GSUB.readLigature = function(r, t) {\n            var a = e._bin, n = {\n                chain: []\n            };\n            n.nglyph = a.readUshort(r, t), t += 2;\n            var o = a.readUshort(r, t);\n            t += 2;\n            for(var s = 0; s < o - 1; s++)n.chain.push(a.readUshort(r, t)), t += 2;\n            return n;\n        }, e.head = {}, e.head.parse = function(r, t, a) {\n            var n = e._bin, o = {};\n            return n.readFixed(r, t), t += 4, o.fontRevision = n.readFixed(r, t), t += 4, n.readUint(r, t), t += 4, n.readUint(r, t), t += 4, o.flags = n.readUshort(r, t), t += 2, o.unitsPerEm = n.readUshort(r, t), t += 2, o.created = n.readUint64(r, t), t += 8, o.modified = n.readUint64(r, t), t += 8, o.xMin = n.readShort(r, t), t += 2, o.yMin = n.readShort(r, t), t += 2, o.xMax = n.readShort(r, t), t += 2, o.yMax = n.readShort(r, t), t += 2, o.macStyle = n.readUshort(r, t), t += 2, o.lowestRecPPEM = n.readUshort(r, t), t += 2, o.fontDirectionHint = n.readShort(r, t), t += 2, o.indexToLocFormat = n.readShort(r, t), t += 2, o.glyphDataFormat = n.readShort(r, t), t += 2, o;\n        }, e.hhea = {}, e.hhea.parse = function(r, t, a) {\n            var n = e._bin, o = {};\n            return n.readFixed(r, t), t += 4, o.ascender = n.readShort(r, t), t += 2, o.descender = n.readShort(r, t), t += 2, o.lineGap = n.readShort(r, t), t += 2, o.advanceWidthMax = n.readUshort(r, t), t += 2, o.minLeftSideBearing = n.readShort(r, t), t += 2, o.minRightSideBearing = n.readShort(r, t), t += 2, o.xMaxExtent = n.readShort(r, t), t += 2, o.caretSlopeRise = n.readShort(r, t), t += 2, o.caretSlopeRun = n.readShort(r, t), t += 2, o.caretOffset = n.readShort(r, t), t += 2, t += 8, o.metricDataFormat = n.readShort(r, t), t += 2, o.numberOfHMetrics = n.readUshort(r, t), t += 2, o;\n        }, e.hmtx = {}, e.hmtx.parse = function(r, t, a, n) {\n            for(var o = e._bin, s = {\n                aWidth: [],\n                lsBearing: []\n            }, i = 0, h = 0, d = 0; d < n.maxp.numGlyphs; d++)d < n.hhea.numberOfHMetrics && (i = o.readUshort(r, t), t += 2, h = o.readShort(r, t), t += 2), s.aWidth.push(i), s.lsBearing.push(h);\n            return s;\n        }, e.kern = {}, e.kern.parse = function(r, t, a, n) {\n            var o = e._bin, s = o.readUshort(r, t);\n            if (t += 2, 1 == s) return e.kern.parseV1(r, t - 2, a, n);\n            var i = o.readUshort(r, t);\n            t += 2;\n            for(var h = {\n                glyph1: [],\n                rval: []\n            }, d = 0; d < i; d++){\n                t += 2;\n                a = o.readUshort(r, t);\n                t += 2;\n                var f = o.readUshort(r, t);\n                t += 2;\n                var u = f >>> 8;\n                if (0 != (u &= 15)) throw \"unknown kern table format: \" + u;\n                t = e.kern.readFormat0(r, t, h);\n            }\n            return h;\n        }, e.kern.parseV1 = function(r, t, a, n) {\n            var o = e._bin;\n            o.readFixed(r, t), t += 4;\n            var s = o.readUint(r, t);\n            t += 4;\n            for(var i = {\n                glyph1: [],\n                rval: []\n            }, h = 0; h < s; h++){\n                o.readUint(r, t), t += 4;\n                var d = o.readUshort(r, t);\n                t += 2, o.readUshort(r, t), t += 2;\n                var f = d >>> 8;\n                if (0 != (f &= 15)) throw \"unknown kern table format: \" + f;\n                t = e.kern.readFormat0(r, t, i);\n            }\n            return i;\n        }, e.kern.readFormat0 = function(r, t, a) {\n            var n = e._bin, o = -1, s = n.readUshort(r, t);\n            t += 2, n.readUshort(r, t), t += 2, n.readUshort(r, t), t += 2, n.readUshort(r, t), t += 2;\n            for(var i = 0; i < s; i++){\n                var h = n.readUshort(r, t);\n                t += 2;\n                var d = n.readUshort(r, t);\n                t += 2;\n                var f = n.readShort(r, t);\n                t += 2, h != o && (a.glyph1.push(h), a.rval.push({\n                    glyph2: [],\n                    vals: []\n                }));\n                var u = a.rval[a.rval.length - 1];\n                u.glyph2.push(d), u.vals.push(f), o = h;\n            }\n            return t;\n        }, e.loca = {}, e.loca.parse = function(r, t, a, n) {\n            var o = e._bin, s = [], i = n.head.indexToLocFormat, h = n.maxp.numGlyphs + 1;\n            if (0 == i) for(var d = 0; d < h; d++)s.push(o.readUshort(r, t + (d << 1)) << 1);\n            if (1 == i) for(d = 0; d < h; d++)s.push(o.readUint(r, t + (d << 2)));\n            return s;\n        }, e.maxp = {}, e.maxp.parse = function(r, t, a) {\n            var n = e._bin, o = {}, s = n.readUint(r, t);\n            return t += 4, o.numGlyphs = n.readUshort(r, t), t += 2, 65536 == s && (o.maxPoints = n.readUshort(r, t), t += 2, o.maxContours = n.readUshort(r, t), t += 2, o.maxCompositePoints = n.readUshort(r, t), t += 2, o.maxCompositeContours = n.readUshort(r, t), t += 2, o.maxZones = n.readUshort(r, t), t += 2, o.maxTwilightPoints = n.readUshort(r, t), t += 2, o.maxStorage = n.readUshort(r, t), t += 2, o.maxFunctionDefs = n.readUshort(r, t), t += 2, o.maxInstructionDefs = n.readUshort(r, t), t += 2, o.maxStackElements = n.readUshort(r, t), t += 2, o.maxSizeOfInstructions = n.readUshort(r, t), t += 2, o.maxComponentElements = n.readUshort(r, t), t += 2, o.maxComponentDepth = n.readUshort(r, t), t += 2), o;\n        }, e.name = {}, e.name.parse = function(r, t, a) {\n            var n = e._bin, o = {};\n            n.readUshort(r, t), t += 2;\n            var s = n.readUshort(r, t);\n            t += 2, n.readUshort(r, t);\n            for(var i, h = [\n                \"copyright\",\n                \"fontFamily\",\n                \"fontSubfamily\",\n                \"ID\",\n                \"fullName\",\n                \"version\",\n                \"postScriptName\",\n                \"trademark\",\n                \"manufacturer\",\n                \"designer\",\n                \"description\",\n                \"urlVendor\",\n                \"urlDesigner\",\n                \"licence\",\n                \"licenceURL\",\n                \"---\",\n                \"typoFamilyName\",\n                \"typoSubfamilyName\",\n                \"compatibleFull\",\n                \"sampleText\",\n                \"postScriptCID\",\n                \"wwsFamilyName\",\n                \"wwsSubfamilyName\",\n                \"lightPalette\",\n                \"darkPalette\"\n            ], d = t += 2, f = 0; f < s; f++){\n                var u = n.readUshort(r, t);\n                t += 2;\n                var l = n.readUshort(r, t);\n                t += 2;\n                var v = n.readUshort(r, t);\n                t += 2;\n                var c = n.readUshort(r, t);\n                t += 2;\n                var p = n.readUshort(r, t);\n                t += 2;\n                var U = n.readUshort(r, t);\n                t += 2;\n                var g, S = h[c], m = d + 12 * s + U;\n                if (0 == u) g = n.readUnicode(r, m, p / 2);\n                else if (3 == u && 0 == l) g = n.readUnicode(r, m, p / 2);\n                else if (0 == l) g = n.readASCII(r, m, p);\n                else if (1 == l) g = n.readUnicode(r, m, p / 2);\n                else if (3 == l) g = n.readUnicode(r, m, p / 2);\n                else {\n                    if (1 != u) throw \"unknown encoding \" + l + \", platformID: \" + u;\n                    g = n.readASCII(r, m, p), console.debug(\"reading unknown MAC encoding \" + l + \" as ASCII\");\n                }\n                var b = \"p\" + u + \",\" + v.toString(16);\n                null == o[b] && (o[b] = {}), o[b][void 0 !== S ? S : c] = g, o[b]._lang = v;\n            }\n            for(var y in o)if (null != o[y].postScriptName && 1033 == o[y]._lang) return o[y];\n            for(var y in o)if (null != o[y].postScriptName && 0 == o[y]._lang) return o[y];\n            for(var y in o)if (null != o[y].postScriptName && 3084 == o[y]._lang) return o[y];\n            for(var y in o)if (null != o[y].postScriptName) return o[y];\n            for(var y in o){\n                i = y;\n                break;\n            }\n            return console.debug(\"returning name table with languageID \" + o[i]._lang), o[i];\n        }, e[\"OS/2\"] = {}, e[\"OS/2\"].parse = function(r, t, a) {\n            var n = e._bin.readUshort(r, t);\n            t += 2;\n            var o = {};\n            if (0 == n) e[\"OS/2\"].version0(r, t, o);\n            else if (1 == n) e[\"OS/2\"].version1(r, t, o);\n            else if (2 == n || 3 == n || 4 == n) e[\"OS/2\"].version2(r, t, o);\n            else {\n                if (5 != n) throw \"unknown OS/2 table version: \" + n;\n                e[\"OS/2\"].version5(r, t, o);\n            }\n            return o;\n        }, e[\"OS/2\"].version0 = function(r, t, a) {\n            var n = e._bin;\n            return a.xAvgCharWidth = n.readShort(r, t), t += 2, a.usWeightClass = n.readUshort(r, t), t += 2, a.usWidthClass = n.readUshort(r, t), t += 2, a.fsType = n.readUshort(r, t), t += 2, a.ySubscriptXSize = n.readShort(r, t), t += 2, a.ySubscriptYSize = n.readShort(r, t), t += 2, a.ySubscriptXOffset = n.readShort(r, t), t += 2, a.ySubscriptYOffset = n.readShort(r, t), t += 2, a.ySuperscriptXSize = n.readShort(r, t), t += 2, a.ySuperscriptYSize = n.readShort(r, t), t += 2, a.ySuperscriptXOffset = n.readShort(r, t), t += 2, a.ySuperscriptYOffset = n.readShort(r, t), t += 2, a.yStrikeoutSize = n.readShort(r, t), t += 2, a.yStrikeoutPosition = n.readShort(r, t), t += 2, a.sFamilyClass = n.readShort(r, t), t += 2, a.panose = n.readBytes(r, t, 10), t += 10, a.ulUnicodeRange1 = n.readUint(r, t), t += 4, a.ulUnicodeRange2 = n.readUint(r, t), t += 4, a.ulUnicodeRange3 = n.readUint(r, t), t += 4, a.ulUnicodeRange4 = n.readUint(r, t), t += 4, a.achVendID = [\n                n.readInt8(r, t),\n                n.readInt8(r, t + 1),\n                n.readInt8(r, t + 2),\n                n.readInt8(r, t + 3)\n            ], t += 4, a.fsSelection = n.readUshort(r, t), t += 2, a.usFirstCharIndex = n.readUshort(r, t), t += 2, a.usLastCharIndex = n.readUshort(r, t), t += 2, a.sTypoAscender = n.readShort(r, t), t += 2, a.sTypoDescender = n.readShort(r, t), t += 2, a.sTypoLineGap = n.readShort(r, t), t += 2, a.usWinAscent = n.readUshort(r, t), t += 2, a.usWinDescent = n.readUshort(r, t), t += 2;\n        }, e[\"OS/2\"].version1 = function(r, t, a) {\n            var n = e._bin;\n            return t = e[\"OS/2\"].version0(r, t, a), a.ulCodePageRange1 = n.readUint(r, t), t += 4, a.ulCodePageRange2 = n.readUint(r, t), t += 4;\n        }, e[\"OS/2\"].version2 = function(r, t, a) {\n            var n = e._bin;\n            return t = e[\"OS/2\"].version1(r, t, a), a.sxHeight = n.readShort(r, t), t += 2, a.sCapHeight = n.readShort(r, t), t += 2, a.usDefault = n.readUshort(r, t), t += 2, a.usBreak = n.readUshort(r, t), t += 2, a.usMaxContext = n.readUshort(r, t), t += 2;\n        }, e[\"OS/2\"].version5 = function(r, t, a) {\n            var n = e._bin;\n            return t = e[\"OS/2\"].version2(r, t, a), a.usLowerOpticalPointSize = n.readUshort(r, t), t += 2, a.usUpperOpticalPointSize = n.readUshort(r, t), t += 2;\n        }, e.post = {}, e.post.parse = function(r, t, a) {\n            var n = e._bin, o = {};\n            return o.version = n.readFixed(r, t), t += 4, o.italicAngle = n.readFixed(r, t), t += 4, o.underlinePosition = n.readShort(r, t), t += 2, o.underlineThickness = n.readShort(r, t), t += 2, o;\n        }, null == e && (e = {}), null == e.U && (e.U = {}), e.U.codeToGlyph = function(r, e) {\n            var t = r.cmap, a = -1;\n            if (null != t.p0e4 ? a = t.p0e4 : null != t.p3e1 ? a = t.p3e1 : null != t.p1e0 ? a = t.p1e0 : null != t.p0e3 && (a = t.p0e3), -1 == a) throw \"no familiar platform and encoding!\";\n            var n = t.tables[a];\n            if (0 == n.format) return e >= n.map.length ? 0 : n.map[e];\n            if (4 == n.format) {\n                for(var o = -1, s = 0; s < n.endCount.length; s++)if (e <= n.endCount[s]) {\n                    o = s;\n                    break;\n                }\n                if (-1 == o) return 0;\n                if (n.startCount[o] > e) return 0;\n                return 65535 & (0 != n.idRangeOffset[o] ? n.glyphIdArray[e - n.startCount[o] + (n.idRangeOffset[o] >> 1) - (n.idRangeOffset.length - o)] : e + n.idDelta[o]);\n            }\n            if (12 == n.format) {\n                if (e > n.groups[n.groups.length - 1][1]) return 0;\n                for(s = 0; s < n.groups.length; s++){\n                    var i = n.groups[s];\n                    if (i[0] <= e && e <= i[1]) return i[2] + (e - i[0]);\n                }\n                return 0;\n            }\n            throw \"unknown cmap table format \" + n.format;\n        }, e.U.glyphToPath = function(r, t) {\n            var a = {\n                cmds: [],\n                crds: []\n            };\n            if (r.SVG && r.SVG.entries[t]) {\n                var n = r.SVG.entries[t];\n                return null == n ? a : (\"string\" == typeof n && (n = e.SVG.toPath(n), r.SVG.entries[t] = n), n);\n            }\n            if (r.CFF) {\n                var o = {\n                    x: 0,\n                    y: 0,\n                    stack: [],\n                    nStems: 0,\n                    haveWidth: !1,\n                    width: r.CFF.Private ? r.CFF.Private.defaultWidthX : 0,\n                    open: !1\n                }, s = r.CFF, i = r.CFF.Private;\n                if (s.ROS) {\n                    for(var h = 0; s.FDSelect[h + 2] <= t;)h += 2;\n                    i = s.FDArray[s.FDSelect[h + 1]].Private;\n                }\n                e.U._drawCFF(r.CFF.CharStrings[t], o, s, i, a);\n            } else r.glyf && e.U._drawGlyf(t, r, a);\n            return a;\n        }, e.U._drawGlyf = function(r, t, a) {\n            var n = t.glyf[r];\n            null == n && (n = t.glyf[r] = e.glyf._parseGlyf(t, r)), null != n && (n.noc > -1 ? e.U._simpleGlyph(n, a) : e.U._compoGlyph(n, t, a));\n        }, e.U._simpleGlyph = function(r, t) {\n            for(var a = 0; a < r.noc; a++){\n                for(var n = 0 == a ? 0 : r.endPts[a - 1] + 1, o = r.endPts[a], s = n; s <= o; s++){\n                    var i = s == n ? o : s - 1, h = s == o ? n : s + 1, d = 1 & r.flags[s], f = 1 & r.flags[i], u = 1 & r.flags[h], l = r.xs[s], v = r.ys[s];\n                    if (s == n) if (d) {\n                        if (!f) {\n                            e.U.P.moveTo(t, l, v);\n                            continue;\n                        }\n                        e.U.P.moveTo(t, r.xs[i], r.ys[i]);\n                    } else f ? e.U.P.moveTo(t, r.xs[i], r.ys[i]) : e.U.P.moveTo(t, (r.xs[i] + l) / 2, (r.ys[i] + v) / 2);\n                    d ? f && e.U.P.lineTo(t, l, v) : u ? e.U.P.qcurveTo(t, l, v, r.xs[h], r.ys[h]) : e.U.P.qcurveTo(t, l, v, (l + r.xs[h]) / 2, (v + r.ys[h]) / 2);\n                }\n                e.U.P.closePath(t);\n            }\n        }, e.U._compoGlyph = function(r, t, a) {\n            for(var n = 0; n < r.parts.length; n++){\n                var o = {\n                    cmds: [],\n                    crds: []\n                }, s = r.parts[n];\n                e.U._drawGlyf(s.glyphIndex, t, o);\n                for(var i = s.m, h = 0; h < o.crds.length; h += 2){\n                    var d = o.crds[h], f = o.crds[h + 1];\n                    a.crds.push(d * i.a + f * i.b + i.tx), a.crds.push(d * i.c + f * i.d + i.ty);\n                }\n                for(h = 0; h < o.cmds.length; h++)a.cmds.push(o.cmds[h]);\n            }\n        }, e.U._getGlyphClass = function(r, t) {\n            var a = e._lctf.getInterval(t, r);\n            return -1 == a ? 0 : t[a + 2];\n        }, e.U._applySubs = function(r, t, a, n) {\n            for(var o = r.length - t - 1, s = 0; s < a.tabs.length; s++)if (null != a.tabs[s]) {\n                var i, h = a.tabs[s];\n                if (!h.coverage || -1 != (i = e._lctf.coverageIndex(h.coverage, r[t]))) {\n                    if (1 == a.ltype) r[t], 1 == h.fmt ? r[t] = r[t] + h.delta : r[t] = h.newg[i];\n                    else if (4 == a.ltype) for(var d = h.vals[i], f = 0; f < d.length; f++){\n                        var u = d[f], l = u.chain.length;\n                        if (!(l > o)) {\n                            for(var v = !0, c = 0, p = 0; p < l; p++){\n                                for(; -1 == r[t + c + (1 + p)];)c++;\n                                u.chain[p] != r[t + c + (1 + p)] && (v = !1);\n                            }\n                            if (v) {\n                                r[t] = u.nglyph;\n                                for(p = 0; p < l + c; p++)r[t + p + 1] = -1;\n                                break;\n                            }\n                        }\n                    }\n                    else if (5 == a.ltype && 2 == h.fmt) for(var U = e._lctf.getInterval(h.cDef, r[t]), g = h.cDef[U + 2], S = h.scset[g], m = 0; m < S.length; m++){\n                        var b = S[m], y = b.input;\n                        if (!(y.length > o)) {\n                            for(v = !0, p = 0; p < y.length; p++){\n                                var F = e._lctf.getInterval(h.cDef, r[t + 1 + p]);\n                                if (-1 == U && h.cDef[F + 2] != y[p]) {\n                                    v = !1;\n                                    break;\n                                }\n                            }\n                            if (v) {\n                                var C = b.substLookupRecords;\n                                for(f = 0; f < C.length; f += 2)C[f], C[f + 1];\n                            }\n                        }\n                    }\n                    else if (6 == a.ltype && 3 == h.fmt) {\n                        if (!e.U._glsCovered(r, h.backCvg, t - h.backCvg.length)) continue;\n                        if (!e.U._glsCovered(r, h.inptCvg, t)) continue;\n                        if (!e.U._glsCovered(r, h.ahedCvg, t + h.inptCvg.length)) continue;\n                        var _ = h.lookupRec;\n                        for(m = 0; m < _.length; m += 2){\n                            U = _[m];\n                            var P = n[_[m + 1]];\n                            e.U._applySubs(r, t + U, P, n);\n                        }\n                    }\n                }\n            }\n        }, e.U._glsCovered = function(r, t, a) {\n            for(var n = 0; n < t.length; n++){\n                if (-1 == e._lctf.coverageIndex(t[n], r[a + n])) return !1;\n            }\n            return !0;\n        }, e.U.glyphsToPath = function(r, t, a) {\n            for(var n = {\n                cmds: [],\n                crds: []\n            }, o = 0, s = 0; s < t.length; s++){\n                var i = t[s];\n                if (-1 != i) {\n                    for(var h = s < t.length - 1 && -1 != t[s + 1] ? t[s + 1] : 0, d = e.U.glyphToPath(r, i), f = 0; f < d.crds.length; f += 2)n.crds.push(d.crds[f] + o), n.crds.push(d.crds[f + 1]);\n                    a && n.cmds.push(a);\n                    for(f = 0; f < d.cmds.length; f++)n.cmds.push(d.cmds[f]);\n                    a && n.cmds.push(\"X\"), o += r.hmtx.aWidth[i], s < t.length - 1 && (o += e.U.getPairAdjustment(r, i, h));\n                }\n            }\n            return n;\n        }, e.U.P = {}, e.U.P.moveTo = function(r, e, t) {\n            r.cmds.push(\"M\"), r.crds.push(e, t);\n        }, e.U.P.lineTo = function(r, e, t) {\n            r.cmds.push(\"L\"), r.crds.push(e, t);\n        }, e.U.P.curveTo = function(r, e, t, a, n, o, s) {\n            r.cmds.push(\"C\"), r.crds.push(e, t, a, n, o, s);\n        }, e.U.P.qcurveTo = function(r, e, t, a, n) {\n            r.cmds.push(\"Q\"), r.crds.push(e, t, a, n);\n        }, e.U.P.closePath = function(r) {\n            r.cmds.push(\"Z\");\n        }, e.U._drawCFF = function(r, t, a, n, o) {\n            for(var s = t.stack, i = t.nStems, h = t.haveWidth, d = t.width, f = t.open, u = 0, l = t.x, v = t.y, c = 0, p = 0, U = 0, g = 0, S = 0, m = 0, b = 0, y = 0, F = 0, C = 0, _ = {\n                val: 0,\n                size: 0\n            }; u < r.length;){\n                e.CFF.getCharString(r, u, _);\n                var P = _.val;\n                if (u += _.size, \"o1\" == P || \"o18\" == P) s.length % 2 != 0 && !h && (d = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = !0;\n                else if (\"o3\" == P || \"o23\" == P) {\n                    s.length % 2 != 0 && !h && (d = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = !0;\n                } else if (\"o4\" == P) s.length > 1 && !h && (d = s.shift() + n.nominalWidthX, h = !0), f && e.U.P.closePath(o), v += s.pop(), e.U.P.moveTo(o, l, v), f = !0;\n                else if (\"o5\" == P) for(; s.length > 0;)l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v);\n                else if (\"o6\" == P || \"o7\" == P) for(var x = s.length, I = \"o6\" == P, w = 0; w < x; w++){\n                    var k = s.shift();\n                    I ? l += k : v += k, I = !I, e.U.P.lineTo(o, l, v);\n                }\n                else if (\"o8\" == P || \"o24\" == P) {\n                    x = s.length;\n                    for(var G = 0; G + 6 <= x;)c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), l = U + s.shift(), v = g + s.shift(), e.U.P.curveTo(o, c, p, U, g, l, v), G += 6;\n                    \"o24\" == P && (l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v));\n                } else {\n                    if (\"o11\" == P) break;\n                    if (\"o1234\" == P || \"o1235\" == P || \"o1236\" == P || \"o1237\" == P) \"o1234\" == P && (p = v, U = (c = l + s.shift()) + s.shift(), C = g = p + s.shift(), m = g, y = v, l = (b = (S = (F = U + s.shift()) + s.shift()) + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U, g, F, C), e.U.P.curveTo(o, S, m, b, y, l, v)), \"o1235\" == P && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), F = U + s.shift(), C = g + s.shift(), S = F + s.shift(), m = C + s.shift(), b = S + s.shift(), y = m + s.shift(), l = b + s.shift(), v = y + s.shift(), s.shift(), e.U.P.curveTo(o, c, p, U, g, F, C), e.U.P.curveTo(o, S, m, b, y, l, v)), \"o1236\" == P && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), C = g = p + s.shift(), m = g, b = (S = (F = U + s.shift()) + s.shift()) + s.shift(), y = m + s.shift(), l = b + s.shift(), e.U.P.curveTo(o, c, p, U, g, F, C), e.U.P.curveTo(o, S, m, b, y, l, v)), \"o1237\" == P && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), F = U + s.shift(), C = g + s.shift(), S = F + s.shift(), m = C + s.shift(), b = S + s.shift(), y = m + s.shift(), Math.abs(b - l) > Math.abs(y - v) ? l = b + s.shift() : v = y + s.shift(), e.U.P.curveTo(o, c, p, U, g, F, C), e.U.P.curveTo(o, S, m, b, y, l, v));\n                    else if (\"o14\" == P) {\n                        if (s.length > 0 && !h && (d = s.shift() + a.nominalWidthX, h = !0), 4 == s.length) {\n                            var O = s.shift(), T = s.shift(), D = s.shift(), B = s.shift(), A = e.CFF.glyphBySE(a, D), R = e.CFF.glyphBySE(a, B);\n                            e.U._drawCFF(a.CharStrings[A], t, a, n, o), t.x = O, t.y = T, e.U._drawCFF(a.CharStrings[R], t, a, n, o);\n                        }\n                        f && (e.U.P.closePath(o), f = !1);\n                    } else if (\"o19\" == P || \"o20\" == P) {\n                        s.length % 2 != 0 && !h && (d = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = !0, u += i + 7 >> 3;\n                    } else if (\"o21\" == P) s.length > 2 && !h && (d = s.shift() + n.nominalWidthX, h = !0), v += s.pop(), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v), f = !0;\n                    else if (\"o22\" == P) s.length > 1 && !h && (d = s.shift() + n.nominalWidthX, h = !0), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v), f = !0;\n                    else if (\"o25\" == P) {\n                        for(; s.length > 6;)l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v);\n                        c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), l = U + s.shift(), v = g + s.shift(), e.U.P.curveTo(o, c, p, U, g, l, v);\n                    } else if (\"o26\" == P) for(s.length % 2 && (l += s.shift()); s.length > 0;)c = l, p = v + s.shift(), l = U = c + s.shift(), v = (g = p + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U, g, l, v);\n                    else if (\"o27\" == P) for(s.length % 2 && (v += s.shift()); s.length > 0;)p = v, U = (c = l + s.shift()) + s.shift(), g = p + s.shift(), l = U + s.shift(), v = g, e.U.P.curveTo(o, c, p, U, g, l, v);\n                    else if (\"o10\" == P || \"o29\" == P) {\n                        var L = \"o10\" == P ? n : a;\n                        if (0 == s.length) console.debug(\"error: empty stack\");\n                        else {\n                            var W = s.pop(), M = L.Subrs[W + L.Bias];\n                            t.x = l, t.y = v, t.nStems = i, t.haveWidth = h, t.width = d, t.open = f, e.U._drawCFF(M, t, a, n, o), l = t.x, v = t.y, i = t.nStems, h = t.haveWidth, d = t.width, f = t.open;\n                        }\n                    } else if (\"o30\" == P || \"o31\" == P) {\n                        var V = s.length, E = (G = 0, \"o31\" == P);\n                        for(G += V - (x = -3 & V); G < x;)E ? (p = v, U = (c = l + s.shift()) + s.shift(), v = (g = p + s.shift()) + s.shift(), x - G == 5 ? (l = U + s.shift(), G++) : l = U, E = !1) : (c = l, p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), l = U + s.shift(), x - G == 5 ? (v = g + s.shift(), G++) : v = g, E = !0), e.U.P.curveTo(o, c, p, U, g, l, v), G += 4;\n                    } else {\n                        if (\"o\" == (P + \"\").charAt(0)) throw console.debug(\"Unknown operation: \" + P, r), P;\n                        s.push(P);\n                    }\n                }\n            }\n            t.x = l, t.y = v, t.nStems = i, t.haveWidth = h, t.width = d, t.open = f;\n        };\n        var t = e, a = {\n            Typr: t\n        };\n        return r.Typr = t, r.default = a, Object.defineProperty(r, \"__esModule\", {\n            value: !0\n        }), r;\n    }({}).Typr;\n}\n/*!\nCustom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate\n(https://github.com/101arrowz/fflate) for use in Troika text rendering. \nOriginal licenses apply: \n- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)\n- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)\n*/ function woff2otfFactory() {\n    return function(r) {\n        var e = Uint8Array, n = Uint16Array, t = Uint32Array, a = new e([\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            1,\n            1,\n            1,\n            2,\n            2,\n            2,\n            2,\n            3,\n            3,\n            3,\n            3,\n            4,\n            4,\n            4,\n            4,\n            5,\n            5,\n            5,\n            5,\n            0,\n            0,\n            0,\n            0\n        ]), i = new e([\n            0,\n            0,\n            0,\n            0,\n            1,\n            1,\n            2,\n            2,\n            3,\n            3,\n            4,\n            4,\n            5,\n            5,\n            6,\n            6,\n            7,\n            7,\n            8,\n            8,\n            9,\n            9,\n            10,\n            10,\n            11,\n            11,\n            12,\n            12,\n            13,\n            13,\n            0,\n            0\n        ]), o = new e([\n            16,\n            17,\n            18,\n            0,\n            8,\n            7,\n            9,\n            6,\n            10,\n            5,\n            11,\n            4,\n            12,\n            3,\n            13,\n            2,\n            14,\n            1,\n            15\n        ]), f = function(r, e) {\n            for(var a = new n(31), i = 0; i < 31; ++i)a[i] = e += 1 << r[i - 1];\n            var o = new t(a[30]);\n            for(i = 1; i < 30; ++i)for(var f = a[i]; f < a[i + 1]; ++f)o[f] = f - a[i] << 5 | i;\n            return [\n                a,\n                o\n            ];\n        }, u = f(a, 2), v = u[0], s = u[1];\n        v[28] = 258, s[258] = 28;\n        for(var l = f(i, 0)[0], c = new n(32768), g = 0; g < 32768; ++g){\n            var h = (43690 & g) >>> 1 | (21845 & g) << 1;\n            h = (61680 & (h = (52428 & h) >>> 2 | (13107 & h) << 2)) >>> 4 | (3855 & h) << 4, c[g] = ((65280 & h) >>> 8 | (255 & h) << 8) >>> 1;\n        }\n        var w = function(r, e, t) {\n            for(var a = r.length, i = 0, o = new n(e); i < a; ++i)++o[r[i] - 1];\n            var f, u = new n(e);\n            for(i = 0; i < e; ++i)u[i] = u[i - 1] + o[i - 1] << 1;\n            if (t) {\n                f = new n(1 << e);\n                var v = 15 - e;\n                for(i = 0; i < a; ++i)if (r[i]) for(var s = i << 4 | r[i], l = e - r[i], g = u[r[i] - 1]++ << l, h = g | (1 << l) - 1; g <= h; ++g)f[c[g] >>> v] = s;\n            } else for(f = new n(a), i = 0; i < a; ++i)r[i] && (f[i] = c[u[r[i] - 1]++] >>> 15 - r[i]);\n            return f;\n        }, d = new e(288);\n        for(g = 0; g < 144; ++g)d[g] = 8;\n        for(g = 144; g < 256; ++g)d[g] = 9;\n        for(g = 256; g < 280; ++g)d[g] = 7;\n        for(g = 280; g < 288; ++g)d[g] = 8;\n        var m = new e(32);\n        for(g = 0; g < 32; ++g)m[g] = 5;\n        var b = w(d, 9, 1), p = w(m, 5, 1), y = function(r) {\n            for(var e = r[0], n = 1; n < r.length; ++n)r[n] > e && (e = r[n]);\n            return e;\n        }, L = function(r, e, n) {\n            var t = e / 8 | 0;\n            return (r[t] | r[t + 1] << 8) >> (7 & e) & n;\n        }, U = function(r, e) {\n            var n = e / 8 | 0;\n            return (r[n] | r[n + 1] << 8 | r[n + 2] << 16) >> (7 & e);\n        }, k = [\n            \"unexpected EOF\",\n            \"invalid block type\",\n            \"invalid length/literal\",\n            \"invalid distance\",\n            \"stream finished\",\n            \"no stream handler\",\n            ,\n            \"no callback\",\n            \"invalid UTF-8 data\",\n            \"extra field too long\",\n            \"date not in range 1980-2099\",\n            \"filename too long\",\n            \"stream finishing\",\n            \"invalid zip data\"\n        ], T = function(r, e, n) {\n            var t = new Error(e || k[r]);\n            if (t.code = r, Error.captureStackTrace && Error.captureStackTrace(t, T), !n) throw t;\n            return t;\n        }, O = function(r, f, u) {\n            var s = r.length;\n            if (!s || u && !u.l && s < 5) return f || new e(0);\n            var c = !f || u, g = !u || u.i;\n            u || (u = {}), f || (f = new e(3 * s));\n            var h, d = function(r) {\n                var n = f.length;\n                if (r > n) {\n                    var t = new e(Math.max(2 * n, r));\n                    t.set(f), f = t;\n                }\n            }, m = u.f || 0, k = u.p || 0, O = u.b || 0, A = u.l, x = u.d, E = u.m, D = u.n, M = 8 * s;\n            do {\n                if (!A) {\n                    u.f = m = L(r, k, 1);\n                    var S = L(r, k + 1, 3);\n                    if (k += 3, !S) {\n                        var V = r[(I = ((h = k) / 8 | 0) + (7 & h && 1) + 4) - 4] | r[I - 3] << 8, _ = I + V;\n                        if (_ > s) {\n                            g && T(0);\n                            break;\n                        }\n                        c && d(O + V), f.set(r.subarray(I, _), O), u.b = O += V, u.p = k = 8 * _;\n                        continue;\n                    }\n                    if (1 == S) A = b, x = p, E = 9, D = 5;\n                    else if (2 == S) {\n                        var j = L(r, k, 31) + 257, z = L(r, k + 10, 15) + 4, C = j + L(r, k + 5, 31) + 1;\n                        k += 14;\n                        for(var F = new e(C), P = new e(19), q = 0; q < z; ++q)P[o[q]] = L(r, k + 3 * q, 7);\n                        k += 3 * z;\n                        var B = y(P), G = (1 << B) - 1, H = w(P, B, 1);\n                        for(q = 0; q < C;){\n                            var I, J = H[L(r, k, G)];\n                            if (k += 15 & J, (I = J >>> 4) < 16) F[q++] = I;\n                            else {\n                                var K = 0, N = 0;\n                                for(16 == I ? (N = 3 + L(r, k, 3), k += 2, K = F[q - 1]) : 17 == I ? (N = 3 + L(r, k, 7), k += 3) : 18 == I && (N = 11 + L(r, k, 127), k += 7); N--;)F[q++] = K;\n                            }\n                        }\n                        var Q = F.subarray(0, j), R = F.subarray(j);\n                        E = y(Q), D = y(R), A = w(Q, E, 1), x = w(R, D, 1);\n                    } else T(1);\n                    if (k > M) {\n                        g && T(0);\n                        break;\n                    }\n                }\n                c && d(O + 131072);\n                for(var W = (1 << E) - 1, X = (1 << D) - 1, Y = k;; Y = k){\n                    var Z = (K = A[U(r, k) & W]) >>> 4;\n                    if ((k += 15 & K) > M) {\n                        g && T(0);\n                        break;\n                    }\n                    if (K || T(2), Z < 256) f[O++] = Z;\n                    else {\n                        if (256 == Z) {\n                            Y = k, A = null;\n                            break;\n                        }\n                        var $ = Z - 254;\n                        if (Z > 264) {\n                            var rr = a[q = Z - 257];\n                            $ = L(r, k, (1 << rr) - 1) + v[q], k += rr;\n                        }\n                        var er = x[U(r, k) & X], nr = er >>> 4;\n                        er || T(3), k += 15 & er;\n                        R = l[nr];\n                        if (nr > 3) {\n                            rr = i[nr];\n                            R += U(r, k) & (1 << rr) - 1, k += rr;\n                        }\n                        if (k > M) {\n                            g && T(0);\n                            break;\n                        }\n                        c && d(O + 131072);\n                        for(var tr = O + $; O < tr; O += 4)f[O] = f[O - R], f[O + 1] = f[O + 1 - R], f[O + 2] = f[O + 2 - R], f[O + 3] = f[O + 3 - R];\n                        O = tr;\n                    }\n                }\n                u.l = A, u.p = Y, u.b = O, A && (m = 1, u.m = E, u.d = x, u.n = D);\n            }while (!m);\n            return O == f.length ? f : function(r, a, i) {\n                (null == a || a < 0) && (a = 0), (null == i || i > r.length) && (i = r.length);\n                var o = new (r instanceof n ? n : r instanceof t ? t : e)(i - a);\n                return o.set(r.subarray(a, i)), o;\n            }(f, 0, O);\n        }, A = new e(0);\n        var x = \"undefined\" != typeof TextDecoder && new TextDecoder;\n        try {\n            x.decode(A, {\n                stream: !0\n            }), 1;\n        } catch (r) {}\n        return r.convert_streams = function(r) {\n            var e = new DataView(r), n = 0;\n            function t() {\n                var r = e.getUint16(n);\n                return n += 2, r;\n            }\n            function a() {\n                var r = e.getUint32(n);\n                return n += 4, r;\n            }\n            function i(r) {\n                m.setUint16(b, r), b += 2;\n            }\n            function o(r) {\n                m.setUint32(b, r), b += 4;\n            }\n            for(var f = {\n                signature: a(),\n                flavor: a(),\n                length: a(),\n                numTables: t(),\n                reserved: t(),\n                totalSfntSize: a(),\n                majorVersion: t(),\n                minorVersion: t(),\n                metaOffset: a(),\n                metaLength: a(),\n                metaOrigLength: a(),\n                privOffset: a(),\n                privLength: a()\n            }, u = 0; Math.pow(2, u) <= f.numTables;)u++;\n            u--;\n            for(var v = 16 * Math.pow(2, u), s = 16 * f.numTables - v, l = 12, c = [], g = 0; g < f.numTables; g++)c.push({\n                tag: a(),\n                offset: a(),\n                compLength: a(),\n                origLength: a(),\n                origChecksum: a()\n            }), l += 16;\n            var h, w = new Uint8Array(12 + 16 * c.length + c.reduce(function(r, e) {\n                return r + e.origLength + 4;\n            }, 0)), d = w.buffer, m = new DataView(d), b = 0;\n            return o(f.flavor), i(f.numTables), i(v), i(u), i(s), c.forEach(function(r) {\n                o(r.tag), o(r.origChecksum), o(l), o(r.origLength), r.outOffset = l, (l += r.origLength) % 4 != 0 && (l += 4 - l % 4);\n            }), c.forEach(function(e) {\n                var n, t = r.slice(e.offset, e.offset + e.compLength);\n                if (e.compLength != e.origLength) {\n                    var a = new Uint8Array(e.origLength);\n                    n = new Uint8Array(t, 2), O(n, a);\n                } else a = new Uint8Array(t);\n                w.set(a, e.outOffset);\n                var i = 0;\n                (l = e.outOffset + e.origLength) % 4 != 0 && (i = 4 - l % 4), w.set(new Uint8Array(i).buffer, e.outOffset + e.origLength), h = l + i;\n            }), d.slice(0, h);\n        }, Object.defineProperty(r, \"__esModule\", {\n            value: !0\n        }), r;\n    }({}).convert_streams;\n}\n/**\n * A factory wrapper parsing a font file using Typr.\n * Also adds support for WOFF files (not WOFF2).\n */ /**\n * @typedef ParsedFont\n * @property {number} ascender\n * @property {number} descender\n * @property {number} xHeight\n * @property {(number) => boolean} supportsCodePoint\n * @property {(text:string, fontSize:number, letterSpacing:number, callback) => number} forEachGlyph\n * @property {number} lineGap\n * @property {number} capHeight\n * @property {number} unitsPerEm\n */ /**\n * @typedef {(buffer: ArrayBuffer) => ParsedFont} FontParser\n */ /**\n * @returns {FontParser}\n */ function parserFactory(Typr, woff2otf) {\n    const cmdArgLengths = {\n        M: 2,\n        L: 2,\n        Q: 4,\n        C: 6,\n        Z: 0\n    };\n    // {joinType: \"skip+step,...\"}\n    const joiningTypeRawData = {\n        \"C\": \"18g,ca,368,1kz\",\n        \"D\": \"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v\",\n        \"R\": \"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6\",\n        \"L\": \"x9u,jff,a,fd,jv\",\n        \"T\": \"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n\"\n    };\n    const JT_LEFT = 1, JT_RIGHT = 2, JT_DUAL = 4, JT_TRANSPARENT = 8, JT_JOIN_CAUSING = 16, JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,\n    let joiningTypeMap;\n    function getCharJoiningType(ch) {\n        if (!joiningTypeMap) {\n            const m = {\n                R: JT_RIGHT,\n                L: JT_LEFT,\n                D: JT_DUAL,\n                C: JT_JOIN_CAUSING,\n                U: JT_NON_JOINING,\n                T: JT_TRANSPARENT\n            };\n            joiningTypeMap = new Map();\n            for(let type in joiningTypeRawData){\n                let lastCode = 0;\n                joiningTypeRawData[type].split(\",\").forEach((range)=>{\n                    let [skip, step] = range.split(\"+\");\n                    skip = parseInt(skip, 36);\n                    step = step ? parseInt(step, 36) : 0;\n                    joiningTypeMap.set(lastCode += skip, m[type]);\n                    for(let i = step; i--;){\n                        joiningTypeMap.set(++lastCode, m[type]);\n                    }\n                });\n            }\n        }\n        return joiningTypeMap.get(ch) || JT_NON_JOINING;\n    }\n    const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;\n    const formsToFeatures = [\n        null,\n        \"isol\",\n        \"init\",\n        \"fina\",\n        \"medi\"\n    ];\n    function detectJoiningForms(str) {\n        // This implements the algorithm described here:\n        // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md\n        const joiningForms = new Uint8Array(str.length);\n        let prevJoiningType = JT_NON_JOINING;\n        let prevForm = ISOL;\n        let prevIndex = -1;\n        for(let i = 0; i < str.length; i++){\n            const code = str.codePointAt(i);\n            let joiningType = getCharJoiningType(code) | 0;\n            let form = ISOL;\n            if (joiningType & JT_TRANSPARENT) {\n                continue;\n            }\n            if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {\n                if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {\n                    form = FINA;\n                    // isol->init, fina->medi\n                    if (prevForm === ISOL || prevForm === FINA) {\n                        joiningForms[prevIndex]++;\n                    }\n                } else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {\n                    // medi->fina, init->isol\n                    if (prevForm === INIT || prevForm === MEDI) {\n                        joiningForms[prevIndex]--;\n                    }\n                }\n            } else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {\n                // medi->fina, init->isol\n                if (prevForm === INIT || prevForm === MEDI) {\n                    joiningForms[prevIndex]--;\n                }\n            }\n            prevForm = joiningForms[i] = form;\n            prevJoiningType = joiningType;\n            prevIndex = i;\n            if (code > 0xffff) i++;\n        }\n        // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))\n        // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))\n        // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))\n        return joiningForms;\n    }\n    function stringToGlyphs(font, str) {\n        const glyphIds = [];\n        for(let i = 0; i < str.length; i++){\n            const cc = str.codePointAt(i);\n            if (cc > 0xffff) i++;\n            glyphIds.push(Typr.U.codeToGlyph(font, cc));\n        }\n        const gsub = font[\"GSUB\"];\n        if (gsub) {\n            const { lookupList, featureList } = gsub;\n            let joiningForms;\n            const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/;\n            const usedLookups = [];\n            featureList.forEach((feature)=>{\n                if (supportedFeatures.test(feature.tag)) {\n                    for(let ti = 0; ti < feature.tab.length; ti++){\n                        if (usedLookups[feature.tab[ti]]) continue;\n                        usedLookups[feature.tab[ti]] = true;\n                        const tab = lookupList[feature.tab[ti]];\n                        const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);\n                        if (isJoiningFeature && !joiningForms) {\n                            joiningForms = detectJoiningForms(str);\n                        }\n                        for(let ci = 0; ci < glyphIds.length; ci++){\n                            if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {\n                                Typr.U._applySubs(glyphIds, ci, tab, lookupList);\n                            }\n                        }\n                    }\n                }\n            });\n        }\n        return glyphIds;\n    }\n    // Calculate advances and x/y offsets for each glyph, e.g. kerning and mark\n    // attachments. This is a more complete version of Typr.U.getPairAdjustment\n    // and should become an upstream replacement eventually.\n    function calcGlyphPositions(font, glyphIds) {\n        const positions = new Int16Array(glyphIds.length * 3); // [offsetX, offsetY, advanceX, ...]\n        let glyphIndex = 0;\n        for(; glyphIndex < glyphIds.length; glyphIndex++){\n            const glyphId = glyphIds[glyphIndex];\n            if (glyphId === -1) continue;\n            positions[glyphIndex * 3 + 2] = font.hmtx.aWidth[glyphId]; // populate advanceX in...advance.\n            const gpos = font.GPOS;\n            if (gpos) {\n                const llist = gpos.lookupList;\n                for(let i = 0; i < llist.length; i++){\n                    const lookup = llist[i];\n                    for(let j = 0; j < lookup.tabs.length; j++){\n                        const tab = lookup.tabs[j];\n                        // Single char placement\n                        if (lookup.ltype === 1) {\n                            const ind = Typr._lctf.coverageIndex(tab.coverage, glyphId);\n                            if (ind !== -1 && tab.pos) {\n                                applyValueRecord(tab.pos, glyphIndex);\n                                break;\n                            }\n                        } else if (lookup.ltype === 2) {\n                            let adj = null;\n                            let prevGlyphIndex = getPrevGlyphIndex();\n                            if (prevGlyphIndex !== -1) {\n                                const coverageIndex = Typr._lctf.coverageIndex(tab.coverage, glyphIds[prevGlyphIndex]);\n                                if (coverageIndex !== -1) {\n                                    if (tab.fmt === 1) {\n                                        const right = tab.pairsets[coverageIndex];\n                                        for(let k = 0; k < right.length; k++){\n                                            if (right[k].gid2 === glyphId) adj = right[k];\n                                        }\n                                    } else if (tab.fmt === 2) {\n                                        const c1 = Typr.U._getGlyphClass(glyphIds[prevGlyphIndex], tab.classDef1);\n                                        const c2 = Typr.U._getGlyphClass(glyphId, tab.classDef2);\n                                        adj = tab.matrix[c1][c2];\n                                    }\n                                    if (adj) {\n                                        if (adj.val1) applyValueRecord(adj.val1, prevGlyphIndex);\n                                        if (adj.val2) applyValueRecord(adj.val2, glyphIndex);\n                                        break;\n                                    }\n                                }\n                            }\n                        } else if (lookup.ltype === 4) {\n                            const markArrIndex = Typr._lctf.coverageIndex(tab.markCoverage, glyphId);\n                            if (markArrIndex !== -1) {\n                                const baseGlyphIndex = getPrevGlyphIndex(isBaseGlyph);\n                                const baseArrIndex = baseGlyphIndex === -1 ? -1 : Typr._lctf.coverageIndex(tab.baseCoverage, glyphIds[baseGlyphIndex]);\n                                if (baseArrIndex !== -1) {\n                                    const markRecord = tab.markArray[markArrIndex];\n                                    const baseAnchor = tab.baseArray[baseArrIndex][markRecord.markClass];\n                                    positions[glyphIndex * 3] = baseAnchor.x - markRecord.x + positions[baseGlyphIndex * 3] - positions[baseGlyphIndex * 3 + 2];\n                                    positions[glyphIndex * 3 + 1] = baseAnchor.y - markRecord.y + positions[baseGlyphIndex * 3 + 1];\n                                    break;\n                                }\n                            }\n                        } else if (lookup.ltype === 6) {\n                            const mark1ArrIndex = Typr._lctf.coverageIndex(tab.mark1Coverage, glyphId);\n                            if (mark1ArrIndex !== -1) {\n                                const prevGlyphIndex = getPrevGlyphIndex();\n                                if (prevGlyphIndex !== -1) {\n                                    const prevGlyphId = glyphIds[prevGlyphIndex];\n                                    if (getGlyphClass(font, prevGlyphId) === 3) {\n                                        const mark2ArrIndex = Typr._lctf.coverageIndex(tab.mark2Coverage, prevGlyphId);\n                                        if (mark2ArrIndex !== -1) {\n                                            const mark1Record = tab.mark1Array[mark1ArrIndex];\n                                            const mark2Anchor = tab.mark2Array[mark2ArrIndex][mark1Record.markClass];\n                                            positions[glyphIndex * 3] = mark2Anchor.x - mark1Record.x + positions[prevGlyphIndex * 3] - positions[prevGlyphIndex * 3 + 2];\n                                            positions[glyphIndex * 3 + 1] = mark2Anchor.y - mark1Record.y + positions[prevGlyphIndex * 3 + 1];\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } else if (font.kern && !font.cff) {\n                const prevGlyphIndex = getPrevGlyphIndex();\n                if (prevGlyphIndex !== -1) {\n                    const ind1 = font.kern.glyph1.indexOf(glyphIds[prevGlyphIndex]);\n                    if (ind1 !== -1) {\n                        const ind2 = font.kern.rval[ind1].glyph2.indexOf(glyphId);\n                        if (ind2 !== -1) {\n                            positions[prevGlyphIndex * 3 + 2] += font.kern.rval[ind1].vals[ind2];\n                        }\n                    }\n                }\n            }\n        }\n        return positions;\n        function getPrevGlyphIndex(filter) {\n            for(let i = glyphIndex - 1; i >= 0; i--){\n                if (glyphIds[i] !== -1 && (!filter || filter(glyphIds[i]))) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        function isBaseGlyph(glyphId) {\n            return getGlyphClass(font, glyphId) === 1;\n        }\n        function applyValueRecord(source, gi) {\n            for(let i = 0; i < 3; i++){\n                positions[gi * 3 + i] += source[i] || 0;\n            }\n        }\n    }\n    function getGlyphClass(font, glyphId) {\n        const classDef = font.GDEF && font.GDEF.glyphClassDef;\n        return classDef ? Typr.U._getGlyphClass(glyphId, classDef) : 0;\n    }\n    function firstNum(...args) {\n        for(let i = 0; i < args.length; i++){\n            if (typeof args[i] === \"number\") {\n                return args[i];\n            }\n        }\n    }\n    /**\n   * @returns ParsedFont\n   */ function wrapFontObj(typrFont) {\n        const glyphMap = Object.create(null);\n        const os2 = typrFont[\"OS/2\"];\n        const hhea = typrFont.hhea;\n        const unitsPerEm = typrFont.head.unitsPerEm;\n        const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);\n        /** @type ParsedFont */ const fontObj = {\n            unitsPerEm,\n            ascender,\n            descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),\n            capHeight: firstNum(os2 && os2.sCapHeight, ascender),\n            xHeight: firstNum(os2 && os2.sxHeight, ascender),\n            lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),\n            supportsCodePoint (code) {\n                return Typr.U.codeToGlyph(typrFont, code) > 0;\n            },\n            forEachGlyph (text, fontSize, letterSpacing, callback) {\n                let penX = 0;\n                const fontScale = 1 / fontObj.unitsPerEm * fontSize;\n                const glyphIds = stringToGlyphs(typrFont, text);\n                let charIndex = 0;\n                const positions = calcGlyphPositions(typrFont, glyphIds);\n                glyphIds.forEach((glyphId, i)=>{\n                    // Typr returns a glyph index per string codepoint, with -1s in place of those that\n                    // were omitted due to ligature substitution. So we can track original index in the\n                    // string via simple increment, and skip everything else when seeing a -1.\n                    if (glyphId !== -1) {\n                        let glyphObj = glyphMap[glyphId];\n                        if (!glyphObj) {\n                            const { cmds, crds } = Typr.U.glyphToPath(typrFont, glyphId);\n                            // Build path string\n                            let path = \"\";\n                            let crdsIdx = 0;\n                            for(let i = 0, len = cmds.length; i < len; i++){\n                                const numArgs = cmdArgLengths[cmds[i]];\n                                path += cmds[i];\n                                for(let j = 1; j <= numArgs; j++){\n                                    path += (j > 1 ? \",\" : \"\") + crds[crdsIdx++];\n                                }\n                            }\n                            // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't\n                            // normalize the two, so it's simplest just to iterate ourselves.\n                            let xMin, yMin, xMax, yMax;\n                            if (crds.length) {\n                                xMin = yMin = Infinity;\n                                xMax = yMax = -Infinity;\n                                for(let i = 0, len = crds.length; i < len; i += 2){\n                                    let x = crds[i];\n                                    let y = crds[i + 1];\n                                    if (x < xMin) xMin = x;\n                                    if (y < yMin) yMin = y;\n                                    if (x > xMax) xMax = x;\n                                    if (y > yMax) yMax = y;\n                                }\n                            } else {\n                                xMin = xMax = yMin = yMax = 0;\n                            }\n                            glyphObj = glyphMap[glyphId] = {\n                                index: glyphId,\n                                advanceWidth: typrFont.hmtx.aWidth[glyphId],\n                                xMin,\n                                yMin,\n                                xMax,\n                                yMax,\n                                path\n                            };\n                        }\n                        callback.call(null, glyphObj, penX + positions[i * 3] * fontScale, positions[i * 3 + 1] * fontScale, charIndex);\n                        penX += positions[i * 3 + 2] * fontScale;\n                        if (letterSpacing) {\n                            penX += letterSpacing * fontSize;\n                        }\n                    }\n                    charIndex += text.codePointAt(charIndex) > 0xffff ? 2 : 1;\n                });\n                return penX;\n            }\n        };\n        return fontObj;\n    }\n    /**\n   * @type FontParser\n   */ return function parse(buffer) {\n        // Look to see if we have a WOFF file and convert it if so:\n        const peek = new Uint8Array(buffer, 0, 4);\n        const tag = Typr._bin.readASCII(peek, 0, 4);\n        if (tag === \"wOFF\") {\n            buffer = woff2otf(buffer);\n        } else if (tag === \"wOF2\") {\n            throw new Error(\"woff2 fonts not supported\");\n        }\n        return wrapFontObj(Typr.parse(buffer)[0]);\n    };\n}\nconst workerModule = /*#__PURE__*/ (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n    name: \"Typr Font Parser\",\n    dependencies: [\n        typrFactory,\n        woff2otfFactory,\n        parserFactory\n    ],\n    init (typrFactory, woff2otfFactory, parserFactory) {\n        const Typr = typrFactory();\n        const woff2otf = woff2otfFactory();\n        return parserFactory(Typr, woff2otf);\n    }\n});\n/*!\nCustom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)\nfor use in Troika text rendering. \nOriginal MIT license applies\n*/ function unicodeFontResolverClientFactory() {\n    return function(t) {\n        var n = function() {\n            this.buckets = new Map;\n        };\n        n.prototype.add = function(t) {\n            var n = t >> 5;\n            this.buckets.set(n, (this.buckets.get(n) || 0) | 1 << (31 & t));\n        }, n.prototype.has = function(t) {\n            var n = this.buckets.get(t >> 5);\n            return void 0 !== n && 0 != (n & 1 << (31 & t));\n        }, n.prototype.serialize = function() {\n            var t = [];\n            return this.buckets.forEach(function(n, r) {\n                t.push((+r).toString(36) + \":\" + n.toString(36));\n            }), t.join(\",\");\n        }, n.prototype.deserialize = function(t) {\n            var n = this;\n            this.buckets.clear(), t.split(\",\").forEach(function(t) {\n                var r = t.split(\":\");\n                n.buckets.set(parseInt(r[0], 36), parseInt(r[1], 36));\n            });\n        };\n        var r = Math.pow(2, 8), e = r - 1, o = ~e;\n        function a(t) {\n            var n = (function(t) {\n                return t & o;\n            })(t).toString(16), e = (function(t) {\n                return (t & o) + r - 1;\n            })(t).toString(16);\n            return \"codepoint-index/plane\" + (t >> 16) + \"/\" + n + \"-\" + e + \".json\";\n        }\n        function i(t, n) {\n            var r = t & e, o = n.codePointAt(r / 6 | 0);\n            return 0 != ((o = (o || 48) - 48) & 1 << r % 6);\n        }\n        function u(t, n) {\n            var r;\n            (r = t, r.replace(/U\\+/gi, \"\").replace(/^,+|,+$/g, \"\").split(/,+/).map(function(t) {\n                return t.split(\"-\").map(function(t) {\n                    return parseInt(t.trim(), 16);\n                });\n            })).forEach(function(t) {\n                var r = t[0], e = t[1];\n                void 0 === e && (e = r), n(r, e);\n            });\n        }\n        function c(t, n) {\n            u(t, function(t, r) {\n                for(var e = t; e <= r; e++)n(e);\n            });\n        }\n        var s = {}, f = {}, l = new WeakMap, v = \"https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data\";\n        function d(t) {\n            var r = l.get(t);\n            return r || (r = new n, c(t.ranges, function(t) {\n                return r.add(t);\n            }), l.set(t, r)), r;\n        }\n        var h, p = new Map;\n        function g(t, n, r) {\n            return t[n] ? n : t[r] ? r : function(t) {\n                for(var n in t)return n;\n            }(t);\n        }\n        function w(t, n) {\n            var r = n;\n            if (!t.includes(r)) {\n                r = 1 / 0;\n                for(var e = 0; e < t.length; e++)Math.abs(t[e] - n) < Math.abs(r - n) && (r = t[e]);\n            }\n            return r;\n        }\n        function k(t) {\n            return h || (h = new Set, c(\"9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000\", function(t) {\n                h.add(t);\n            })), h.has(t);\n        }\n        return t.CodePointSet = n, t.clearCache = function() {\n            s = {}, f = {};\n        }, t.getFontsForString = function(t, n) {\n            void 0 === n && (n = {});\n            var r, e = n.lang;\n            void 0 === e && (e = /\\p{Script=Hangul}/u.test(r = t) ? \"ko\" : /\\p{Script=Hiragana}|\\p{Script=Katakana}/u.test(r) ? \"ja\" : \"en\");\n            var o = n.category;\n            void 0 === o && (o = \"sans-serif\");\n            var u = n.style;\n            void 0 === u && (u = \"normal\");\n            var c = n.weight;\n            void 0 === c && (c = 400);\n            var l = (n.dataUrl || v).replace(/\\/$/g, \"\"), h = new Map, y = new Uint8Array(t.length), b = {}, m = {}, A = new Array(t.length), S = new Map, j = !1;\n            function M(t) {\n                var n = p.get(t);\n                return n || (n = fetch(l + \"/\" + t).then(function(t) {\n                    if (!t.ok) throw new Error(t.statusText);\n                    return t.json().then(function(t) {\n                        if (!Array.isArray(t) || 1 !== t[0]) throw new Error(\"Incorrect schema version; need 1, got \" + t[0]);\n                        return t[1];\n                    });\n                }).catch(function(n) {\n                    if (l !== v) return j || (console.error('unicode-font-resolver: Failed loading from dataUrl \"' + l + '\", trying default CDN. ' + n.message), j = !0), l = v, p.delete(t), M(t);\n                    throw n;\n                }), p.set(t, n)), n;\n            }\n            for(var P = function(n) {\n                var r = t.codePointAt(n), e = a(r);\n                A[n] = e, s[e] || S.has(e) || S.set(e, M(e).then(function(t) {\n                    s[e] = t;\n                })), r > 65535 && (n++, E = n);\n            }, E = 0; E < t.length; E++)P(E);\n            return Promise.all(S.values()).then(function() {\n                S.clear();\n                for(var n = function(n) {\n                    var o = t.codePointAt(n), a = null, u = s[A[n]], c = void 0;\n                    for(var l in u){\n                        var v = m[l];\n                        if (void 0 === v && (v = m[l] = new RegExp(l).test(e || \"en\")), v) {\n                            for(var d in c = l, u[l])if (i(o, u[l][d])) {\n                                a = d;\n                                break;\n                            }\n                            break;\n                        }\n                    }\n                    if (!a) {\n                        t: for(var h in u)if (h !== c) {\n                            for(var p in u[h])if (i(o, u[h][p])) {\n                                a = p;\n                                break t;\n                            }\n                        }\n                    }\n                    a || (console.debug(\"No font coverage for U+\" + o.toString(16)), a = \"latin\"), A[n] = a, f[a] || S.has(a) || S.set(a, M(\"font-meta/\" + a + \".json\").then(function(t) {\n                        f[a] = t;\n                    })), o > 65535 && (n++, r = n);\n                }, r = 0; r < t.length; r++)n(r);\n                return Promise.all(S.values());\n            }).then(function() {\n                for(var n, r = null, e = 0; e < t.length; e++){\n                    var a = t.codePointAt(e);\n                    if (r && (k(a) || d(r).has(a))) y[e] = y[e - 1];\n                    else {\n                        r = f[A[e]];\n                        var i = b[r.id];\n                        if (!i) {\n                            var s = r.typeforms, v = g(s, o, \"sans-serif\"), p = g(s[v], u, \"normal\"), m = w(null === (n = s[v]) || void 0 === n ? void 0 : n[p], c);\n                            i = b[r.id] = l + \"/font-files/\" + r.id + \"/\" + v + \".\" + p + \".\" + m + \".woff\";\n                        }\n                        var S = h.get(i);\n                        null == S && (S = h.size, h.set(i, S)), y[e] = S;\n                    }\n                    a > 65535 && (e++, y[e] = y[e - 1]);\n                }\n                return {\n                    fontUrls: Array.from(h.keys()),\n                    chars: y\n                };\n            });\n        }, Object.defineProperty(t, \"__esModule\", {\n            value: !0\n        }), t;\n    }({});\n}\n/**\n * @typedef {string | {src:string, label?:string, unicodeRange?:string, lang?:string}} UserFont\n */ /**\n * @typedef {ClientOptions} FontResolverOptions\n * @property {Array<UserFont>|UserFont} [fonts]\n * @property {'normal'|'italic'} [style]\n * @property {'normal'|'bold'|number} [style]\n * @property {string} [unicodeFontsURL]\n */ /**\n * @typedef {Object} FontResolverResult\n * @property {Uint8Array} chars\n * @property {Array<ParsedFont & {src:string}>} fonts\n */ /**\n * @typedef {function} FontResolver\n * @param {string} text\n * @param {(FontResolverResult) => void} callback\n * @param {FontResolverOptions} [options]\n */ /**\n * Factory for the FontResolver function.\n * @param {FontParser} fontParser\n * @param {{getFontsForString: function, CodePointSet: function}} unicodeFontResolverClient\n * @return {FontResolver}\n */ function createFontResolver(fontParser, unicodeFontResolverClient) {\n    /**\n   * @type {Record<string, ParsedFont>}\n   */ const parsedFonts = Object.create(null);\n    /**\n   * @type {Record<string, Array<(ParsedFont) => void>>}\n   */ const loadingFonts = Object.create(null);\n    /**\n   * Load a given font url\n   */ function doLoadFont(url, callback) {\n        const onError = (err)=>{\n            console.error(`Failure loading font ${url}`, err);\n        };\n        try {\n            const request = new XMLHttpRequest();\n            request.open(\"get\", url, true);\n            request.responseType = \"arraybuffer\";\n            request.onload = function() {\n                if (request.status >= 400) {\n                    onError(new Error(request.statusText));\n                } else if (request.status > 0) {\n                    try {\n                        const fontObj = fontParser(request.response);\n                        fontObj.src = url;\n                        callback(fontObj);\n                    } catch (e) {\n                        onError(e);\n                    }\n                }\n            };\n            request.onerror = onError;\n            request.send();\n        } catch (err) {\n            onError(err);\n        }\n    }\n    /**\n   * Load a given font url if needed, invoking a callback when it's loaded. If already\n   * loaded, the callback will be called synchronously.\n   * @param {string} fontUrl\n   * @param {(font: ParsedFont) => void} callback\n   */ function loadFont(fontUrl, callback) {\n        let font = parsedFonts[fontUrl];\n        if (font) {\n            callback(font);\n        } else if (loadingFonts[fontUrl]) {\n            loadingFonts[fontUrl].push(callback);\n        } else {\n            loadingFonts[fontUrl] = [\n                callback\n            ];\n            doLoadFont(fontUrl, (fontObj)=>{\n                fontObj.src = fontUrl;\n                parsedFonts[fontUrl] = fontObj;\n                loadingFonts[fontUrl].forEach((cb)=>cb(fontObj));\n                delete loadingFonts[fontUrl];\n            });\n        }\n    }\n    /**\n   * For a given string of text, determine which fonts are required to fully render it and\n   * ensure those fonts are loaded.\n   */ return function(text, callback, { lang, fonts: userFonts = [], style = \"normal\", weight = \"normal\", unicodeFontsURL } = {}) {\n        const charResolutions = new Uint8Array(text.length);\n        const fontResolutions = [];\n        if (!text.length) {\n            allDone();\n        }\n        const fontIndices = new Map();\n        const fallbackRanges = []; // [[start, end], ...]\n        if (style !== \"italic\") style = \"normal\";\n        if (typeof weight !== \"number\") {\n            weight = weight === \"bold\" ? 700 : 400;\n        }\n        if (userFonts && !Array.isArray(userFonts)) {\n            userFonts = [\n                userFonts\n            ];\n        }\n        userFonts = userFonts.slice()// filter by language\n        .filter((def)=>!def.lang || def.lang.test(lang))// switch order for easier iteration\n        .reverse();\n        if (userFonts.length) {\n            const UNKNOWN = 0;\n            const RESOLVED = 1;\n            const NEEDS_FALLBACK = 2;\n            let prevCharResult = UNKNOWN;\n            (function resolveUserFonts(startIndex = 0) {\n                for(let i = startIndex, iLen = text.length; i < iLen; i++){\n                    const codePoint = text.codePointAt(i);\n                    // Carry previous character's result forward if:\n                    // - it resolved to a font that also covers this character\n                    // - this character is whitespace\n                    if (prevCharResult === RESOLVED && fontResolutions[charResolutions[i - 1]].supportsCodePoint(codePoint) || i > 0 && /\\s/.test(text[i])) {\n                        charResolutions[i] = charResolutions[i - 1];\n                        if (prevCharResult === NEEDS_FALLBACK) {\n                            fallbackRanges[fallbackRanges.length - 1][1] = i;\n                        }\n                    } else {\n                        for(let j = charResolutions[i], jLen = userFonts.length; j <= jLen; j++){\n                            if (j === jLen) {\n                                // none of the user fonts matched; needs fallback\n                                const range = prevCharResult === NEEDS_FALLBACK ? fallbackRanges[fallbackRanges.length - 1] : fallbackRanges[fallbackRanges.length] = [\n                                    i,\n                                    i\n                                ];\n                                range[1] = i;\n                                prevCharResult = NEEDS_FALLBACK;\n                            } else {\n                                charResolutions[i] = j;\n                                const { src, unicodeRange } = userFonts[j];\n                                // filter by optional explicit unicode ranges\n                                if (!unicodeRange || isCodeInRanges(codePoint, unicodeRange)) {\n                                    const fontObj = parsedFonts[src];\n                                    // font not yet loaded, load it and resume\n                                    if (!fontObj) {\n                                        loadFont(src, ()=>{\n                                            resolveUserFonts(i);\n                                        });\n                                        return;\n                                    }\n                                    // if the font actually contains a glyph for this char, lock it in\n                                    if (fontObj.supportsCodePoint(codePoint)) {\n                                        let fontIndex = fontIndices.get(fontObj);\n                                        if (typeof fontIndex !== \"number\") {\n                                            fontIndex = fontResolutions.length;\n                                            fontResolutions.push(fontObj);\n                                            fontIndices.set(fontObj, fontIndex);\n                                        }\n                                        charResolutions[i] = fontIndex;\n                                        prevCharResult = RESOLVED;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (codePoint > 0xffff && i + 1 < iLen) {\n                        charResolutions[i + 1] = charResolutions[i];\n                        i++;\n                        if (prevCharResult === NEEDS_FALLBACK) {\n                            fallbackRanges[fallbackRanges.length - 1][1] = i;\n                        }\n                    }\n                }\n                resolveFallbacks();\n            })();\n        } else {\n            fallbackRanges.push([\n                0,\n                text.length - 1\n            ]);\n            resolveFallbacks();\n        }\n        function resolveFallbacks() {\n            if (fallbackRanges.length) {\n                // Combine all fallback substrings into a single string for querying\n                const fallbackString = fallbackRanges.map((range)=>text.substring(range[0], range[1] + 1)).join(\"\\n\");\n                unicodeFontResolverClient.getFontsForString(fallbackString, {\n                    lang: lang || undefined,\n                    style,\n                    weight,\n                    dataUrl: unicodeFontsURL\n                }).then(({ fontUrls, chars })=>{\n                    // Extract results and put them back in the main array\n                    const fontIndexOffset = fontResolutions.length;\n                    let charIdx = 0;\n                    fallbackRanges.forEach((range)=>{\n                        for(let i = 0, endIdx = range[1] - range[0]; i <= endIdx; i++){\n                            charResolutions[range[0] + i] = chars[charIdx++] + fontIndexOffset;\n                        }\n                        charIdx++; //skip segment separator\n                    });\n                    // Load and parse the fallback fonts - avoiding Promise here to prevent polyfills in the worker\n                    let loadedCount = 0;\n                    fontUrls.forEach((url, i)=>{\n                        loadFont(url, (fontObj)=>{\n                            fontResolutions[i + fontIndexOffset] = fontObj;\n                            if (++loadedCount === fontUrls.length) {\n                                allDone();\n                            }\n                        });\n                    });\n                });\n            } else {\n                allDone();\n            }\n        }\n        function allDone() {\n            callback({\n                chars: charResolutions,\n                fonts: fontResolutions\n            });\n        }\n        function isCodeInRanges(code, ranges) {\n            // todo optimize search - CodePointSet from unicode-font-resolver?\n            for(let k = 0; k < ranges.length; k++){\n                const [start, end = start] = ranges[k];\n                if (start <= code && code <= end) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n}\nconst fontResolverWorkerModule = /*#__PURE__*/ (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n    name: \"FontResolver\",\n    dependencies: [\n        createFontResolver,\n        workerModule,\n        unicodeFontResolverClientFactory\n    ],\n    init (createFontResolver, fontParser, unicodeFontResolverClientFactory) {\n        return createFontResolver(fontParser, unicodeFontResolverClientFactory());\n    }\n});\n/**\n * @typedef {number|'left'|'center'|'right'} AnchorXValue\n */ /**\n * @typedef {number|'top'|'top-baseline'|'top-cap'|'top-ex'|'middle'|'bottom-baseline'|'bottom'} AnchorYValue\n */ /**\n * @typedef {object} TypesetParams\n * @property {string} text\n * @property {UserFont|UserFont[]} [font]\n * @property {string} [lang]\n * @property {number} [sdfGlyphSize=64]\n * @property {number} [fontSize=1]\n * @property {number|'normal'|'bold'} [fontWeight='normal']\n * @property {'normal'|'italic'} [fontStyle='normal']\n * @property {number} [letterSpacing=0]\n * @property {'normal'|number} [lineHeight='normal']\n * @property {number} [maxWidth]\n * @property {'ltr'|'rtl'} [direction='ltr']\n * @property {string} [textAlign='left']\n * @property {number} [textIndent=0]\n * @property {'normal'|'nowrap'} [whiteSpace='normal']\n * @property {'normal'|'break-word'} [overflowWrap='normal']\n * @property {AnchorXValue} [anchorX=0]\n * @property {AnchorYValue} [anchorY=0]\n * @property {boolean} [metricsOnly=false]\n * @property {string} [unicodeFontsURL]\n * @property {FontResolverResult} [preResolvedFonts]\n * @property {boolean} [includeCaretPositions=false]\n * @property {number} [chunkedBoundsSize=8192]\n * @property {{[rangeStartIndex]: number}} [colorRanges]\n */ /**\n * @typedef {object} TypesetResult\n * @property {Uint16Array} glyphIds id for each glyph, specific to that glyph's font\n * @property {Uint8Array} glyphFontIndices index into fontData for each glyph\n * @property {Float32Array} glyphPositions x,y of each glyph's origin in layout\n * @property {{[font]: {[glyphId]: {path: string, pathBounds: number[]}}}} glyphData data about each glyph appearing in the text\n * @property {TypesetFontData[]} fontData data about each font used in the text\n * @property {Float32Array} [caretPositions] startX,endX,bottomY caret positions for each char\n * @property {Uint8Array} [glyphColors] color for each glyph, if color ranges supplied\n *         chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n *         fontSize, //calculated em height\n *         topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline\n *         blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n *           anchorXOffset,\n *           anchorYOffset - totalHeight,\n *           anchorXOffset + maxLineWidth,\n *           anchorYOffset\n *         ],\n *         visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n *         timings\n */ /**\n * @typedef {object} TypesetFontData\n * @property src\n * @property unitsPerEm\n * @property ascender\n * @property descender\n * @property lineHeight\n * @property capHeight\n * @property xHeight\n */ /**\n * @typedef {function} TypesetterTypesetFunction - compute fonts and layout for some text.\n * @param {TypesetParams} params\n * @param {(TypesetResult) => void} callback - function called when typesetting is complete.\n *    If the params included `preResolvedFonts`, this will be called synchronously.\n */ /**\n * @typedef {function} TypesetterMeasureFunction - compute width/height for some text.\n * @param {TypesetParams} params\n * @param {(width:number, height:number) => void} callback - function called when measurement is complete.\n *    If the params included `preResolvedFonts`, this will be called synchronously.\n */ /**\n * Factory function that creates a self-contained environment for processing text typesetting requests.\n *\n * It is important that this function has no closure dependencies, so that it can be easily injected\n * into the source for a Worker without requiring a build step or complex dependency loading. All its\n * dependencies must be passed in at initialization.\n *\n * @param {FontResolver} resolveFonts - function to resolve a string to parsed fonts\n * @param {object} bidi - the bidi.js implementation object\n * @return {{typeset: TypesetterTypesetFunction, measure: TypesetterMeasureFunction}}\n */ function createTypesetter(resolveFonts, bidi) {\n    const INF = Infinity;\n    // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs\n    // eslint-disable-next-line no-misleading-character-class\n    const DEFAULT_IGNORABLE_CHARS = /[\\u00AD\\u034F\\u061C\\u115F-\\u1160\\u17B4-\\u17B5\\u180B-\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u3164\\uFE00-\\uFE0F\\uFEFF\\uFFA0\\uFFF0-\\uFFF8]/;\n    // This regex (instead of /\\s/) allows us to select all whitespace EXCEPT for non-breaking white spaces\n    const lineBreakingWhiteSpace = `[^\\\\S\\\\u00A0]`;\n    // Incomplete set of characters that allow line breaking after them\n    // In the future we may consider a full Unicode line breaking algorithm impl: https://www.unicode.org/reports/tr14\n    const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\\\-\\\\u007C\\\\u00AD\\\\u2010\\\\u2012-\\\\u2014\\\\u2027\\\\u2056\\\\u2E17\\\\u2E40]`);\n    /**\n   * Load and parse all the necessary fonts to render a given string of text, then group\n   * them into consecutive runs of characters sharing a font.\n   */ function calculateFontRuns({ text, lang, fonts, style, weight, preResolvedFonts, unicodeFontsURL }, onDone) {\n        const onResolved = ({ chars, fonts: parsedFonts })=>{\n            let curRun, prevVal;\n            const runs = [];\n            for(let i = 0; i < chars.length; i++){\n                if (chars[i] !== prevVal) {\n                    prevVal = chars[i];\n                    runs.push(curRun = {\n                        start: i,\n                        end: i,\n                        fontObj: parsedFonts[chars[i]]\n                    });\n                } else {\n                    curRun.end = i;\n                }\n            }\n            onDone(runs);\n        };\n        if (preResolvedFonts) {\n            onResolved(preResolvedFonts);\n        } else {\n            resolveFonts(text, onResolved, {\n                lang,\n                fonts,\n                style,\n                weight,\n                unicodeFontsURL\n            });\n        }\n    }\n    /**\n   * Main entry point.\n   * Process a text string with given font and formatting parameters, and return all info\n   * necessary to render all its glyphs.\n   * @type TypesetterTypesetFunction\n   */ function typeset({ text = \"\", font, lang, sdfGlyphSize = 64, fontSize = 400, fontWeight = 1, fontStyle = \"normal\", letterSpacing = 0, lineHeight = \"normal\", maxWidth = INF, direction, textAlign = \"left\", textIndent = 0, whiteSpace = \"normal\", overflowWrap = \"normal\", anchorX = 0, anchorY = 0, metricsOnly = false, unicodeFontsURL, preResolvedFonts = null, includeCaretPositions = false, chunkedBoundsSize = 8192, colorRanges = null }, callback) {\n        const mainStart = now();\n        const timings = {\n            fontLoad: 0,\n            typesetting: 0\n        };\n        // Ensure newlines are normalized\n        if (text.indexOf(\"\\r\") > -1) {\n            console.info(\"Typesetter: got text with \\\\r chars; normalizing to \\\\n\");\n            text = text.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n        }\n        // Ensure we've got numbers not strings\n        fontSize = +fontSize;\n        letterSpacing = +letterSpacing;\n        maxWidth = +maxWidth;\n        lineHeight = lineHeight || \"normal\";\n        textIndent = +textIndent;\n        calculateFontRuns({\n            text,\n            lang,\n            style: fontStyle,\n            weight: fontWeight,\n            fonts: typeof font === \"string\" ? [\n                {\n                    src: font\n                }\n            ] : font,\n            unicodeFontsURL,\n            preResolvedFonts\n        }, (runs)=>{\n            timings.fontLoad = now() - mainStart;\n            const hasMaxWidth = isFinite(maxWidth);\n            let glyphIds = null;\n            let glyphFontIndices = null;\n            let glyphPositions = null;\n            let glyphData = null;\n            let glyphColors = null;\n            let caretPositions = null;\n            let visibleBounds = null;\n            let chunkedBounds = null;\n            let maxLineWidth = 0;\n            let renderableGlyphCount = 0;\n            let canWrap = whiteSpace !== \"nowrap\";\n            const metricsByFont = new Map(); // fontObj -> metrics\n            const typesetStart = now();\n            // Distribute glyphs into lines based on wrapping\n            let lineXOffset = textIndent;\n            let prevRunEndX = 0;\n            let currentLine = new TextLine();\n            const lines = [\n                currentLine\n            ];\n            runs.forEach((run)=>{\n                const { fontObj } = run;\n                const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;\n                // Calculate metrics for each font used\n                let fontData = metricsByFont.get(fontObj);\n                if (!fontData) {\n                    // Find conversion between native font units and fontSize units\n                    const fontSizeMult = fontSize / unitsPerEm;\n                    // Determine appropriate value for 'normal' line height based on the font's actual metrics\n                    // This does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?\n                    const calcLineHeight = lineHeight === \"normal\" ? (ascender - descender + lineGap) * fontSizeMult : lineHeight * fontSize;\n                    // Determine line height and leading adjustments\n                    const halfLeading = (calcLineHeight - (ascender - descender) * fontSizeMult) / 2;\n                    const caretHeight = Math.min(calcLineHeight, (ascender - descender) * fontSizeMult);\n                    const caretTop = (ascender + descender) / 2 * fontSizeMult + caretHeight / 2;\n                    fontData = {\n                        index: metricsByFont.size,\n                        src: fontObj.src,\n                        fontObj,\n                        fontSizeMult,\n                        unitsPerEm,\n                        ascender: ascender * fontSizeMult,\n                        descender: descender * fontSizeMult,\n                        capHeight: capHeight * fontSizeMult,\n                        xHeight: xHeight * fontSizeMult,\n                        lineHeight: calcLineHeight,\n                        baseline: -halfLeading - ascender * fontSizeMult,\n                        // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height\n                        // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height\n                        caretTop,\n                        caretBottom: caretTop - caretHeight\n                    };\n                    metricsByFont.set(fontObj, fontData);\n                }\n                const { fontSizeMult } = fontData;\n                const runText = text.slice(run.start, run.end + 1);\n                let prevGlyphX, prevGlyphObj;\n                fontObj.forEachGlyph(runText, fontSize, letterSpacing, (glyphObj, glyphX, glyphY, charIndex)=>{\n                    glyphX += prevRunEndX;\n                    charIndex += run.start;\n                    prevGlyphX = glyphX;\n                    prevGlyphObj = glyphObj;\n                    const char = text.charAt(charIndex);\n                    const glyphWidth = glyphObj.advanceWidth * fontSizeMult;\n                    const curLineCount = currentLine.count;\n                    let nextLine;\n                    // Calc isWhitespace and isEmpty once per glyphObj\n                    if (!(\"isEmpty\" in glyphObj)) {\n                        glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);\n                        glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);\n                        glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);\n                    }\n                    if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n                        renderableGlyphCount++;\n                    }\n                    // If a non-whitespace character overflows the max width, we need to soft-wrap\n                    if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {\n                        // If it's the first char after a whitespace, start a new line\n                        if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {\n                            nextLine = new TextLine();\n                            lineXOffset = -glyphX;\n                        } else {\n                            // Back up looking for a whitespace character to wrap at\n                            for(let i = curLineCount; i--;){\n                                // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'\n                                if (i === 0 && overflowWrap === \"break-word\") {\n                                    nextLine = new TextLine();\n                                    lineXOffset = -glyphX;\n                                    break;\n                                } else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {\n                                    nextLine = currentLine.splitAt(i + 1);\n                                    const adjustX = nextLine.glyphAt(0).x;\n                                    lineXOffset -= adjustX;\n                                    for(let j = nextLine.count; j--;){\n                                        nextLine.glyphAt(j).x -= adjustX;\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                        if (nextLine) {\n                            currentLine.isSoftWrapped = true;\n                            currentLine = nextLine;\n                            lines.push(currentLine);\n                            maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width\n                        }\n                    }\n                    let fly = currentLine.glyphAt(currentLine.count);\n                    fly.glyphObj = glyphObj;\n                    fly.x = glyphX + lineXOffset;\n                    fly.y = glyphY;\n                    fly.width = glyphWidth;\n                    fly.charIndex = charIndex;\n                    fly.fontData = fontData;\n                    // Handle hard line breaks\n                    if (char === \"\\n\") {\n                        currentLine = new TextLine();\n                        lines.push(currentLine);\n                        lineXOffset = -(glyphX + glyphWidth + letterSpacing * fontSize) + textIndent;\n                    }\n                });\n                // At the end of a run we must capture the x position as the starting point for the next run\n                prevRunEndX = prevGlyphX + prevGlyphObj.advanceWidth * fontSizeMult + letterSpacing * fontSize;\n            });\n            // Calculate width/height/baseline of each line (excluding trailing whitespace) and maximum block width\n            let totalHeight = 0;\n            lines.forEach((line)=>{\n                let isTrailingWhitespace = true;\n                for(let i = line.count; i--;){\n                    const glyphInfo = line.glyphAt(i);\n                    // omit trailing whitespace from width calculation\n                    if (isTrailingWhitespace && !glyphInfo.glyphObj.isWhitespace) {\n                        line.width = glyphInfo.x + glyphInfo.width;\n                        if (line.width > maxLineWidth) {\n                            maxLineWidth = line.width;\n                        }\n                        isTrailingWhitespace = false;\n                    }\n                    // use the tallest line height, lowest baseline, and highest cap/ex\n                    let { lineHeight, capHeight, xHeight, baseline } = glyphInfo.fontData;\n                    if (lineHeight > line.lineHeight) line.lineHeight = lineHeight;\n                    const baselineDiff = baseline - line.baseline;\n                    if (baselineDiff < 0) {\n                        line.baseline += baselineDiff;\n                        line.cap += baselineDiff;\n                        line.ex += baselineDiff;\n                    }\n                    // compare cap/ex based on new lowest baseline\n                    line.cap = Math.max(line.cap, line.baseline + capHeight);\n                    line.ex = Math.max(line.ex, line.baseline + xHeight);\n                }\n                line.baseline -= totalHeight;\n                line.cap -= totalHeight;\n                line.ex -= totalHeight;\n                totalHeight += line.lineHeight;\n            });\n            // Find overall position adjustments for anchoring\n            let anchorXOffset = 0;\n            let anchorYOffset = 0;\n            if (anchorX) {\n                if (typeof anchorX === \"number\") {\n                    anchorXOffset = -anchorX;\n                } else if (typeof anchorX === \"string\") {\n                    anchorXOffset = -maxLineWidth * (anchorX === \"left\" ? 0 : anchorX === \"center\" ? 0.5 : anchorX === \"right\" ? 1 : parsePercent(anchorX));\n                }\n            }\n            if (anchorY) {\n                if (typeof anchorY === \"number\") {\n                    anchorYOffset = -anchorY;\n                } else if (typeof anchorY === \"string\") {\n                    anchorYOffset = anchorY === \"top\" ? 0 : anchorY === \"top-baseline\" ? -lines[0].baseline : anchorY === \"top-cap\" ? -lines[0].cap : anchorY === \"top-ex\" ? -lines[0].ex : anchorY === \"middle\" ? totalHeight / 2 : anchorY === \"bottom\" ? totalHeight : anchorY === \"bottom-baseline\" ? -lines[lines.length - 1].baseline : parsePercent(anchorY) * totalHeight;\n                }\n            }\n            if (!metricsOnly) {\n                // Resolve bidi levels\n                const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);\n                // Process each line, applying alignment offsets, adding each glyph to the atlas, and\n                // collecting all renderable glyphs into a single collection.\n                glyphIds = new Uint16Array(renderableGlyphCount);\n                glyphFontIndices = new Uint8Array(renderableGlyphCount);\n                glyphPositions = new Float32Array(renderableGlyphCount * 2);\n                glyphData = {};\n                visibleBounds = [\n                    INF,\n                    INF,\n                    -INF,\n                    -INF\n                ];\n                chunkedBounds = [];\n                if (includeCaretPositions) {\n                    caretPositions = new Float32Array(text.length * 4);\n                }\n                if (colorRanges) {\n                    glyphColors = new Uint8Array(renderableGlyphCount * 3);\n                }\n                let renderableGlyphIndex = 0;\n                let prevCharIndex = -1;\n                let colorCharIndex = -1;\n                let chunk;\n                let currentColor;\n                lines.forEach((line, lineIndex)=>{\n                    let { count: lineGlyphCount, width: lineWidth } = line;\n                    // Ignore empty lines\n                    if (lineGlyphCount > 0) {\n                        // Count trailing whitespaces, we want to ignore these for certain things\n                        let trailingWhitespaceCount = 0;\n                        for(let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;){\n                            trailingWhitespaceCount++;\n                        }\n                        // Apply horizontal alignment adjustments\n                        let lineXOffset = 0;\n                        let justifyAdjust = 0;\n                        if (textAlign === \"center\") {\n                            lineXOffset = (maxLineWidth - lineWidth) / 2;\n                        } else if (textAlign === \"right\") {\n                            lineXOffset = maxLineWidth - lineWidth;\n                        } else if (textAlign === \"justify\" && line.isSoftWrapped) {\n                            // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop\n                            let whitespaceCount = 0;\n                            for(let i = lineGlyphCount - trailingWhitespaceCount; i--;){\n                                if (line.glyphAt(i).glyphObj.isWhitespace) {\n                                    whitespaceCount++;\n                                }\n                            }\n                            justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;\n                        }\n                        if (justifyAdjust || lineXOffset) {\n                            let justifyOffset = 0;\n                            for(let i = 0; i < lineGlyphCount; i++){\n                                let glyphInfo = line.glyphAt(i);\n                                const glyphObj = glyphInfo.glyphObj;\n                                glyphInfo.x += lineXOffset + justifyOffset;\n                                // Expand non-trailing whitespaces for justify alignment\n                                if (justifyAdjust !== 0 && glyphObj.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {\n                                    justifyOffset += justifyAdjust;\n                                    glyphInfo.width += justifyAdjust;\n                                }\n                            }\n                        }\n                        // Perform bidi range flipping\n                        const flips = bidi.getReorderSegments(text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex);\n                        for(let fi = 0; fi < flips.length; fi++){\n                            const [start, end] = flips[fi];\n                            // Map start/end string indices to indices in the line\n                            let left = Infinity, right = -Infinity;\n                            for(let i = 0; i < lineGlyphCount; i++){\n                                if (line.glyphAt(i).charIndex >= start) {\n                                    let startInLine = i, endInLine = i;\n                                    for(; endInLine < lineGlyphCount; endInLine++){\n                                        let info = line.glyphAt(endInLine);\n                                        if (info.charIndex > end) {\n                                            break;\n                                        }\n                                        if (endInLine < lineGlyphCount - trailingWhitespaceCount) {\n                                            left = Math.min(left, info.x);\n                                            right = Math.max(right, info.x + info.width);\n                                        }\n                                    }\n                                    for(let j = startInLine; j < endInLine; j++){\n                                        const glyphInfo = line.glyphAt(j);\n                                        glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                        // Assemble final data arrays\n                        let glyphObj;\n                        const setGlyphObj = (g)=>glyphObj = g;\n                        for(let i = 0; i < lineGlyphCount; i++){\n                            const glyphInfo = line.glyphAt(i);\n                            glyphObj = glyphInfo.glyphObj;\n                            const glyphId = glyphObj.index;\n                            // Replace mirrored characters in rtl\n                            const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1; //odd level means rtl\n                            if (rtl) {\n                                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);\n                                if (mirrored) {\n                                    glyphInfo.fontData.fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);\n                                }\n                            }\n                            // Add caret positions\n                            if (includeCaretPositions) {\n                                const { charIndex, fontData } = glyphInfo;\n                                const caretLeft = glyphInfo.x + anchorXOffset;\n                                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;\n                                caretPositions[charIndex * 4] = rtl ? caretRight : caretLeft; //start edge x\n                                caretPositions[charIndex * 4 + 1] = rtl ? caretLeft : caretRight; //end edge x\n                                caretPositions[charIndex * 4 + 2] = line.baseline + fontData.caretBottom + anchorYOffset; //common bottom y\n                                caretPositions[charIndex * 4 + 3] = line.baseline + fontData.caretTop + anchorYOffset; //common top y\n                                // If we skipped any chars from the previous glyph (due to ligature subs), fill in caret\n                                // positions for those missing char indices; currently this uses a best-guess by dividing\n                                // the ligature's width evenly. In the future we may try to use the font's LigatureCaretList\n                                // table to get better interior caret positions.\n                                const ligCount = charIndex - prevCharIndex;\n                                if (ligCount > 1) {\n                                    fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n                                }\n                                prevCharIndex = charIndex;\n                            }\n                            // Track current color range\n                            if (colorRanges) {\n                                const { charIndex } = glyphInfo;\n                                while(charIndex > colorCharIndex){\n                                    colorCharIndex++;\n                                    if (colorRanges.hasOwnProperty(colorCharIndex)) {\n                                        currentColor = colorRanges[colorCharIndex];\n                                    }\n                                }\n                            }\n                            // Get atlas data for renderable glyphs\n                            if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n                                const idx = renderableGlyphIndex++;\n                                const { fontSizeMult, src: fontSrc, index: fontIndex } = glyphInfo.fontData;\n                                // Add this glyph's path data\n                                const fontGlyphData = glyphData[fontSrc] || (glyphData[fontSrc] = {});\n                                if (!fontGlyphData[glyphId]) {\n                                    fontGlyphData[glyphId] = {\n                                        path: glyphObj.path,\n                                        pathBounds: [\n                                            glyphObj.xMin,\n                                            glyphObj.yMin,\n                                            glyphObj.xMax,\n                                            glyphObj.yMax\n                                        ]\n                                    };\n                                }\n                                // Determine final glyph position and add to glyphPositions array\n                                const glyphX = glyphInfo.x + anchorXOffset;\n                                const glyphY = glyphInfo.y + line.baseline + anchorYOffset;\n                                glyphPositions[idx * 2] = glyphX;\n                                glyphPositions[idx * 2 + 1] = glyphY;\n                                // Track total visible bounds\n                                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;\n                                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;\n                                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;\n                                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;\n                                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;\n                                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;\n                                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;\n                                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;\n                                // Track bounding rects for each chunk of N glyphs\n                                if (idx % chunkedBoundsSize === 0) {\n                                    chunk = {\n                                        start: idx,\n                                        end: idx,\n                                        rect: [\n                                            INF,\n                                            INF,\n                                            -INF,\n                                            -INF\n                                        ]\n                                    };\n                                    chunkedBounds.push(chunk);\n                                }\n                                chunk.end++;\n                                const chunkRect = chunk.rect;\n                                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;\n                                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;\n                                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;\n                                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;\n                                // Add to glyph ids and font indices arrays\n                                glyphIds[idx] = glyphId;\n                                glyphFontIndices[idx] = fontIndex;\n                                // Add colors\n                                if (colorRanges) {\n                                    const start = idx * 3;\n                                    glyphColors[start] = currentColor >> 16 & 255;\n                                    glyphColors[start + 1] = currentColor >> 8 & 255;\n                                    glyphColors[start + 2] = currentColor & 255;\n                                }\n                            }\n                        }\n                    }\n                });\n                // Fill in remaining caret positions in case the final character was a ligature\n                if (caretPositions) {\n                    const ligCount = text.length - prevCharIndex;\n                    if (ligCount > 1) {\n                        fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n                    }\n                }\n            }\n            // Assemble final data about each font used\n            const fontData = [];\n            metricsByFont.forEach(({ index, src, unitsPerEm, ascender, descender, lineHeight, capHeight, xHeight })=>{\n                fontData[index] = {\n                    src,\n                    unitsPerEm,\n                    ascender,\n                    descender,\n                    lineHeight,\n                    capHeight,\n                    xHeight\n                };\n            });\n            // Timing stats\n            timings.typesetting = now() - typesetStart;\n            callback({\n                glyphIds,\n                glyphFontIndices,\n                glyphPositions,\n                glyphData,\n                fontData,\n                caretPositions,\n                // caretHeight, //height of cursor from bottom to top - todo per glyph?\n                glyphColors,\n                chunkedBounds,\n                fontSize,\n                topBaseline: anchorYOffset + lines[0].baseline,\n                blockBounds: [\n                    anchorXOffset,\n                    anchorYOffset - totalHeight,\n                    anchorXOffset + maxLineWidth,\n                    anchorYOffset\n                ],\n                visibleBounds,\n                timings\n            });\n        });\n    }\n    /**\n   * For a given text string and font parameters, determine the resulting block dimensions\n   * after wrapping for the given maxWidth.\n   * @param args\n   * @param callback\n   */ function measure(args, callback) {\n        typeset({\n            ...args,\n            metricsOnly: true\n        }, (result)=>{\n            const [x0, y0, x1, y1] = result.blockBounds;\n            callback({\n                width: x1 - x0,\n                height: y1 - y0\n            });\n        });\n    }\n    function parsePercent(str) {\n        let match = str.match(/^([\\d.]+)%$/);\n        let pct = match ? parseFloat(match[1]) : NaN;\n        return isNaN(pct) ? 0 : pct / 100;\n    }\n    function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {\n        const ligStartX = caretPositions[ligStartIndex * 4];\n        const ligEndX = caretPositions[ligStartIndex * 4 + 1];\n        const ligBottom = caretPositions[ligStartIndex * 4 + 2];\n        const ligTop = caretPositions[ligStartIndex * 4 + 3];\n        const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;\n        for(let i = 0; i < ligCount; i++){\n            const startIndex = (ligStartIndex + i) * 4;\n            caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;\n            caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);\n            caretPositions[startIndex + 2] = ligBottom;\n            caretPositions[startIndex + 3] = ligTop;\n        }\n    }\n    function now() {\n        return (self.performance || Date).now();\n    }\n    // Array-backed structure for a single line's glyphs data\n    function TextLine() {\n        this.data = [];\n    }\n    const textLineProps = [\n        \"glyphObj\",\n        \"x\",\n        \"y\",\n        \"width\",\n        \"charIndex\",\n        \"fontData\"\n    ];\n    TextLine.prototype = {\n        width: 0,\n        lineHeight: 0,\n        baseline: 0,\n        cap: 0,\n        ex: 0,\n        isSoftWrapped: false,\n        get count () {\n            return Math.ceil(this.data.length / textLineProps.length);\n        },\n        glyphAt (i) {\n            let fly = TextLine.flyweight;\n            fly.data = this.data;\n            fly.index = i;\n            return fly;\n        },\n        splitAt (i) {\n            let newLine = new TextLine();\n            newLine.data = this.data.splice(i * textLineProps.length);\n            return newLine;\n        }\n    };\n    TextLine.flyweight = textLineProps.reduce((obj, prop, i, all)=>{\n        Object.defineProperty(obj, prop, {\n            get () {\n                return this.data[this.index * textLineProps.length + i];\n            },\n            set (val) {\n                this.data[this.index * textLineProps.length + i] = val;\n            }\n        });\n        return obj;\n    }, {\n        data: null,\n        index: 0\n    });\n    return {\n        typeset,\n        measure\n    };\n}\nconst now = ()=>(self.performance || Date).now();\nconst mainThreadGenerator = /*#__PURE__*/ (0,webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\nlet warned;\n/**\n * Generate an SDF texture image for a single glyph path, placing the result into a webgl canvas at a\n * given location and channel. Utilizes the webgl-sdf-generator external package for GPU-accelerated SDF\n * generation when supported.\n */ function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {\n    // Allow opt-out\n    if (!useWebGL) {\n        return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel);\n    }\n    // Attempt GPU-accelerated generation first\n    return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(null, (err)=>{\n        // WebGL failed either due to a hard error or unexpected results; fall back to JS in workers\n        if (!warned) {\n            console.warn(`WebGL SDF generation failed, falling back to JS`, err);\n            warned = true;\n        }\n        return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel);\n    });\n}\nconst queue = [];\nconst chunkTimeBudget = 5; // ms\nlet timer = 0;\nfunction nextChunk() {\n    const start = now();\n    while(queue.length && now() - start < chunkTimeBudget){\n        queue.shift()();\n    }\n    timer = queue.length ? setTimeout(nextChunk, 0) : 0;\n}\n/**\n * WebGL-based implementation executed on the main thread. Requests are executed in time-bounded\n * macrotask chunks to allow render frames to execute in between.\n */ const generateSDF_GL = (...args)=>{\n    return new Promise((resolve, reject)=>{\n        queue.push(()=>{\n            const start = now();\n            try {\n                mainThreadGenerator.webgl.generateIntoCanvas(...args);\n                resolve({\n                    timing: now() - start\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n        if (!timer) {\n            timer = setTimeout(nextChunk, 0);\n        }\n    });\n};\nconst threadCount = 4; // how many workers to spawn\nconst idleTimeout = 2000; // workers will be terminated after being idle this many milliseconds\nconst threads = {};\nlet callNum = 0;\n/**\n * Fallback JS-based implementation, fanned out to a number of worker threads for parallelism\n */ function generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {\n    const workerId = \"TroikaTextSDFGenerator_JS_\" + callNum++ % threadCount;\n    let thread = threads[workerId];\n    if (!thread) {\n        thread = threads[workerId] = {\n            workerModule: (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n                name: workerId,\n                workerId,\n                dependencies: [\n                    webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n                    now\n                ],\n                init (_createSDFGenerator, now) {\n                    const generate = _createSDFGenerator().javascript.generate;\n                    return function(...args) {\n                        const start = now();\n                        const textureData = generate(...args);\n                        return {\n                            textureData,\n                            timing: now() - start\n                        };\n                    };\n                },\n                getTransferables (result) {\n                    return [\n                        result.textureData.buffer\n                    ];\n                }\n            }),\n            requests: 0,\n            idleTimer: null\n        };\n    }\n    thread.requests++;\n    clearTimeout(thread.idleTimer);\n    return thread.workerModule(width, height, path, viewBox, distance, exponent).then(({ textureData, timing })=>{\n        // copy result data into the canvas\n        const start = now();\n        // expand single-channel data into rgba\n        const imageData = new Uint8Array(textureData.length * 4);\n        for(let i = 0; i < textureData.length; i++){\n            imageData[i * 4 + channel] = textureData[i];\n        }\n        mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << 3 - channel);\n        timing += now() - start;\n        // clean up workers after a while\n        if (--thread.requests === 0) {\n            thread.idleTimer = setTimeout(()=>{\n                (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.terminateWorker)(workerId);\n            }, idleTimeout);\n        }\n        return {\n            timing\n        };\n    });\n}\nfunction warmUpSDFCanvas(canvas) {\n    if (!canvas._warm) {\n        mainThreadGenerator.webgl.isSupported(canvas);\n        canvas._warm = true;\n    }\n}\nconst resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;\nconst CONFIG = {\n    defaultFontURL: null,\n    unicodeFontsURL: null,\n    sdfGlyphSize: 64,\n    sdfMargin: 1 / 16,\n    sdfExponent: 9,\n    textureWidth: 2048,\n    useWorker: true\n};\nconst tempColor = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Color();\nlet hasRequested = false;\nfunction now$1() {\n    return (self.performance || Date).now();\n}\n/**\n * Customizes the text builder configuration. This must be called prior to the first font processing\n * request, and applies to all fonts.\n *\n * @param {String} config.defaultFontURL - The URL of the default font to use for text processing\n *                 requests, in case none is specified or the specifiede font fails to load or parse.\n *                 Defaults to \"Roboto Regular\" from Google Fonts.\n * @param {String} config.unicodeFontsURL - A custom location for the fallback unicode-font-resolver\n *                 data and font files, if you don't want to use the default CDN. See\n *                 https://github.com/lojjic/unicode-font-resolver for details. It can also be\n *                 configured per text instance, but this lets you do it once globally.\n * @param {Number} config.sdfGlyphSize - The default size of each glyph's SDF (signed distance field)\n *                 texture used for rendering. Must be a power-of-two number, and applies to all fonts,\n *                 but note that this can also be overridden per call to `getTextRenderInfo()`.\n *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness\n *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults\n *                 to 64 which is generally a good balance of size and quality.\n * @param {Number} config.sdfExponent - The exponent used when encoding the SDF values. A higher exponent\n *                 shifts the encoded 8-bit values to achieve higher precision/accuracy at texels nearer\n *                 the glyph's path, with lower precision further away. Defaults to 9.\n * @param {Number} config.sdfMargin - How much space to reserve in the SDF as margin outside the glyph's\n *                 path, as a percentage of the SDF width. A larger margin increases the quality of\n *                 extruded glyph outlines, but decreases the precision available for the glyph itself.\n *                 Defaults to 1/16th of the glyph size.\n * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to\n *                 2048 which is a safe maximum texture dimension according to the stats at\n *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a\n *                 reasonably large number of glyphs (default glyph size of 64^2 and safe texture size of\n *                 2048^2, times 4 channels, allows for 4096 glyphs.) This can be increased if you need to\n *                 increase the glyph size and/or have an extraordinary number of glyphs.\n * @param {Boolean} config.useWorker - Whether to run typesetting in a web worker. Defaults to true.\n */ function configureTextBuilder(config) {\n    if (hasRequested) {\n        console.warn(\"configureTextBuilder called after first font request; will be ignored.\");\n    } else {\n        assign(CONFIG, config);\n    }\n}\n/**\n * Repository for all font SDF atlas textures and their glyph mappings. There is a separate atlas for\n * each sdfGlyphSize. Each atlas has a single Texture that holds all glyphs for all fonts.\n *\n *   {\n *     [sdfGlyphSize]: {\n *       glyphCount: number,\n *       sdfGlyphSize: number,\n *       sdfTexture: Texture,\n *       sdfCanvas: HTMLCanvasElement,\n *       contextLost: boolean,\n *       glyphsByFont: Map<fontURL, Map<glyphID, {path, atlasIndex, sdfViewBox}>>\n *     }\n *   }\n */ const atlases = Object.create(null);\n/**\n * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.\n * @property {TypesetParams} parameters - The normalized input arguments to the render call.\n * @property {Texture} sdfTexture - The SDF atlas texture.\n * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.\n * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.\n * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.\n * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.\n * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.\n * @property {Float32Array} [caretPositions] - A list of caret positions for all characters in the string; each is\n *           four elements: the starting X, the ending X, the bottom Y, and the top Y for the caret.\n * @property {number} [caretHeight] - An appropriate height for all selection carets.\n * @property {number} ascender - The font's ascender metric.\n * @property {number} descender - The font's descender metric.\n * @property {number} capHeight - The font's cap height metric, based on the height of Latin capital letters.\n * @property {number} xHeight - The font's x height metric, based on the height of Latin lowercase letters.\n * @property {number} lineHeight - The final computed lineHeight measurement.\n * @property {number} topBaseline - The y position of the top line's baseline.\n * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is\n *           equivalent to the dimensions of a block-level text element in CSS.\n * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.\n * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,\n *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.\n * @property {object} timings - Timing info for various parts of the rendering logic including SDF\n *           generation, typesetting, etc.\n * @frozen\n */ /**\n * @callback getTextRenderInfo~callback\n * @param {TroikaTextRenderInfo} textRenderInfo\n */ /**\n * Main entry point for requesting the data needed to render a text string with given font parameters.\n * This is an asynchronous call, performing most of the logic in a web worker thread.\n * @param {TypesetParams} args\n * @param {getTextRenderInfo~callback} callback\n */ function getTextRenderInfo(args, callback) {\n    hasRequested = true;\n    args = assign({}, args);\n    const totalStart = now$1();\n    // Convert relative URL to absolute so it can be resolved in the worker, and add fallbacks.\n    // In the future we'll allow args.font to be a list with unicode ranges too.\n    const { defaultFontURL } = CONFIG;\n    const fonts = [];\n    if (defaultFontURL) {\n        fonts.push({\n            label: \"default\",\n            src: toAbsoluteURL(defaultFontURL)\n        });\n    }\n    if (args.font) {\n        fonts.push({\n            label: \"user\",\n            src: toAbsoluteURL(args.font)\n        });\n    }\n    args.font = fonts;\n    // Normalize text to a string\n    args.text = \"\" + args.text;\n    args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;\n    args.unicodeFontsURL = args.unicodeFontsURL || CONFIG.unicodeFontsURL;\n    // Normalize colors\n    if (args.colorRanges != null) {\n        let colors = {};\n        for(let key in args.colorRanges){\n            if (args.colorRanges.hasOwnProperty(key)) {\n                let val = args.colorRanges[key];\n                if (typeof val !== \"number\") {\n                    val = tempColor.set(val).getHex();\n                }\n                colors[key] = val;\n            }\n        }\n        args.colorRanges = colors;\n    }\n    Object.freeze(args);\n    // Init the atlas if needed\n    const { textureWidth, sdfExponent } = CONFIG;\n    const { sdfGlyphSize } = args;\n    const glyphsPerRow = textureWidth / sdfGlyphSize * 4;\n    let atlas = atlases[sdfGlyphSize];\n    if (!atlas) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = textureWidth;\n        canvas.height = sdfGlyphSize * 256 / glyphsPerRow; // start tall enough to fit 256 glyphs\n        atlas = atlases[sdfGlyphSize] = {\n            glyphCount: 0,\n            sdfGlyphSize,\n            sdfCanvas: canvas,\n            sdfTexture: new three__WEBPACK_IMPORTED_MODULE_3__.Texture(canvas, undefined, undefined, undefined, three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter),\n            contextLost: false,\n            glyphsByFont: new Map()\n        };\n        atlas.sdfTexture.generateMipmaps = false;\n        initContextLossHandling(atlas);\n    }\n    const { sdfTexture, sdfCanvas } = atlas;\n    // Issue request to the typesetting engine in the worker\n    const typeset = CONFIG.useWorker ? typesetInWorker : typesetOnMainThread;\n    typeset(args).then((result)=>{\n        const { glyphIds, glyphFontIndices, fontData, glyphPositions, fontSize, timings } = result;\n        const neededSDFs = [];\n        const glyphBounds = new Float32Array(glyphIds.length * 4);\n        let boundsIdx = 0;\n        let positionsIdx = 0;\n        const quadsStart = now$1();\n        const fontGlyphMaps = fontData.map((font)=>{\n            let map = atlas.glyphsByFont.get(font.src);\n            if (!map) {\n                atlas.glyphsByFont.set(font.src, map = new Map());\n            }\n            return map;\n        });\n        glyphIds.forEach((glyphId, i)=>{\n            const fontIndex = glyphFontIndices[i];\n            const { src: fontSrc, unitsPerEm } = fontData[fontIndex];\n            let glyphInfo = fontGlyphMaps[fontIndex].get(glyphId);\n            // If this is a glyphId not seen before, add it to the atlas\n            if (!glyphInfo) {\n                const { path, pathBounds } = result.glyphData[fontSrc][glyphId];\n                // Margin around path edges in SDF, based on a percentage of the glyph's max dimension.\n                // Note we add an extra 0.5 px over the configured value because the outer 0.5 doesn't contain\n                // useful interpolated values and will be ignored anyway.\n                const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1]) / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);\n                const atlasIndex = atlas.glyphCount++;\n                const sdfViewBox = [\n                    pathBounds[0] - fontUnitsMargin,\n                    pathBounds[1] - fontUnitsMargin,\n                    pathBounds[2] + fontUnitsMargin,\n                    pathBounds[3] + fontUnitsMargin\n                ];\n                fontGlyphMaps[fontIndex].set(glyphId, glyphInfo = {\n                    path,\n                    atlasIndex,\n                    sdfViewBox\n                });\n                // Collect those that need SDF generation\n                neededSDFs.push(glyphInfo);\n            }\n            // Calculate bounds for renderable quads\n            // TODO can we get this back off the main thread?\n            const { sdfViewBox } = glyphInfo;\n            const posX = glyphPositions[positionsIdx++];\n            const posY = glyphPositions[positionsIdx++];\n            const fontSizeMult = fontSize / unitsPerEm;\n            glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;\n            glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;\n            glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;\n            glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;\n            // Convert glyphId to SDF index for the shader\n            glyphIds[i] = glyphInfo.atlasIndex;\n        });\n        timings.quads = (timings.quads || 0) + (now$1() - quadsStart);\n        const sdfStart = now$1();\n        timings.sdf = {};\n        // Grow the texture height by power of 2 if needed\n        const currentHeight = sdfCanvas.height;\n        const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);\n        const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));\n        if (neededHeight > currentHeight) {\n            // Since resizing the canvas clears its render buffer, it needs special handling to copy the old contents over\n            console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);\n            resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);\n            // As of Three r136 textures cannot be resized once they're allocated on the GPU, we must dispose to reallocate it\n            sdfTexture.dispose();\n        }\n        Promise.all(neededSDFs.map((glyphInfo)=>generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({ timing })=>{\n                timings.sdf[glyphInfo.atlasIndex] = timing;\n            }))).then(()=>{\n            if (neededSDFs.length && !atlas.contextLost) {\n                safariPre15Workaround(atlas);\n                sdfTexture.needsUpdate = true;\n            }\n            timings.sdfTotal = now$1() - sdfStart;\n            timings.total = now$1() - totalStart;\n            // console.log(`SDF - ${timings.sdfTotal}, Total - ${timings.total - timings.fontLoad}`)\n            // Invoke callback with the text layout arrays and updated texture\n            callback(Object.freeze({\n                parameters: args,\n                sdfTexture,\n                sdfGlyphSize,\n                sdfExponent,\n                glyphBounds,\n                glyphAtlasIndices: glyphIds,\n                glyphColors: result.glyphColors,\n                caretPositions: result.caretPositions,\n                chunkedBounds: result.chunkedBounds,\n                ascender: result.ascender,\n                descender: result.descender,\n                lineHeight: result.lineHeight,\n                capHeight: result.capHeight,\n                xHeight: result.xHeight,\n                topBaseline: result.topBaseline,\n                blockBounds: result.blockBounds,\n                visibleBounds: result.visibleBounds,\n                timings: result.timings\n            }));\n        });\n    });\n    // While the typesetting request is being handled, go ahead and make sure the atlas canvas context is\n    // \"warmed up\"; the first request will be the longest due to shader program compilation so this gets\n    // a head start on that process before SDFs actually start getting processed.\n    Promise.resolve().then(()=>{\n        if (!atlas.contextLost) {\n            warmUpSDFCanvas(sdfCanvas);\n        }\n    });\n}\nfunction generateGlyphSDF({ path, atlasIndex, sdfViewBox }, { sdfGlyphSize, sdfCanvas, contextLost }, useGPU) {\n    if (contextLost) {\n        // If the context is lost there's nothing we can do, just quit silently and let it\n        // get regenerated when the context is restored\n        return Promise.resolve({\n            timing: -1\n        });\n    }\n    const { textureWidth, sdfExponent } = CONFIG;\n    const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);\n    const squareIndex = Math.floor(atlasIndex / 4);\n    const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;\n    const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;\n    const channel = atlasIndex % 4;\n    return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU);\n}\nfunction initContextLossHandling(atlas) {\n    const canvas = atlas.sdfCanvas;\n    /*\n  // Begin context loss simulation\n  if (!window.WebGLDebugUtils) {\n    let script = document.getElementById('WebGLDebugUtilsScript')\n    if (!script) {\n      script = document.createElement('script')\n      script.id = 'WebGLDebugUtils'\n      document.head.appendChild(script)\n      script.src = 'https://cdn.jsdelivr.net/gh/KhronosGroup/WebGLDeveloperTools@b42e702/src/debug/webgl-debug.js'\n    }\n    script.addEventListener('load', () => {\n      initContextLossHandling(atlas)\n    })\n    return\n  }\n  window.WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)\n  canvas.loseContextInNCalls(500)\n  canvas.addEventListener('webglcontextrestored', (event) => {\n    canvas.loseContextInNCalls(5000)\n  })\n  // End context loss simulation\n  */ canvas.addEventListener(\"webglcontextlost\", (event)=>{\n        console.log(\"Context Lost\", event);\n        event.preventDefault();\n        atlas.contextLost = true;\n    });\n    canvas.addEventListener(\"webglcontextrestored\", (event)=>{\n        console.log(\"Context Restored\", event);\n        atlas.contextLost = false;\n        // Regenerate all glyphs into the restored canvas:\n        const promises = [];\n        atlas.glyphsByFont.forEach((glyphMap)=>{\n            glyphMap.forEach((glyph)=>{\n                promises.push(generateGlyphSDF(glyph, atlas, true));\n            });\n        });\n        Promise.all(promises).then(()=>{\n            safariPre15Workaround(atlas);\n            atlas.sdfTexture.needsUpdate = true;\n        });\n    });\n}\n/**\n * Preload a given font and optionally pre-generate glyph SDFs for one or more character sequences.\n * This can be useful to avoid long pauses when first showing text in a scene, by preloading the\n * needed fonts and glyphs up front along with other assets.\n *\n * @param {object} options\n * @param {string} options.font - URL of the font file to preload. If not given, the default font will\n *        be loaded.\n * @param {string|string[]} options.characters - One or more character sequences for which to pre-\n *        generate glyph SDFs. Note that this will honor ligature substitution, so you may need\n *        to specify ligature sequences in addition to their individual characters to get all\n *        possible glyphs, e.g. `[\"t\", \"h\", \"th\"]` to get the \"t\" and \"h\" glyphs plus the \"th\" ligature.\n * @param {number} options.sdfGlyphSize - The size at which to prerender the SDF textures for the\n *        specified `characters`.\n * @param {function} callback - A function that will be called when the preloading is complete.\n */ function preloadFont({ font, characters, sdfGlyphSize }, callback) {\n    let text = Array.isArray(characters) ? characters.join(\"\\n\") : \"\" + characters;\n    getTextRenderInfo({\n        font,\n        sdfGlyphSize,\n        text\n    }, callback);\n}\n// Local assign impl so we don't have to import troika-core\nfunction assign(toObj, fromObj) {\n    for(let key in fromObj){\n        if (fromObj.hasOwnProperty(key)) {\n            toObj[key] = fromObj[key];\n        }\n    }\n    return toObj;\n}\n// Utility for making URLs absolute\nlet linkEl;\nfunction toAbsoluteURL(path) {\n    if (!linkEl) {\n        linkEl = typeof document === \"undefined\" ? {} : document.createElement(\"a\");\n    }\n    linkEl.href = path;\n    return linkEl.href;\n}\n/**\n * Safari < v15 seems unable to use the SDF webgl canvas as a texture. This applies a workaround\n * where it reads the pixels out of that canvas and uploads them as a data texture instead, at\n * a slight performance cost.\n */ function safariPre15Workaround(atlas) {\n    // Use createImageBitmap support as a proxy for Safari<15, all other mainstream browsers\n    // have supported it for a long while so any false positives should be minimal.\n    if (typeof createImageBitmap !== \"function\") {\n        console.info(\"Safari<15: applying SDF canvas workaround\");\n        const { sdfCanvas, sdfTexture } = atlas;\n        const { width, height } = sdfCanvas;\n        const gl = atlas.sdfCanvas.getContext(\"webgl\");\n        let pixels = sdfTexture.image.data;\n        if (!pixels || pixels.length !== width * height * 4) {\n            pixels = new Uint8Array(width * height * 4);\n            sdfTexture.image = {\n                width,\n                height,\n                data: pixels\n            };\n            sdfTexture.flipY = false;\n            sdfTexture.isDataTexture = true;\n        }\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    }\n}\nconst typesetterWorkerModule = /*#__PURE__*/ (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n    name: \"Typesetter\",\n    dependencies: [\n        createTypesetter,\n        fontResolverWorkerModule,\n        bidi_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n    ],\n    init (createTypesetter, fontResolver, bidiFactory) {\n        return createTypesetter(fontResolver, bidiFactory());\n    }\n});\nconst typesetInWorker = /*#__PURE__*/ (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n    name: \"Typesetter\",\n    dependencies: [\n        typesetterWorkerModule\n    ],\n    init (typesetter) {\n        return function(args) {\n            return new Promise((resolve)=>{\n                typesetter.typeset(args, resolve);\n            });\n        };\n    },\n    getTransferables (result) {\n        // Mark array buffers as transferable to avoid cloning during postMessage\n        const transferables = [];\n        for(let p in result){\n            if (result[p] && result[p].buffer) {\n                transferables.push(result[p].buffer);\n            }\n        }\n        return transferables;\n    }\n});\nconst typesetOnMainThread = typesetInWorker.onMainThread;\nfunction dumpSDFTextures() {\n    Object.keys(atlases).forEach((size)=>{\n        const canvas = atlases[size].sdfCanvas;\n        const { width, height } = canvas;\n        console.log(\"%c.\", `\n      background: url(${canvas.toDataURL()});\n      background-size: ${width}px ${height}px;\n      color: transparent;\n      font-size: 0;\n      line-height: ${height}px;\n      padding-left: ${width}px;\n    `);\n    });\n}\nconst templateGeometries = {};\nfunction getTemplateGeometry(detail) {\n    let geom = templateGeometries[detail];\n    if (!geom) {\n        geom = templateGeometries[detail] = new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, detail, detail).translate(0.5, 0.5, 0);\n    }\n    return geom;\n}\nconst glyphBoundsAttrName = \"aTroikaGlyphBounds\";\nconst glyphIndexAttrName = \"aTroikaGlyphIndex\";\nconst glyphColorAttrName = \"aTroikaGlyphColor\";\n/**\n@class GlyphsGeometry\n\nA specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to\nrender the glyphs using GPU instancing of a single quad, rather than constructing a whole\ngeometry with vertices, for much smaller attribute arraybuffers according to this math:\n\n  Where N = number of glyphs...\n\n  Instanced:\n  - position: 4 * 3\n  - index: 2 * 3\n  - normal: 4 * 3\n  - uv: 4 * 2\n  - glyph x/y bounds: N * 4\n  - glyph indices: N * 1\n  = 5N + 38\n\n  Non-instanced:\n  - position: N * 4 * 3\n  - index: N * 2 * 3\n  - normal: N * 4 * 3\n  - uv: N * 4 * 2\n  - glyph indices: N * 1\n  = 39N\n\nA downside of this is the rare-but-possible lack of the instanced arrays extension,\nwhich we could potentially work around with a fallback non-instanced implementation.\n\n*/ class GlyphsGeometry extends three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferGeometry {\n    constructor(){\n        super();\n        this.detail = 1;\n        this.curveRadius = 0;\n        // Define groups for rendering text outline as a separate pass; these will only\n        // be used when the `material` getter returns an array, i.e. outlineWidth > 0.\n        this.groups = [\n            {\n                start: 0,\n                count: Infinity,\n                materialIndex: 0\n            },\n            {\n                start: 0,\n                count: Infinity,\n                materialIndex: 1\n            }\n        ];\n        // Preallocate empty bounding objects\n        this.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_3__.Sphere();\n        this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_3__.Box3();\n    }\n    computeBoundingSphere() {\n    // No-op; we'll sync the boundingSphere proactively when needed.\n    }\n    computeBoundingBox() {\n    // No-op; we'll sync the boundingBox proactively when needed.\n    }\n    set detail(detail) {\n        if (detail !== this._detail) {\n            this._detail = detail;\n            if (typeof detail !== \"number\" || detail < 1) {\n                detail = 1;\n            }\n            let tpl = getTemplateGeometry(detail);\n            [\n                \"position\",\n                \"normal\",\n                \"uv\"\n            ].forEach((attr)=>{\n                this.attributes[attr] = tpl.attributes[attr].clone();\n            });\n            this.setIndex(tpl.getIndex().clone());\n        }\n    }\n    get detail() {\n        return this._detail;\n    }\n    set curveRadius(r) {\n        if (r !== this._curveRadius) {\n            this._curveRadius = r;\n            this._updateBounds();\n        }\n    }\n    get curveRadius() {\n        return this._curveRadius;\n    }\n    /**\n   * Update the geometry for a new set of glyphs.\n   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs\n   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1\n   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within\n   *        the SDF atlas texture.\n   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs\n   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N\n   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be\n   *        used with `applyClipRect` to choose an optimized `instanceCount`.\n   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.\n   */ updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {\n        // Update the instance attributes\n        this.updateAttributeData(glyphBoundsAttrName, glyphBounds, 4);\n        this.updateAttributeData(glyphIndexAttrName, glyphAtlasIndices, 1);\n        this.updateAttributeData(glyphColorAttrName, glyphColors, 3);\n        this._blockBounds = blockBounds;\n        this._chunkedBounds = chunkedBounds;\n        this.instanceCount = glyphAtlasIndices.length;\n        this._updateBounds();\n    }\n    _updateBounds() {\n        const bounds = this._blockBounds;\n        if (bounds) {\n            const { curveRadius, boundingBox: bbox } = this;\n            if (curveRadius) {\n                const { PI, floor, min, max, sin, cos } = Math;\n                const halfPi = PI / 2;\n                const twoPi = PI * 2;\n                const absR = Math.abs(curveRadius);\n                const leftAngle = bounds[0] / absR;\n                const rightAngle = bounds[2] / absR;\n                const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi) ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);\n                const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi) ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);\n                const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi) ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);\n                bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);\n                bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);\n            } else {\n                bbox.min.set(bounds[0], bounds[1], 0);\n                bbox.max.set(bounds[2], bounds[3], 0);\n            }\n            bbox.getBoundingSphere(this.boundingSphere);\n        }\n    }\n    /**\n   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest\n   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization\n   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would\n   * be clipped anyway.\n   *\n   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting\n   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the\n   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,\n   * but at the expense of much larger attribute buffers (see classdoc above.)\n   *\n   * @param {Vector4} clipRect\n   */ applyClipRect(clipRect) {\n        let count = this.getAttribute(glyphIndexAttrName).count;\n        let chunks = this._chunkedBounds;\n        if (chunks) {\n            for(let i = chunks.length; i--;){\n                count = chunks[i].end;\n                let rect = chunks[i].rect;\n                // note: both rects are l-b-r-t\n                if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {\n                    break;\n                }\n            }\n        }\n        this.instanceCount = count;\n    }\n    /**\n   * Utility for updating instance attributes with automatic resizing\n   */ updateAttributeData(attrName, newArray, itemSize) {\n        const attr = this.getAttribute(attrName);\n        if (newArray) {\n            // If length isn't changing, just update the attribute's array data\n            if (attr && attr.array.length === newArray.length) {\n                attr.array.set(newArray);\n                attr.needsUpdate = true;\n            } else {\n                this.setAttribute(attrName, new three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferAttribute(newArray, itemSize));\n                // If the new attribute has a different size, we also have to (as of r117) manually clear the\n                // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706\n                // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in\n                // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a\n                // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly\n                // implies it should be supported. It's possible we need to\n                delete this._maxInstanceCount; //for r117+, could be fragile\n                this.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like\n            }\n        } else if (attr) {\n            this.deleteAttribute(attrName);\n        }\n    }\n}\n// language=GLSL\nconst VERTEX_DEFS = `\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaEdgeOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n`;\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst VERTEX_TRANSFORM = `\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n${\"\" /* NOTE: it seems important to calculate the glyph's bounding texture UVs here in the\n  vertex shader, rather than in the fragment shader, as the latter gives strange artifacts\n  on some glyphs (those in the leftmost texture column) on some systems. The exact reason\n  isn't understood but doing this here, then mix()-ing in the fragment shader, seems to work. */ }\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n`;\n// language=GLSL\nconst FRAGMENT_DEFS = `\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaEdgeOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of exponential encoding in webgl-sdf-generator\n  ${\"\" /* TODO - there's some slight inaccuracy here when dealing with interpolated alpha values; those\n    are linearly interpolated where the encoding is exponential. Look into improving this by rounding\n    to nearest 2 whole texels, decoding those exponential values, and linearly interpolating the result.\n  */ }\n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  ${\"\" /*\n    When the standard derivatives extension is available, we choose an antialiasing alpha threshold based\n    on the potential change in the SDF's alpha from this fragment to its neighbor. This strategy maximizes \n    readability and edge crispness at all sizes and screen resolutions.\n  */ }\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  ${\"\" /* \n  // TODO more refined extrapolated distance by adjusting for angle of gradient at edge...\n  // This has potential but currently gives very jagged extensions, maybe due to precision issues?\n  float uvStep = 1.0 / uTroikaSDFGlyphSize;\n  vec2 neighbor1UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  vec2 neighbor2UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * -sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * -sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  float neighbor1Distance = troikaGlyphUvToDistance(neighbor1UV);\n  float neighbor2Distance = troikaGlyphUvToDistance(neighbor2UV);\n  float distToUnclamped = length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n  float distToNeighbor = length((clampedGlyphUV - neighbor1UV) * vTroikaGlyphDimensions);\n  float gradientAngle1 = min(asin(abs(neighbor1Distance - distance) / distToNeighbor), PI / 2.0);\n  float gradientAngle2 = min(asin(abs(neighbor2Distance - distance) / distToNeighbor), PI / 2.0);\n  distance += (cos(gradientAngle1) + cos(gradientAngle2)) / 2.0 * distToUnclamped;\n  */ }\n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n`;\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst FRAGMENT_TRANSFORM = `\nfloat aaDist = troikaGetAADist();\nfloat fragDistance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  fragDistance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n`;\n/**\n * Create a material for rendering text, derived from a baseMaterial\n */ function createTextDerivedMaterial(baseMaterial) {\n    const textMaterial = (0,troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.createDerivedMaterial)(baseMaterial, {\n        chained: true,\n        extensions: {\n            derivatives: true\n        },\n        uniforms: {\n            uTroikaSDFTexture: {\n                value: null\n            },\n            uTroikaSDFTextureSize: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()\n            },\n            uTroikaSDFGlyphSize: {\n                value: 0\n            },\n            uTroikaSDFExponent: {\n                value: 0\n            },\n            uTroikaTotalBounds: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0, 0, 0, 0)\n            },\n            uTroikaClipRect: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0, 0, 0, 0)\n            },\n            uTroikaEdgeOffset: {\n                value: 0\n            },\n            uTroikaFillOpacity: {\n                value: 1\n            },\n            uTroikaPositionOffset: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()\n            },\n            uTroikaCurveRadius: {\n                value: 0\n            },\n            uTroikaBlurRadius: {\n                value: 0\n            },\n            uTroikaStrokeWidth: {\n                value: 0\n            },\n            uTroikaStrokeColor: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Color()\n            },\n            uTroikaStrokeOpacity: {\n                value: 1\n            },\n            uTroikaOrient: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Matrix3()\n            },\n            uTroikaUseGlyphColors: {\n                value: true\n            },\n            uTroikaSDFDebug: {\n                value: false\n            }\n        },\n        vertexDefs: VERTEX_DEFS,\n        vertexTransform: VERTEX_TRANSFORM,\n        fragmentDefs: FRAGMENT_DEFS,\n        fragmentColorTransform: FRAGMENT_TRANSFORM,\n        customRewriter ({ vertexShader, fragmentShader }) {\n            let uDiffuseRE = /\\buniform\\s+vec3\\s+diffuse\\b/;\n            if (uDiffuseRE.test(fragmentShader)) {\n                // Replace all instances of `diffuse` with our varying\n                fragmentShader = fragmentShader.replace(uDiffuseRE, \"varying vec3 vTroikaGlyphColor\").replace(/\\bdiffuse\\b/g, \"vTroikaGlyphColor\");\n                // Make sure the vertex shader declares the uniform so we can grab it as a fallback\n                if (!uDiffuseRE.test(vertexShader)) {\n                    vertexShader = vertexShader.replace(troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.voidMainRegExp, \"uniform vec3 diffuse;\\n$&\\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\\n\");\n                }\n            }\n            return {\n                vertexShader,\n                fragmentShader\n            };\n        }\n    });\n    // Force transparency - TODO is this reasonable?\n    textMaterial.transparent = true;\n    // Force single draw call when double-sided\n    textMaterial.forceSinglePass = true;\n    Object.defineProperties(textMaterial, {\n        isTroikaTextMaterial: {\n            value: true\n        },\n        // WebGLShadowMap reverses the side of the shadow material by default, which fails\n        // for planes, so here we force the `shadowSide` to always match the main side.\n        shadowSide: {\n            get () {\n                return this.side;\n            },\n            set () {\n            //no-op\n            }\n        }\n    });\n    return textMaterial;\n}\nconst defaultMaterial = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n    color: 0xffffff,\n    side: three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide,\n    transparent: true\n});\nconst defaultStrokeColor = 0x808080;\nconst tempMat4 = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst tempVec3a = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempVec3b = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempArray = [];\nconst origin = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst defaultOrient = \"+x+y\";\nfunction first(o) {\n    return Array.isArray(o) ? o[0] : o;\n}\nlet getFlatRaycastMesh = ()=>{\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1), defaultMaterial);\n    getFlatRaycastMesh = ()=>mesh;\n    return mesh;\n};\nlet getCurvedRaycastMesh = ()=>{\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, 32, 1), defaultMaterial);\n    getCurvedRaycastMesh = ()=>mesh;\n    return mesh;\n};\nconst syncStartEvent = {\n    type: \"syncstart\"\n};\nconst syncCompleteEvent = {\n    type: \"synccomplete\"\n};\nconst SYNCABLE_PROPS = [\n    \"font\",\n    \"fontSize\",\n    \"fontStyle\",\n    \"fontWeight\",\n    \"lang\",\n    \"letterSpacing\",\n    \"lineHeight\",\n    \"maxWidth\",\n    \"overflowWrap\",\n    \"text\",\n    \"direction\",\n    \"textAlign\",\n    \"textIndent\",\n    \"whiteSpace\",\n    \"anchorX\",\n    \"anchorY\",\n    \"colorRanges\",\n    \"sdfGlyphSize\"\n];\nconst COPYABLE_PROPS = SYNCABLE_PROPS.concat(\"material\", \"color\", \"depthOffset\", \"clipRect\", \"curveRadius\", \"orientation\", \"glyphGeometryDetail\");\n/**\n * @class Text\n *\n * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance\n * fields (SDF).\n */ class Text extends three__WEBPACK_IMPORTED_MODULE_3__.Mesh {\n    constructor(){\n        const geometry = new GlyphsGeometry();\n        super(geometry, null);\n        // === Text layout properties: === //\n        /**\n     * @member {string} text\n     * The string of text to be rendered.\n     */ this.text = \"\";\n        /**\n     * @member {number|string} anchorX\n     * Defines the horizontal position in the text block that should line up with the local origin.\n     * Can be specified as a numeric x position in local units, a string percentage of the total\n     * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',\n     * or 'right'.\n     */ this.anchorX = 0;\n        /**\n     * @member {number|string} anchorY\n     * Defines the vertical position in the text block that should line up with the local origin.\n     * Can be specified as a numeric y position in local units (note: down is negative y), a string\n     * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:\n     * 'top', 'top-baseline', 'top-cap', 'top-ex', 'middle', 'bottom-baseline', or 'bottom'.\n     */ this.anchorY = 0;\n        /**\n     * @member {number} curveRadius\n     * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put\n     * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave\n     * curvature, while negative numbers put it behind the text for a convex curvature. The centerline\n     * will be aligned with the text's local origin; you can use `anchorX` to offset it.\n     *\n     * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane\n     * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.\n     */ this.curveRadius = 0;\n        /**\n     * @member {string} direction\n     * Sets the base direction for the text. The default value of \"auto\" will choose a direction based\n     * on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction.\n     */ this.direction = \"auto\";\n        /**\n     * @member {string|null} font\n     * URL of a custom font to be used. Font files can be in .ttf, .otf, or .woff (not .woff2) formats.\n     * Defaults to Noto Sans.\n     */ this.font = null; //will use default from TextBuilder\n        this.unicodeFontsURL = null; //defaults to CDN\n        /**\n     * @member {number} fontSize\n     * The size at which to render the font in local units; corresponds to the em-box height\n     * of the chosen `font`.\n     */ this.fontSize = 0.1;\n        /**\n     * @member {number|'normal'|'bold'}\n     * The weight of the font. Currently only used for fallback Noto fonts.\n     */ this.fontWeight = \"normal\";\n        /**\n     * @member {'normal'|'italic'}\n     * The style of the font. Currently only used for fallback Noto fonts.\n     */ this.fontStyle = \"normal\";\n        /**\n     * @member {string|null} lang\n     * The language code of this text; can be used for explicitly selecting certain CJK fonts.\n     */ this.lang = null;\n        /**\n     * @member {number} letterSpacing\n     * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive\n     * numbers increase spacing and negative numbers decrease it.\n     */ this.letterSpacing = 0;\n        /**\n     * @member {number|string} lineHeight\n     * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'\n     * which chooses a reasonable height based on the chosen font's ascender/descender metrics.\n     */ this.lineHeight = \"normal\";\n        /**\n     * @member {number} maxWidth\n     * The maximum width of the text block, above which text may start wrapping according to the\n     * `whiteSpace` and `overflowWrap` properties.\n     */ this.maxWidth = Infinity;\n        /**\n     * @member {string} overflowWrap\n     * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`\n     * to break at whitespace characters, or `'break-word'` to allow breaking within words.\n     * Defaults to `'normal'`.\n     */ this.overflowWrap = \"normal\";\n        /**\n     * @member {string} textAlign\n     * The horizontal alignment of each line of text within the overall text bounding box.\n     */ this.textAlign = \"left\";\n        /**\n     * @member {number} textIndent\n     * Indentation for the first character of a line; see CSS `text-indent`.\n     */ this.textIndent = 0;\n        /**\n     * @member {string} whiteSpace\n     * Defines whether text should wrap when a line reaches the `maxWidth`. Can\n     * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,\n     * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to\n     * manually break lines, making it behave more like `'pre-wrap'` does in CSS.\n     */ this.whiteSpace = \"normal\";\n        // === Presentation properties: === //\n        /**\n     * @member {THREE.Material} material\n     * Defines a _base_ material to be used when rendering the text. This material will be\n     * automatically replaced with a material derived from it, that adds shader code to\n     * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.\n     * By default it will derive from a simple white MeshBasicMaterial, but you can use any\n     * of the other mesh materials to gain other features like lighting, texture maps, etc.\n     *\n     * Also see the `color` shortcut property.\n     */ this.material = null;\n        /**\n     * @member {string|number|THREE.Color} color\n     * This is a shortcut for setting the `color` of the text's material. You can use this\n     * if you don't want to specify a whole custom `material`. Also, if you do use a custom\n     * `material`, this color will only be used for this particuar Text instance, even if\n     * that same material instance is shared across multiple Text objects.\n     */ this.color = null;\n        /**\n     * @member {object|null} colorRanges\n     * WARNING: This API is experimental and may change.\n     * This allows more fine-grained control of colors for individual or ranges of characters,\n     * taking precedence over the material's `color`. Its format is an Object whose keys each\n     * define a starting character index for a range, and whose values are the color for each\n     * range. The color value can be a numeric hex color value, a `THREE.Color` object, or\n     * any of the strings accepted by `THREE.Color`.\n     */ this.colorRanges = null;\n        /**\n     * @member {number|string} outlineWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means\n     * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.\n     */ this.outlineWidth = 0;\n        /**\n     * @member {string|number|THREE.Color} outlineColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to black.\n     */ this.outlineColor = 0x000000;\n        /**\n     * @member {number} outlineOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to `1`.\n     */ this.outlineOpacity = 1;\n        /**\n     * @member {number|string} outlineBlur\n     * WARNING: This API is experimental and may change.\n     * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is\n     * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */ this.outlineBlur = 0;\n        /**\n     * @member {number|string} outlineOffsetX\n     * WARNING: This API is experimental and may change.\n     * A horizontal offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */ this.outlineOffsetX = 0;\n        /**\n     * @member {number|string} outlineOffsetY\n     * WARNING: This API is experimental and may change.\n     * A vertical offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */ this.outlineOffsetY = 0;\n        /**\n     * @member {number|string} strokeWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */ this.strokeWidth = 0;\n        /**\n     * @member {string|number|THREE.Color} strokeColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.\n     */ this.strokeColor = defaultStrokeColor;\n        /**\n     * @member {number} strokeOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.\n     */ this.strokeOpacity = 1;\n        /**\n     * @member {number} fillOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows\n     * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the\n     * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.\n     */ this.fillOpacity = 1;\n        /**\n     * @member {number} depthOffset\n     * This is a shortcut for setting the material's `polygonOffset` and related properties,\n     * which can be useful in preventing z-fighting when this text is laid on top of another\n     * plane in the scene. Positive numbers are further from the camera, negatives closer.\n     */ this.depthOffset = 0;\n        /**\n     * @member {Array<number>} clipRect\n     * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all\n     * pixels will be discarded. This can be used for example to clip overflowing text when\n     * `whiteSpace='nowrap'`.\n     */ this.clipRect = null;\n        /**\n     * @member {string} orientation\n     * Defines the axis plane on which the text should be laid out when the mesh has no extra\n     * rotation transform. It is specified as a string with two axes: the horizontal axis with\n     * positive pointing right, and the vertical axis with positive pointing up. By default this\n     * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y\n     * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's\n     * top toward negative z and facing positive y.\n     */ this.orientation = defaultOrient;\n        /**\n     * @member {number} glyphGeometryDetail\n     * Controls number of vertical/horizontal segments that make up each glyph's rectangular\n     * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom\n     * vertex shader effects, for example.\n     */ this.glyphGeometryDetail = 1;\n        /**\n     * @member {number|null} sdfGlyphSize\n     * The size of each glyph's SDF (signed distance field) used for rendering. This must be a\n     * power-of-two number. Defaults to 64 which is generally a good balance of size and quality\n     * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing\n     * the sharpness of corners and preventing loss of very thin lines, at the expense of\n     * increased memory footprint and longer SDF generation time.\n     */ this.sdfGlyphSize = null;\n        /**\n     * @member {boolean} gpuAccelerateSDF\n     * When `true`, the SDF generation process will be GPU-accelerated with WebGL when possible,\n     * making it much faster especially for complex glyphs, and falling back to a JavaScript version\n     * executed in web workers when support isn't available. It should automatically detect support,\n     * but it's still somewhat experimental, so you can set it to `false` to force it to use the JS\n     * version if you encounter issues with it.\n     */ this.gpuAccelerateSDF = true;\n        this.debugSDF = false;\n    }\n    /**\n   * Updates the text rendering according to the current text-related configuration properties.\n   * This is an async process, so you can pass in a callback function to be executed when it\n   * finishes.\n   * @param {function} [callback]\n   */ sync(callback) {\n        if (this._needsSync) {\n            this._needsSync = false;\n            // If there's another sync still in progress, queue\n            if (this._isSyncing) {\n                (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);\n            } else {\n                this._isSyncing = true;\n                this.dispatchEvent(syncStartEvent);\n                getTextRenderInfo({\n                    text: this.text,\n                    font: this.font,\n                    lang: this.lang,\n                    fontSize: this.fontSize || 0.1,\n                    fontWeight: this.fontWeight || \"normal\",\n                    fontStyle: this.fontStyle || \"normal\",\n                    letterSpacing: this.letterSpacing || 0,\n                    lineHeight: this.lineHeight || \"normal\",\n                    maxWidth: this.maxWidth,\n                    direction: this.direction || \"auto\",\n                    textAlign: this.textAlign,\n                    textIndent: this.textIndent,\n                    whiteSpace: this.whiteSpace,\n                    overflowWrap: this.overflowWrap,\n                    anchorX: this.anchorX,\n                    anchorY: this.anchorY,\n                    colorRanges: this.colorRanges,\n                    includeCaretPositions: true,\n                    sdfGlyphSize: this.sdfGlyphSize,\n                    gpuAccelerateSDF: this.gpuAccelerateSDF,\n                    unicodeFontsURL: this.unicodeFontsURL\n                }, (textRenderInfo)=>{\n                    this._isSyncing = false;\n                    // Save result for later use in onBeforeRender\n                    this._textRenderInfo = textRenderInfo;\n                    // Update the geometry attributes\n                    this.geometry.updateGlyphs(textRenderInfo.glyphBounds, textRenderInfo.glyphAtlasIndices, textRenderInfo.blockBounds, textRenderInfo.chunkedBounds, textRenderInfo.glyphColors);\n                    // If we had extra sync requests queued up, kick it off\n                    const queued = this._queuedSyncs;\n                    if (queued) {\n                        this._queuedSyncs = null;\n                        this._needsSync = true;\n                        this.sync(()=>{\n                            queued.forEach((fn)=>fn && fn());\n                        });\n                    }\n                    this.dispatchEvent(syncCompleteEvent);\n                    if (callback) {\n                        callback();\n                    }\n                });\n            }\n        }\n    }\n    /**\n   * Initiate a sync if needed - note it won't complete until next frame at the\n   * earliest so if possible it's a good idea to call sync() manually as soon as\n   * all the properties have been set.\n   * @override\n   */ onBeforeRender(renderer, scene, camera, geometry, material, group) {\n        this.sync();\n        // This may not always be a text material, e.g. if there's a scene.overrideMaterial present\n        if (material.isTroikaTextMaterial) {\n            this._prepareForRender(material);\n        }\n    }\n    /**\n   * Shortcut to dispose the geometry specific to this instance.\n   * Note: we don't also dispose the derived material here because if anything else is\n   * sharing the same base material it will result in a pause next frame as the program\n   * is recompiled. Instead users can dispose the base material manually, like normal,\n   * and we'll also dispose the derived material at that time.\n   */ dispose() {\n        this.geometry.dispose();\n    }\n    /**\n   * @property {TroikaTextRenderInfo|null} textRenderInfo\n   * @readonly\n   * The current processed rendering data for this TextMesh, returned by the TextBuilder after\n   * a `sync()` call. This will be `null` initially, and may be stale for a short period until\n   * the asynchrous `sync()` process completes.\n   */ get textRenderInfo() {\n        return this._textRenderInfo || null;\n    }\n    /**\n   * Create the text derived material from the base material. Can be overridden to use a custom\n   * derived material.\n   */ createDerivedMaterial(baseMaterial) {\n        return createTextDerivedMaterial(baseMaterial);\n    }\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    get material() {\n        let derivedMaterial = this._derivedMaterial;\n        const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());\n        if (!derivedMaterial || !derivedMaterial.isDerivedFrom(baseMaterial)) {\n            derivedMaterial = this._derivedMaterial = this.createDerivedMaterial(baseMaterial);\n            // dispose the derived material when its base material is disposed:\n            baseMaterial.addEventListener(\"dispose\", function onDispose() {\n                baseMaterial.removeEventListener(\"dispose\", onDispose);\n                derivedMaterial.dispose();\n            });\n        }\n        // If text outline is configured, render it as a preliminary draw using Three's multi-material\n        // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi\n        // materials ensures the layers are always rendered consecutively in a consistent order.\n        // Each layer will trigger onBeforeRender with the appropriate material.\n        if (this.hasOutline()) {\n            let outlineMaterial = derivedMaterial._outlineMtl;\n            if (!outlineMaterial) {\n                outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {\n                    id: {\n                        value: derivedMaterial.id + 0.1\n                    }\n                });\n                outlineMaterial.isTextOutlineMaterial = true;\n                outlineMaterial.depthWrite = false;\n                outlineMaterial.map = null; //???\n                derivedMaterial.addEventListener(\"dispose\", function onDispose() {\n                    derivedMaterial.removeEventListener(\"dispose\", onDispose);\n                    outlineMaterial.dispose();\n                });\n            }\n            return [\n                outlineMaterial,\n                derivedMaterial\n            ];\n        } else {\n            return derivedMaterial;\n        }\n    }\n    set material(baseMaterial) {\n        if (baseMaterial && baseMaterial.isTroikaTextMaterial) {\n            this._derivedMaterial = baseMaterial;\n            this._baseMaterial = baseMaterial.baseMaterial;\n        } else {\n            this._baseMaterial = baseMaterial;\n        }\n    }\n    hasOutline() {\n        return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY);\n    }\n    get glyphGeometryDetail() {\n        return this.geometry.detail;\n    }\n    set glyphGeometryDetail(detail) {\n        this.geometry.detail = detail;\n    }\n    get curveRadius() {\n        return this.geometry.curveRadius;\n    }\n    set curveRadius(r) {\n        this.geometry.curveRadius = r;\n    }\n    // Create and update material for shadows upon request:\n    get customDepthMaterial() {\n        return first(this.material).getDepthMaterial();\n    }\n    set customDepthMaterial(m) {\n    // future: let the user override with their own?\n    }\n    get customDistanceMaterial() {\n        return first(this.material).getDistanceMaterial();\n    }\n    set customDistanceMaterial(m) {\n    // future: let the user override with their own?\n    }\n    _prepareForRender(material) {\n        const isOutline = material.isTextOutlineMaterial;\n        const uniforms = material.uniforms;\n        const textInfo = this.textRenderInfo;\n        if (textInfo) {\n            const { sdfTexture, blockBounds } = textInfo;\n            uniforms.uTroikaSDFTexture.value = sdfTexture;\n            uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);\n            uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;\n            uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;\n            uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);\n            uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;\n            let distanceOffset = 0;\n            let blurRadius = 0;\n            let strokeWidth = 0;\n            let fillOpacity;\n            let strokeOpacity;\n            let strokeColor;\n            let offsetX = 0;\n            let offsetY = 0;\n            if (isOutline) {\n                let { outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity } = this;\n                distanceOffset = this._parsePercent(outlineWidth) || 0;\n                blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);\n                fillOpacity = outlineOpacity;\n                offsetX = this._parsePercent(outlineOffsetX) || 0;\n                offsetY = this._parsePercent(outlineOffsetY) || 0;\n            } else {\n                strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);\n                if (strokeWidth) {\n                    strokeColor = this.strokeColor;\n                    uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);\n                    strokeOpacity = this.strokeOpacity;\n                    if (strokeOpacity == null) strokeOpacity = 1;\n                }\n                fillOpacity = this.fillOpacity;\n            }\n            uniforms.uTroikaEdgeOffset.value = distanceOffset;\n            uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);\n            uniforms.uTroikaBlurRadius.value = blurRadius;\n            uniforms.uTroikaStrokeWidth.value = strokeWidth;\n            uniforms.uTroikaStrokeOpacity.value = strokeOpacity;\n            uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;\n            uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;\n            let clipRect = this.clipRect;\n            if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {\n                uniforms.uTroikaClipRect.value.fromArray(clipRect);\n            } else {\n                // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines\n                const pad = (this.fontSize || 0.1) * 100;\n                uniforms.uTroikaClipRect.value.set(blockBounds[0] - pad, blockBounds[1] - pad, blockBounds[2] + pad, blockBounds[3] + pad);\n            }\n            this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);\n        }\n        uniforms.uTroikaSDFDebug.value = !!this.debugSDF;\n        material.polygonOffset = !!this.depthOffset;\n        material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;\n        // Shortcut for setting material color via `color` prop on the mesh; this is\n        // applied only to the derived material to avoid mutating a shared base material.\n        const color = isOutline ? this.outlineColor || 0 : this.color;\n        if (color == null) {\n            delete material.color; //inherit from base\n        } else {\n            const colorObj = material.hasOwnProperty(\"color\") ? material.color : material.color = new three__WEBPACK_IMPORTED_MODULE_3__.Color();\n            if (color !== colorObj._input || typeof color === \"object\") {\n                colorObj.set(colorObj._input = color);\n            }\n        }\n        // base orientation\n        let orient = this.orientation || defaultOrient;\n        if (orient !== material._orientation) {\n            let rotMat = uniforms.uTroikaOrient.value;\n            orient = orient.replace(/[^-+xyz]/g, \"\");\n            let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);\n            if (match) {\n                let [, hSign, hAxis, vSign, vAxis] = match;\n                tempVec3a.set(0, 0, 0)[hAxis] = hSign === \"-\" ? 1 : -1;\n                tempVec3b.set(0, 0, 0)[vAxis] = vSign === \"-\" ? -1 : 1;\n                tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);\n                rotMat.setFromMatrix4(tempMat4);\n            } else {\n                rotMat.identity();\n            }\n            material._orientation = orient;\n        }\n    }\n    _parsePercent(value) {\n        if (typeof value === \"string\") {\n            let match = value.match(/^(-?[\\d.]+)%$/);\n            let pct = match ? parseFloat(match[1]) : NaN;\n            value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;\n        }\n        return value;\n    }\n    /**\n   * Translate a point in local space to an x/y in the text plane.\n   */ localPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n        target.copy(position); //simple non-curved case is 1:1\n        const r = this.curveRadius;\n        if (r) {\n            target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);\n        }\n        return target;\n    }\n    /**\n   * Translate a point in world space to an x/y in the text plane.\n   */ worldPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n        tempVec3a.copy(position);\n        return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target);\n    }\n    /**\n   * @override Custom raycasting to test against the whole text block's max rectangular bounds\n   * TODO is there any reason to make this more granular, like within individual line or glyph rects?\n   */ raycast(raycaster, intersects) {\n        const { textRenderInfo, curveRadius } = this;\n        if (textRenderInfo) {\n            const bounds = textRenderInfo.blockBounds;\n            const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();\n            const geom = raycastMesh.geometry;\n            const { position, uv } = geom.attributes;\n            for(let i = 0; i < uv.count; i++){\n                let x = bounds[0] + uv.getX(i) * (bounds[2] - bounds[0]);\n                const y = bounds[1] + uv.getY(i) * (bounds[3] - bounds[1]);\n                let z = 0;\n                if (curveRadius) {\n                    z = curveRadius - Math.cos(x / curveRadius) * curveRadius;\n                    x = Math.sin(x / curveRadius) * curveRadius;\n                }\n                position.setXYZ(i, x, y, z);\n            }\n            geom.boundingSphere = this.geometry.boundingSphere;\n            geom.boundingBox = this.geometry.boundingBox;\n            raycastMesh.matrixWorld = this.matrixWorld;\n            raycastMesh.material.side = this.material.side;\n            tempArray.length = 0;\n            raycastMesh.raycast(raycaster, tempArray);\n            for(let i = 0; i < tempArray.length; i++){\n                tempArray[i].object = this;\n                intersects.push(tempArray[i]);\n            }\n        }\n    }\n    copy(source) {\n        // Prevent copying the geometry reference so we don't end up sharing attributes between instances\n        const geom = this.geometry;\n        super.copy(source);\n        this.geometry = geom;\n        COPYABLE_PROPS.forEach((prop)=>{\n            this[prop] = source[prop];\n        });\n        return this;\n    }\n    clone() {\n        return new this.constructor().copy(this);\n    }\n}\n// Create setters for properties that affect text layout:\nSYNCABLE_PROPS.forEach((prop)=>{\n    const privateKey = \"_private_\" + prop;\n    Object.defineProperty(Text.prototype, prop, {\n        get () {\n            return this[privateKey];\n        },\n        set (value) {\n            if (value !== this[privateKey]) {\n                this[privateKey] = value;\n                this._needsSync = true;\n            }\n        }\n    });\n});\nconst syncStartEvent$1 = {\n    type: \"syncstart\"\n};\nconst syncCompleteEvent$1 = {\n    type: \"synccomplete\"\n};\nconst memberIndexAttrName = \"aTroikaTextBatchMemberIndex\";\n/*\nData texture packing strategy:\n\n# Common:\n0-15: matrix\n16-19: uTroikaTotalBounds\n20-23: uTroikaClipRect\n24: diffuse (color/outlineColor)\n25: uTroikaFillOpacity (fillOpacity/outlineOpacity)\n26: uTroikaCurveRadius\n27: <blank>\n\n# Main:\n28: uTroikaStrokeWidth\n29: uTroikaStrokeColor\n30: uTroikaStrokeOpacity\n\n# Outline:\n28-29: uTroikaPositionOffset\n30: uTroikaEdgeOffset\n31: uTroikaBlurRadius\n*/ const floatsPerMember = 32;\nconst tempBox3 = new three__WEBPACK_IMPORTED_MODULE_3__.Box3();\nconst tempColor$1 = new three__WEBPACK_IMPORTED_MODULE_3__.Color();\n/**\n * @experimental\n *\n * A specialized `Text` implementation that accepts any number of `Text` children\n * and automatically batches them together to render in a single draw call.\n *\n * The `material` of each child `Text` will be ignored, and the `material` of the\n * `BatchedText` will be used for all of them instead.\n *\n * NOTE: This only works in WebGL2 or where the OES_texture_float extension is available.\n */ class BatchedText extends Text {\n    constructor(){\n        super();\n        /**\n     * @typedef {Object} PackingInfo\n     * @property {number} index - the packing order index when last packed, or -1\n     * @property {boolean} dirty - whether it has synced since last pack\n     */ /**\n     * @type {Map<Text, PackingInfo>}\n     */ this._members = new Map();\n        this._dataTextures = {};\n        this._onMemberSynced = (e)=>{\n            this._members.get(e.target).dirty = true;\n        };\n    }\n    /**\n   * @override\n   * Batch any Text objects added as children\n   */ add(...objects) {\n        for(let i = 0; i < objects.length; i++){\n            if (objects[i] instanceof Text) {\n                this.addText(objects[i]);\n            } else {\n                super.add(objects[i]);\n            }\n        }\n        return this;\n    }\n    /**\n   * @override\n   */ remove(...objects) {\n        for(let i = 0; i < objects.length; i++){\n            if (objects[i] instanceof Text) {\n                this.removeText(objects[i]);\n            } else {\n                super.remove(objects[i]);\n            }\n        }\n        return this;\n    }\n    /**\n   * @param {Text} text\n   */ addText(text) {\n        if (!this._members.has(text)) {\n            this._members.set(text, {\n                index: -1,\n                glyphCount: -1,\n                dirty: true\n            });\n            text.addEventListener(\"synccomplete\", this._onMemberSynced);\n        }\n    }\n    /**\n   * @param {Text} text\n   */ removeText(text) {\n        this._needsRepack = true;\n        text.removeEventListener(\"synccomplete\", this._onMemberSynced);\n        this._members.delete(text);\n    }\n    /**\n   * Use the custom derivation with extra batching logic\n   */ createDerivedMaterial(baseMaterial) {\n        return createBatchedTextMaterial(baseMaterial);\n    }\n    updateMatrixWorld(force) {\n        super.updateMatrixWorld(force);\n        this.updateBounds();\n    }\n    /**\n   * Update the batched geometry bounds to hold all members\n   */ updateBounds() {\n        // Update member local matrices and the overall bounds\n        const bbox = this.geometry.boundingBox.makeEmpty();\n        this._members.forEach((_, text)=>{\n            if (text.matrixAutoUpdate) text.updateMatrix(); // ignore world matrix\n            tempBox3.copy(text.geometry.boundingBox).applyMatrix4(text.matrix);\n            bbox.union(tempBox3);\n        });\n        bbox.getBoundingSphere(this.geometry.boundingSphere);\n    }\n    /** @override */ hasOutline() {\n        // Iterator.some() not supported in Safari\n        for (let member of this._members.keys()){\n            if (member.hasOutline()) return true;\n        }\n        return false;\n    }\n    /**\n   * @override\n   * Copy member matrices and uniform values into the data texture\n   */ _prepareForRender(material) {\n        const isOutline = material.isTextOutlineMaterial;\n        material.uniforms.uTroikaIsOutline.value = isOutline;\n        // Resize the texture to fit in powers of 2\n        let texture = this._dataTextures[isOutline ? \"outline\" : \"main\"];\n        const dataLength = Math.pow(2, Math.ceil(Math.log2(this._members.size * floatsPerMember)));\n        if (!texture || dataLength !== texture.image.data.length) {\n            // console.log(`resizing: ${dataLength}`);\n            if (texture) texture.dispose();\n            const width = Math.min(dataLength / 4, 1024);\n            texture = this._dataTextures[isOutline ? \"outline\" : \"main\"] = new three__WEBPACK_IMPORTED_MODULE_3__.DataTexture(new Float32Array(dataLength), width, dataLength / 4 / width, three__WEBPACK_IMPORTED_MODULE_3__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_3__.FloatType);\n        }\n        const texData = texture.image.data;\n        const setTexData = (index, value)=>{\n            if (value !== texData[index]) {\n                texData[index] = value;\n                texture.needsUpdate = true;\n            }\n        };\n        this._members.forEach(({ index, dirty }, text)=>{\n            if (index > -1) {\n                const startIndex = index * floatsPerMember;\n                // Matrix\n                const matrix = text.matrix.elements;\n                for(let i = 0; i < 16; i++){\n                    setTexData(startIndex + i, matrix[i]);\n                }\n                // Let the member populate the uniforms, since that does all the appropriate\n                // logic and handling of defaults, and we'll just grab the results from there\n                text._prepareForRender(material);\n                const { uTroikaTotalBounds, uTroikaClipRect, uTroikaPositionOffset, uTroikaEdgeOffset, uTroikaBlurRadius, uTroikaStrokeWidth, uTroikaStrokeColor, uTroikaStrokeOpacity, uTroikaFillOpacity, uTroikaCurveRadius } = material.uniforms;\n                // Total bounds for uv\n                for(let i = 0; i < 4; i++){\n                    setTexData(startIndex + 16 + i, uTroikaTotalBounds.value.getComponent(i));\n                }\n                // Clip rect\n                for(let i = 0; i < 4; i++){\n                    setTexData(startIndex + 20 + i, uTroikaClipRect.value.getComponent(i));\n                }\n                // Color\n                let color = isOutline ? text.outlineColor || 0 : text.color;\n                if (color == null) color = this.color;\n                if (color == null) color = this.material.color;\n                if (color == null) color = 0xffffff;\n                setTexData(startIndex + 24, tempColor$1.set(color).getHex());\n                // Fill opacity / outline opacity\n                setTexData(startIndex + 25, uTroikaFillOpacity.value);\n                // Curve radius\n                setTexData(startIndex + 26, uTroikaCurveRadius.value);\n                if (isOutline) {\n                    // Outline properties\n                    setTexData(startIndex + 28, uTroikaPositionOffset.value.x);\n                    setTexData(startIndex + 29, uTroikaPositionOffset.value.y);\n                    setTexData(startIndex + 30, uTroikaEdgeOffset.value);\n                    setTexData(startIndex + 31, uTroikaBlurRadius.value);\n                } else {\n                    // Stroke properties\n                    setTexData(startIndex + 28, uTroikaStrokeWidth.value);\n                    setTexData(startIndex + 29, tempColor$1.set(uTroikaStrokeColor.value).getHex());\n                    setTexData(startIndex + 30, uTroikaStrokeOpacity.value);\n                }\n            }\n        });\n        material.setMatrixTexture(texture);\n        // For the non-member-specific uniforms:\n        super._prepareForRender(material);\n    }\n    sync(callback) {\n        // TODO: skip members updating their geometries, just use textRenderInfo directly\n        // Trigger sync on all members that need it\n        let syncPromises = this._needsRepack ? [] : null;\n        this._needsRepack = false;\n        this._members.forEach((packingInfo, text)=>{\n            if (packingInfo.dirty || text._needsSync) {\n                packingInfo.dirty = false;\n                (syncPromises || (syncPromises = [])).push(new Promise((resolve)=>{\n                    if (text._needsSync) {\n                        text.sync(resolve);\n                    } else {\n                        resolve();\n                    }\n                }));\n            }\n        });\n        // If any needed syncing, wait for them and then repack the batched geometry\n        if (syncPromises) {\n            this.dispatchEvent(syncStartEvent$1);\n            Promise.all(syncPromises).then(()=>{\n                const { geometry } = this;\n                const batchedAttributes = geometry.attributes;\n                let memberIndexes = batchedAttributes[memberIndexAttrName] && batchedAttributes[memberIndexAttrName].array || new Uint16Array(0);\n                let batchedGlyphIndexes = batchedAttributes[glyphIndexAttrName] && batchedAttributes[glyphIndexAttrName].array || new Float32Array(0);\n                let batchedGlyphBounds = batchedAttributes[glyphBoundsAttrName] && batchedAttributes[glyphBoundsAttrName].array || new Float32Array(0);\n                // Initial pass to collect total glyph count and resize the arrays if needed\n                let totalGlyphCount = 0;\n                this._members.forEach((packingInfo, { textRenderInfo })=>{\n                    if (textRenderInfo) {\n                        totalGlyphCount += textRenderInfo.glyphAtlasIndices.length;\n                        this._textRenderInfo = textRenderInfo; // TODO - need this, but be smarter\n                    }\n                });\n                if (totalGlyphCount !== memberIndexes.length) {\n                    memberIndexes = cloneAndResize(memberIndexes, totalGlyphCount);\n                    batchedGlyphIndexes = cloneAndResize(batchedGlyphIndexes, totalGlyphCount);\n                    batchedGlyphBounds = cloneAndResize(batchedGlyphBounds, totalGlyphCount * 4);\n                }\n                // Populate batch arrays\n                let memberIndex = 0;\n                let glyphIndex = 0;\n                this._members.forEach((packingInfo, { textRenderInfo })=>{\n                    if (textRenderInfo) {\n                        const glyphCount = textRenderInfo.glyphAtlasIndices.length;\n                        memberIndexes.fill(memberIndex, glyphIndex, glyphIndex + glyphCount);\n                        // TODO can skip these for members that are not dirty or shifting overall position:\n                        batchedGlyphIndexes.set(textRenderInfo.glyphAtlasIndices, glyphIndex, glyphIndex + glyphCount);\n                        batchedGlyphBounds.set(textRenderInfo.glyphBounds, glyphIndex * 4, (glyphIndex + glyphCount) * 4);\n                        glyphIndex += glyphCount;\n                        packingInfo.index = memberIndex++;\n                    }\n                });\n                // Update the geometry attributes\n                geometry.updateAttributeData(memberIndexAttrName, memberIndexes, 1);\n                geometry.getAttribute(memberIndexAttrName).setUsage(three__WEBPACK_IMPORTED_MODULE_3__.DynamicDrawUsage);\n                geometry.updateAttributeData(glyphIndexAttrName, batchedGlyphIndexes, 1);\n                geometry.updateAttributeData(glyphBoundsAttrName, batchedGlyphBounds, 4);\n                this.updateBounds();\n                this.dispatchEvent(syncCompleteEvent$1);\n                if (callback) {\n                    callback();\n                }\n            });\n        }\n    }\n    copy(source) {\n        if (source instanceof BatchedText) {\n            super.copy(source);\n            this._members.forEach((_, text)=>this.removeText(text));\n            source._members.forEach((_, text)=>this.addText(text));\n        }\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        Object.values(this._dataTextures).forEach((tex)=>tex.dispose());\n    }\n}\nfunction cloneAndResize(source, newLength) {\n    const copy = new source.constructor(newLength);\n    copy.set(source.subarray(0, newLength));\n    return copy;\n}\nfunction createBatchedTextMaterial(baseMaterial) {\n    const texUniformName = \"uTroikaMatricesTexture\";\n    const texSizeUniformName = \"uTroikaMatricesTextureSize\";\n    // Due to how vertexTransform gets injected, the matrix transforms must happen\n    // in the base material of TextDerivedMaterial, but other transforms to its\n    // shader must come after, so we sandwich it between two derivations.\n    // Transform the vertex position\n    let batchMaterial = (0,troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.createDerivedMaterial)(baseMaterial, {\n        chained: true,\n        uniforms: {\n            [texSizeUniformName]: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()\n            },\n            [texUniformName]: {\n                value: null\n            }\n        },\n        // language=GLSL\n        vertexDefs: `\n      uniform highp sampler2D ${texUniformName};\n      uniform vec2 ${texSizeUniformName};\n      attribute float ${memberIndexAttrName};\n\n      vec4 troikaBatchTexel(float offset) {\n        offset += ${memberIndexAttrName} * ${floatsPerMember.toFixed(1)} / 4.0;\n        float w = ${texSizeUniformName}.x;\n        vec2 uv = (vec2(mod(offset, w), floor(offset / w)) + 0.5) / ${texSizeUniformName};\n        return texture2D(${texUniformName}, uv);\n      }\n    `,\n        // language=GLSL prefix=\"void main() {\" suffix=\"}\"\n        vertexTransform: `\n      mat4 matrix = mat4(\n        troikaBatchTexel(0.0),\n        troikaBatchTexel(1.0),\n        troikaBatchTexel(2.0),\n        troikaBatchTexel(3.0)\n      );\n      position.xyz = (matrix * vec4(position, 1.0)).xyz;\n    `\n    });\n    // Add the text shaders\n    batchMaterial = createTextDerivedMaterial(batchMaterial);\n    // Now make other changes to the derived text shader code\n    batchMaterial = (0,troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.createDerivedMaterial)(batchMaterial, {\n        chained: true,\n        uniforms: {\n            uTroikaIsOutline: {\n                value: false\n            }\n        },\n        customRewriter (shaders) {\n            // Convert some text shader uniforms to varyings\n            const varyingUniforms = [\n                \"uTroikaTotalBounds\",\n                \"uTroikaClipRect\",\n                \"uTroikaPositionOffset\",\n                \"uTroikaEdgeOffset\",\n                \"uTroikaBlurRadius\",\n                \"uTroikaStrokeWidth\",\n                \"uTroikaStrokeColor\",\n                \"uTroikaStrokeOpacity\",\n                \"uTroikaFillOpacity\",\n                \"uTroikaCurveRadius\",\n                \"diffuse\"\n            ];\n            varyingUniforms.forEach((uniformName)=>{\n                shaders = uniformToVarying(shaders, uniformName);\n            });\n            return shaders;\n        },\n        // language=GLSL\n        vertexDefs: `\n      uniform bool uTroikaIsOutline;\n      vec3 troikaFloatToColor(float v) {\n        return mod(floor(vec3(v / 65536.0, v / 256.0, v)), 256.0) / 256.0;\n      }\n    `,\n        // language=GLSL prefix=\"void main() {\" suffix=\"}\"\n        vertexTransform: `\n      uTroikaTotalBounds = troikaBatchTexel(4.0);\n      uTroikaClipRect = troikaBatchTexel(5.0);\n      \n      vec4 data = troikaBatchTexel(6.0);\n      diffuse = troikaFloatToColor(data.x);\n      uTroikaFillOpacity = data.y;\n      uTroikaCurveRadius = data.z;\n      \n      data = troikaBatchTexel(7.0);\n      if (uTroikaIsOutline) {\n        if (data == vec4(0.0)) { // degenerate if zero outline\n          position = vec3(0.0);\n        } else {\n          uTroikaPositionOffset = data.xy;\n          uTroikaEdgeOffset = data.z;\n          uTroikaBlurRadius = data.w;\n        }\n      } else {\n        uTroikaStrokeWidth = data.x;\n        uTroikaStrokeColor = troikaFloatToColor(data.y);\n        uTroikaStrokeOpacity = data.z;\n      }\n    `\n    });\n    batchMaterial.setMatrixTexture = (texture)=>{\n        batchMaterial.uniforms[texUniformName].value = texture;\n        batchMaterial.uniforms[texSizeUniformName].value.set(texture.image.width, texture.image.height);\n    };\n    return batchMaterial;\n}\n/**\n * Turn a uniform into a varying/writeable value.\n * - If the uniform was used in the fragment shader, it will become a varying in both shaders.\n * - If the uniform was only used in the vertex shader, it will become a writeable var.\n */ function uniformToVarying({ vertexShader, fragmentShader }, uniformName, varyingName = uniformName) {\n    const uniformRE = new RegExp(`uniform\\\\s+(bool|float|vec[234]|mat[34])\\\\s+${uniformName}\\\\b`);\n    let type;\n    let hadFragmentUniform = false;\n    fragmentShader = fragmentShader.replace(uniformRE, ($0, $1)=>{\n        hadFragmentUniform = true;\n        return `varying ${type = $1} ${varyingName}`;\n    });\n    let hadVertexUniform = false;\n    vertexShader = vertexShader.replace(uniformRE, (_, $1)=>{\n        hadVertexUniform = true;\n        return `${hadFragmentUniform ? \"varying\" : \"\"} ${type = $1} ${varyingName}`;\n    });\n    if (!hadVertexUniform) {\n        vertexShader = `${hadFragmentUniform ? \"varying\" : \"\"} ${type} ${varyingName};\\n${vertexShader}`;\n    }\n    return {\n        vertexShader,\n        fragmentShader\n    };\n}\n//=== Utility functions for dealing with carets and selection ranges ===//\n/**\n * @typedef {object} TextCaret\n * @property {number} x - x position of the caret\n * @property {number} y - y position of the caret's bottom\n * @property {number} height - height of the caret\n * @property {number} charIndex - the index in the original input string of this caret's target\n *   character; the caret will be for the position _before_ that character.\n */ /**\n * Given a local x/y coordinate in the text block plane, find the nearest caret position.\n * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo\n * @param {number} x\n * @param {number} y\n * @return {TextCaret | null}\n */ function getCaretAtPoint(textRenderInfo, x, y) {\n    let closestCaret = null;\n    const rows = groupCaretsByRow(textRenderInfo);\n    // Find nearest row by y first\n    let closestRow = null;\n    rows.forEach((row)=>{\n        if (!closestRow || Math.abs(y - (row.top + row.bottom) / 2) < Math.abs(y - (closestRow.top + closestRow.bottom) / 2)) {\n            closestRow = row;\n        }\n    });\n    // Then find closest caret by x within that row\n    closestRow.carets.forEach((caret)=>{\n        if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {\n            closestCaret = caret;\n        }\n    });\n    return closestCaret;\n}\nconst _rectsCache = new WeakMap();\n/**\n * Given start and end character indexes, return a list of rectangles covering all the\n * characters within that selection.\n * @param {TroikaTextRenderInfo} textRenderInfo\n * @param {number} start - index of the first char in the selection\n * @param {number} end - index of the first char after the selection\n * @return {Array<{left, top, right, bottom}> | null}\n */ function getSelectionRects(textRenderInfo, start, end) {\n    let rects;\n    if (textRenderInfo) {\n        // Check cache - textRenderInfo is frozen so it's safe to cache based on it\n        let prevResult = _rectsCache.get(textRenderInfo);\n        if (prevResult && prevResult.start === start && prevResult.end === end) {\n            return prevResult.rects;\n        }\n        const { caretPositions } = textRenderInfo;\n        // Normalize\n        if (end < start) {\n            const s = start;\n            start = end;\n            end = s;\n        }\n        start = Math.max(start, 0);\n        end = Math.min(end, caretPositions.length + 1);\n        // Build list of rects, expanding the current rect for all characters in a run and starting\n        // a new rect whenever reaching a new line or a new bidi direction\n        rects = [];\n        let currentRect = null;\n        for(let i = start; i < end; i++){\n            const x1 = caretPositions[i * 4];\n            const x2 = caretPositions[i * 4 + 1];\n            const left = Math.min(x1, x2);\n            const right = Math.max(x1, x2);\n            const bottom = caretPositions[i * 4 + 2];\n            const top = caretPositions[i * 4 + 3];\n            if (!currentRect || bottom !== currentRect.bottom || top !== currentRect.top || left > currentRect.right || right < currentRect.left) {\n                currentRect = {\n                    left: Infinity,\n                    right: -Infinity,\n                    bottom,\n                    top\n                };\n                rects.push(currentRect);\n            }\n            currentRect.left = Math.min(left, currentRect.left);\n            currentRect.right = Math.max(right, currentRect.right);\n        }\n        // Merge any overlapping rects, e.g. those formed by adjacent bidi runs\n        rects.sort((a, b)=>b.bottom - a.bottom || a.left - b.left);\n        for(let i = rects.length - 1; i-- > 0;){\n            const rectA = rects[i];\n            const rectB = rects[i + 1];\n            if (rectA.bottom === rectB.bottom && rectA.top === rectB.top && rectA.left <= rectB.right && rectA.right >= rectB.left) {\n                rectB.left = Math.min(rectB.left, rectA.left);\n                rectB.right = Math.max(rectB.right, rectA.right);\n                rects.splice(i, 1);\n            }\n        }\n        _rectsCache.set(textRenderInfo, {\n            start,\n            end,\n            rects\n        });\n    }\n    return rects;\n}\nconst _caretsByRowCache = new WeakMap();\n/**\n * Group a set of carets by row of text, caching the result. A single row of text may contain carets of\n * differing positions/heights if it has multiple fonts, and they may overlap slightly across rows, so this\n * uses an assumption of \"at least overlapping by half\" to put them in the same row.\n * @return Array<{bottom: number, top: number, carets: TextCaret[]}>\n */ function groupCaretsByRow(textRenderInfo) {\n    // textRenderInfo is frozen so it's safe to cache based on it\n    let rows = _caretsByRowCache.get(textRenderInfo);\n    if (!rows) {\n        rows = [];\n        const { caretPositions } = textRenderInfo;\n        let curRow;\n        const visitCaret = (x, bottom, top, charIndex)=>{\n            // new row if not overlapping by at least half\n            if (!curRow || top < (curRow.top + curRow.bottom) / 2) {\n                rows.push(curRow = {\n                    bottom,\n                    top,\n                    carets: []\n                });\n            }\n            // expand vertical limits if necessary\n            if (top > curRow.top) curRow.top = top;\n            if (bottom < curRow.bottom) curRow.bottom = bottom;\n            curRow.carets.push({\n                x,\n                y: bottom,\n                height: top - bottom,\n                charIndex\n            });\n        };\n        let i = 0;\n        for(; i < caretPositions.length; i += 4){\n            visitCaret(caretPositions[i], caretPositions[i + 2], caretPositions[i + 3], i / 4);\n        }\n        // Add one more caret after the final char\n        visitCaret(caretPositions[i - 3], caretPositions[i - 2], caretPositions[i - 1], i / 4);\n    }\n    _caretsByRowCache.set(textRenderInfo, rows);\n    return rows;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXRleHQvZGlzdC90cm9pa2EtdGhyZWUtdGV4dC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNlE7QUFDbk07QUFDckI7QUFDbkI7QUFDeUM7QUFFM0U7OztBQUdBLEdBQ0EsU0FBUzBCO0lBQWMsT0FBTyxLQUFhLElBQWdCQyxDQUFBQSxLQUFLQyxNQUFNLEdBQUNELElBQUcsR0FBRyxTQUFTRSxDQUFDO1FBQUUsSUFBSUMsSUFBRTtZQUFDQyxPQUFNLFNBQVNGLENBQUM7Z0JBQUUsSUFBSUcsSUFBRUYsRUFBRUcsSUFBSSxFQUFDQyxJQUFFLElBQUlDLFdBQVdOO2dCQUFHLElBQUcsVUFBUUcsRUFBRUksU0FBUyxDQUFDRixHQUFFLEdBQUUsSUFBRztvQkFBQyxJQUFJRyxJQUFFO29CQUFFTCxFQUFFTSxVQUFVLENBQUNKLEdBQUVHLElBQUdBLEtBQUcsR0FBRUwsRUFBRU0sVUFBVSxDQUFDSixHQUFFRyxJQUFHQSxLQUFHO29CQUFFLElBQUlFLElBQUVQLEVBQUVRLFFBQVEsQ0FBQ04sR0FBRUc7b0JBQUdBLEtBQUc7b0JBQUUsSUFBSSxJQUFJSSxJQUFFLEVBQUUsRUFBQ0MsSUFBRSxHQUFFQSxJQUFFSCxHQUFFRyxJQUFJO3dCQUFDLElBQUlDLElBQUVYLEVBQUVRLFFBQVEsQ0FBQ04sR0FBRUc7d0JBQUdBLEtBQUcsR0FBRUksRUFBRUcsSUFBSSxDQUFDZCxFQUFFZSxTQUFTLENBQUNYLEdBQUVTO29CQUFJO29CQUFDLE9BQU9GO2dCQUFDO2dCQUFDLE9BQU87b0JBQUNYLEVBQUVlLFNBQVMsQ0FBQ1gsR0FBRTtpQkFBRztZQUFBO1lBQUVXLFdBQVUsU0FBU2hCLENBQUMsRUFBQ0csQ0FBQztnQkFBRSxJQUFJRSxJQUFFSixFQUFFRyxJQUFJLEVBQUNJLElBQUVMO2dCQUFFRSxFQUFFWSxTQUFTLENBQUNqQixHQUFFRyxJQUFHQSxLQUFHO2dCQUFFLElBQUlPLElB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O1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFFO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBRTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBRTtZQUFJO1lBQUU7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUU7WUFBSTtZQUFJO1lBQUU7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUk7WUFBRTtZQUFJO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBSTtZQUFFO1lBQUU7WUFBRTtZQUFJO1lBQUU7WUFBRTtZQUFJO1lBQUk7WUFBSTtZQUFJ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LENBQUM3b0IsSUFBSSxFQUFFLEVBQUU2b0IsY0FBYyxDQUFDN29CLElBQUksRUFBRSxFQUFFQSxJQUFJO0lBQ3RGO0lBQ0E2cUMsa0JBQWtCeDBCLEdBQUcsQ0FBQ21yQixnQkFBZ0JvSTtJQUN0QyxPQUFPQTtBQUNUO0FBRXFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZG9nc3RldmUtbjY0Ly4vbm9kZV9tb2R1bGVzL3Ryb2lrYS10aHJlZS10ZXh0L2Rpc3QvdHJvaWthLXRocmVlLXRleHQuZXNtLmpzP2QwZGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dHVyZSwgTGluZWFyRmlsdGVyLCBDb2xvciwgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnksIFNwaGVyZSwgQm94MywgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLCBQbGFuZUdlb21ldHJ5LCBWZWN0b3IyLCBWZWN0b3I0LCBNYXRyaXgzLCBNZXNoLCBNZXNoQmFzaWNNYXRlcmlhbCwgRG91YmxlU2lkZSwgTWF0cml4NCwgVmVjdG9yMywgRGF0YVRleHR1cmUsIFJHQkFGb3JtYXQsIEZsb2F0VHlwZSwgRHluYW1pY0RyYXdVc2FnZSB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IGRlZmluZVdvcmtlck1vZHVsZSwgdGVybWluYXRlV29ya2VyIH0gZnJvbSAndHJvaWthLXdvcmtlci11dGlscyc7XG5pbXBvcnQgY3JlYXRlU0RGR2VuZXJhdG9yIGZyb20gJ3dlYmdsLXNkZi1nZW5lcmF0b3InO1xuaW1wb3J0IGJpZGlGYWN0b3J5IGZyb20gJ2JpZGktanMnO1xuaW1wb3J0IHsgY3JlYXRlRGVyaXZlZE1hdGVyaWFsLCB2b2lkTWFpblJlZ0V4cCB9IGZyb20gJ3Ryb2lrYS10aHJlZS11dGlscyc7XG5cbi8qIVxuQ3VzdG9tIGJ1aWxkIG9mIFR5cHIudHMgKGh0dHBzOi8vZ2l0aHViLmNvbS9mcmVkbGk3NC9UeXByLnRzKSBmb3IgdXNlIGluIFRyb2lrYSB0ZXh0IHJlbmRlcmluZy5cbk9yaWdpbmFsIE1JVCBsaWNlbnNlIGFwcGxpZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mcmVkbGk3NC9UeXByLnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiovXG5mdW5jdGlvbiB0eXByRmFjdG9yeSgpe3JldHVybiBcInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93JiYoc2VsZi53aW5kb3c9c2VsZiksZnVuY3Rpb24ocil7dmFyIGU9e3BhcnNlOmZ1bmN0aW9uKHIpe3ZhciB0PWUuX2JpbixhPW5ldyBVaW50OEFycmF5KHIpO2lmKFwidHRjZlwiPT10LnJlYWRBU0NJSShhLDAsNCkpe3ZhciBuPTQ7dC5yZWFkVXNob3J0KGEsbiksbis9Mix0LnJlYWRVc2hvcnQoYSxuKSxuKz0yO3ZhciBvPXQucmVhZFVpbnQoYSxuKTtuKz00O2Zvcih2YXIgcz1bXSxpPTA7aTxvO2krKyl7dmFyIGg9dC5yZWFkVWludChhLG4pO24rPTQscy5wdXNoKGUuX3JlYWRGb250KGEsaCkpO31yZXR1cm4gc31yZXR1cm4gW2UuX3JlYWRGb250KGEsMCldfSxfcmVhZEZvbnQ6ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10O2EucmVhZEZpeGVkKHIsdCksdCs9NDt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yO2Zvcih2YXIgcz1bXCJjbWFwXCIsXCJoZWFkXCIsXCJoaGVhXCIsXCJtYXhwXCIsXCJobXR4XCIsXCJuYW1lXCIsXCJPUy8yXCIsXCJwb3N0XCIsXCJsb2NhXCIsXCJnbHlmXCIsXCJrZXJuXCIsXCJDRkYgXCIsXCJHREVGXCIsXCJHUE9TXCIsXCJHU1VCXCIsXCJTVkcgXCJdLGk9e19kYXRhOnIsX29mZnNldDpufSxoPXt9LGQ9MDtkPG87ZCsrKXt2YXIgZj1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NCxhLnJlYWRVaW50KHIsdCksdCs9NDt2YXIgdT1hLnJlYWRVaW50KHIsdCk7dCs9NDt2YXIgbD1hLnJlYWRVaW50KHIsdCk7dCs9NCxoW2ZdPXtvZmZzZXQ6dSxsZW5ndGg6bH07fWZvcihkPTA7ZDxzLmxlbmd0aDtkKyspe3ZhciB2PXNbZF07aFt2XSYmKGlbdi50cmltKCldPWVbdi50cmltKCldLnBhcnNlKHIsaFt2XS5vZmZzZXQsaFt2XS5sZW5ndGgsaSkpO31yZXR1cm4gaX0sX3RhYk9mZnNldDpmdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPWUuX2JpbixvPW4ucmVhZFVzaG9ydChyLGErNCkscz1hKzEyLGk9MDtpPG87aSsrKXt2YXIgaD1uLnJlYWRBU0NJSShyLHMsNCk7cys9NCxuLnJlYWRVaW50KHIscykscys9NDt2YXIgZD1uLnJlYWRVaW50KHIscyk7aWYocys9NCxuLnJlYWRVaW50KHIscykscys9NCxoPT10KXJldHVybiBkfXJldHVybiAwfX07ZS5fYmluPXtyZWFkRml4ZWQ6ZnVuY3Rpb24ocixlKXtyZXR1cm4gKHJbZV08PDh8cltlKzFdKSsocltlKzJdPDw4fHJbZSszXSkvNjU1NDB9LHJlYWRGMmRvdDE0OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5yZWFkU2hvcnQocix0KS8xNjM4NH0scmVhZEludDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0SW50MzIodCl9LHJlYWRJbnQ4OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRJbnQ4KHQpfSxyZWFkU2hvcnQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldEludDE2KHQpfSxyZWFkVXNob3J0OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRVaW50MTYodCl9LHJlYWRVc2hvcnRzOmZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49W10sbz0wO288YTtvKyspbi5wdXNoKGUuX2Jpbi5yZWFkVXNob3J0KHIsdCsyKm8pKTtyZXR1cm4gbn0scmVhZFVpbnQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldFVpbnQzMih0KX0scmVhZFVpbnQ2NDpmdW5jdGlvbihyLHQpe3JldHVybiA0Mjk0OTY3Mjk2KmUuX2Jpbi5yZWFkVWludChyLHQpK2UuX2Jpbi5yZWFkVWludChyLHQrNCl9LHJlYWRBU0NJSTpmdW5jdGlvbihyLGUsdCl7Zm9yKHZhciBhPVwiXCIsbj0wO248dDtuKyspYSs9U3RyaW5nLmZyb21DaGFyQ29kZShyW2Urbl0pO3JldHVybiBhfSxyZWFkVW5pY29kZTpmdW5jdGlvbihyLGUsdCl7Zm9yKHZhciBhPVwiXCIsbj0wO248dDtuKyspe3ZhciBvPXJbZSsrXTw8OHxyW2UrK107YSs9U3RyaW5nLmZyb21DaGFyQ29kZShvKTt9cmV0dXJuIGF9LF90ZGVjOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5UZXh0RGVjb2Rlcj9uZXcgd2luZG93LlRleHREZWNvZGVyOm51bGwscmVhZFVURjg6ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2Jpbi5fdGRlYztyZXR1cm4gbiYmMD09dCYmYT09ci5sZW5ndGg/bi5kZWNvZGUocik6ZS5fYmluLnJlYWRBU0NJSShyLHQsYSl9LHJlYWRCeXRlczpmdW5jdGlvbihyLGUsdCl7Zm9yKHZhciBhPVtdLG49MDtuPHQ7bisrKWEucHVzaChyW2Urbl0pO3JldHVybiBhfSxyZWFkQVNDSUlBcnJheTpmdW5jdGlvbihyLGUsdCl7Zm9yKHZhciBhPVtdLG49MDtuPHQ7bisrKWEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHJbZStuXSkpO3JldHVybiBhfSxfdmlldzpmdW5jdGlvbihyKXtyZXR1cm4gci5fZGF0YVZpZXd8fChyLl9kYXRhVmlldz1yLmJ1ZmZlcj9uZXcgRGF0YVZpZXcoci5idWZmZXIsci5ieXRlT2Zmc2V0LHIuYnl0ZUxlbmd0aCk6bmV3IERhdGFWaWV3KG5ldyBVaW50OEFycmF5KHIpLmJ1ZmZlcikpfX0sZS5fbGN0Zj17fSxlLl9sY3RmLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4sbyl7dmFyIHM9ZS5fYmluLGk9e30saD10O3MucmVhZEZpeGVkKHIsdCksdCs9NDt2YXIgZD1zLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPXMucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHU9cy5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsaS5zY3JpcHRMaXN0PWUuX2xjdGYucmVhZFNjcmlwdExpc3QocixoK2QpLGkuZmVhdHVyZUxpc3Q9ZS5fbGN0Zi5yZWFkRmVhdHVyZUxpc3QocixoK2YpLGkubG9va3VwTGlzdD1lLl9sY3RmLnJlYWRMb29rdXBMaXN0KHIsaCt1LG8pLGl9LGUuX2xjdGYucmVhZExvb2t1cExpc3Q9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXQscz1bXSxpPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPTA7aDxpO2grKyl7dmFyIGQ9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZj1lLl9sY3RmLnJlYWRMb29rdXBUYWJsZShyLG8rZCxhKTtzLnB1c2goZik7fXJldHVybiBzfSxlLl9sY3RmLnJlYWRMb29rdXBUYWJsZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89dCxzPXt0YWJzOltdfTtzLmx0eXBlPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIscy5mbGFnPW4ucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIGk9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9cy5sdHlwZSxkPTA7ZDxpO2QrKyl7dmFyIGY9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdT1hKHIsaCxvK2Yscyk7cy50YWJzLnB1c2godSk7fXJldHVybiBzfSxlLl9sY3RmLm51bU9mT25lcz1mdW5jdGlvbihyKXtmb3IodmFyIGU9MCx0PTA7dDwzMjt0KyspMCE9KHI+Pj50JjEpJiZlKys7cmV0dXJuIGV9LGUuX2xjdGYucmVhZENsYXNzRGVmPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49W10sbz1hLnJlYWRVc2hvcnQocix0KTtpZih0Kz0yLDE9PW8pe3ZhciBzPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGk9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9MDtoPGk7aCsrKW4ucHVzaChzK2gpLG4ucHVzaChzK2gpLG4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9Mjt9aWYoMj09byl7dmFyIGQ9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IoaD0wO2g8ZDtoKyspbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yLG4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MixuLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7fXJldHVybiBufSxlLl9sY3RmLmdldEludGVydmFsPWZ1bmN0aW9uKHIsZSl7Zm9yKHZhciB0PTA7dDxyLmxlbmd0aDt0Kz0zKXt2YXIgYT1yW3RdLG49clt0KzFdO2lmKHJbdCsyXSxhPD1lJiZlPD1uKXJldHVybiB0fXJldHVybiAtMX0sZS5fbGN0Zi5yZWFkQ292ZXJhZ2U9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTtuLmZtdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3JldHVybiB0Kz0yLDE9PW4uZm10JiYobi50YWI9YS5yZWFkVXNob3J0cyhyLHQsbykpLDI9PW4uZm10JiYobi50YWI9YS5yZWFkVXNob3J0cyhyLHQsMypvKSksbn0sZS5fbGN0Zi5jb3ZlcmFnZUluZGV4PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ci50YWI7aWYoMT09ci5mbXQpcmV0dXJuIGEuaW5kZXhPZih0KTtpZigyPT1yLmZtdCl7dmFyIG49ZS5fbGN0Zi5nZXRJbnRlcnZhbChhLHQpO2lmKC0xIT1uKXJldHVybiBhW24rMl0rKHQtYVtuXSl9cmV0dXJuIC0xfSxlLl9sY3RmLnJlYWRGZWF0dXJlTGlzdD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz1bXSxzPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9YS5yZWFkQVNDSUkocix0LDQpO3QrPTQ7dmFyIGQ9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZj1lLl9sY3RmLnJlYWRGZWF0dXJlVGFibGUocixuK2QpO2YudGFnPWgudHJpbSgpLG8ucHVzaChmKTt9cmV0dXJuIG99LGUuX2xjdGYucmVhZEZlYXR1cmVUYWJsZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz17fSxzPWEucmVhZFVzaG9ydChyLHQpO3QrPTIscz4wJiYoby5mZWF0dXJlUGFyYW1zPW4rcyk7dmFyIGk9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnRhYj1bXTtmb3IodmFyIGg9MDtoPGk7aCsrKW8udGFiLnB1c2goYS5yZWFkVXNob3J0KHIsdCsyKmgpKTtyZXR1cm4gb30sZS5fbGN0Zi5yZWFkU2NyaXB0TGlzdD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz17fSxzPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9YS5yZWFkQVNDSUkocix0LDQpO3QrPTQ7dmFyIGQ9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvW2gudHJpbSgpXT1lLl9sY3RmLnJlYWRTY3JpcHRUYWJsZShyLG4rZCk7fXJldHVybiBvfSxlLl9sY3RmLnJlYWRTY3JpcHRUYWJsZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz17fSxzPWEucmVhZFVzaG9ydChyLHQpO3QrPTIscz4wJiYoby5kZWZhdWx0PWUuX2xjdGYucmVhZExhbmdTeXNUYWJsZShyLG4rcykpO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPTA7aDxpO2grKyl7dmFyIGQ9YS5yZWFkQVNDSUkocix0LDQpO3QrPTQ7dmFyIGY9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvW2QudHJpbSgpXT1lLl9sY3RmLnJlYWRMYW5nU3lzVGFibGUocixuK2YpO31yZXR1cm4gb30sZS5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307YS5yZWFkVXNob3J0KHIsdCksdCs9MixuLnJlcUZlYXR1cmU9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MixuLmZlYXR1cmVzPWEucmVhZFVzaG9ydHMocix0LG8pLG59LGUuQ0ZGPXt9LGUuQ0ZGLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47KHI9bmV3IFVpbnQ4QXJyYXkoci5idWZmZXIsdCxhKSlbdD0wXSxyWysrdF0sclsrK3RdLHJbKyt0XSx0Kys7dmFyIG89W107dD1lLkNGRi5yZWFkSW5kZXgocix0LG8pO2Zvcih2YXIgcz1bXSxpPTA7aTxvLmxlbmd0aC0xO2krKylzLnB1c2gobi5yZWFkQVNDSUkocix0K29baV0sb1tpKzFdLW9baV0pKTt0Kz1vW28ubGVuZ3RoLTFdO3ZhciBoPVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCxoKTt2YXIgZD1bXTtmb3IoaT0wO2k8aC5sZW5ndGgtMTtpKyspZC5wdXNoKGUuQ0ZGLnJlYWREaWN0KHIsdCtoW2ldLHQraFtpKzFdKSk7dCs9aFtoLmxlbmd0aC0xXTt2YXIgZj1kWzBdLHU9W107dD1lLkNGRi5yZWFkSW5kZXgocix0LHUpO3ZhciBsPVtdO2ZvcihpPTA7aTx1Lmxlbmd0aC0xO2krKylsLnB1c2gobi5yZWFkQVNDSUkocix0K3VbaV0sdVtpKzFdLXVbaV0pKTtpZih0Kz11W3UubGVuZ3RoLTFdLGUuQ0ZGLnJlYWRTdWJycyhyLHQsZiksZi5DaGFyU3RyaW5ncyl7dD1mLkNoYXJTdHJpbmdzO3U9W107dD1lLkNGRi5yZWFkSW5kZXgocix0LHUpO3ZhciB2PVtdO2ZvcihpPTA7aTx1Lmxlbmd0aC0xO2krKyl2LnB1c2gobi5yZWFkQnl0ZXMocix0K3VbaV0sdVtpKzFdLXVbaV0pKTtmLkNoYXJTdHJpbmdzPXY7fWlmKGYuUk9TKXt0PWYuRkRBcnJheTt2YXIgYz1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsYyksZi5GREFycmF5PVtdO2ZvcihpPTA7aTxjLmxlbmd0aC0xO2krKyl7dmFyIHA9ZS5DRkYucmVhZERpY3Qocix0K2NbaV0sdCtjW2krMV0pO2UuQ0ZGLl9yZWFkRkRpY3QocixwLGwpLGYuRkRBcnJheS5wdXNoKHApO310Kz1jW2MubGVuZ3RoLTFdLHQ9Zi5GRFNlbGVjdCxmLkZEU2VsZWN0PVtdO3ZhciBVPXJbdF07aWYodCsrLDMhPVUpdGhyb3cgVTt2YXIgZz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2ZvcihpPTA7aTxnKzE7aSsrKWYuRkRTZWxlY3QucHVzaChuLnJlYWRVc2hvcnQocix0KSxyW3QrMl0pLHQrPTM7fXJldHVybiBmLkVuY29kaW5nJiYoZi5FbmNvZGluZz1lLkNGRi5yZWFkRW5jb2RpbmcocixmLkVuY29kaW5nLGYuQ2hhclN0cmluZ3MubGVuZ3RoKSksZi5jaGFyc2V0JiYoZi5jaGFyc2V0PWUuQ0ZGLnJlYWRDaGFyc2V0KHIsZi5jaGFyc2V0LGYuQ2hhclN0cmluZ3MubGVuZ3RoKSksZS5DRkYuX3JlYWRGRGljdChyLGYsbCksZn0sZS5DRkYuX3JlYWRGRGljdD1mdW5jdGlvbihyLHQsYSl7dmFyIG47Zm9yKHZhciBvIGluIHQuUHJpdmF0ZSYmKG49dC5Qcml2YXRlWzFdLHQuUHJpdmF0ZT1lLkNGRi5yZWFkRGljdChyLG4sbit0LlByaXZhdGVbMF0pLHQuUHJpdmF0ZS5TdWJycyYmZS5DRkYucmVhZFN1YnJzKHIsbit0LlByaXZhdGUuU3VicnMsdC5Qcml2YXRlKSksdCktMSE9W1wiRmFtaWx5TmFtZVwiLFwiRm9udE5hbWVcIixcIkZ1bGxOYW1lXCIsXCJOb3RpY2VcIixcInZlcnNpb25cIixcIkNvcHlyaWdodFwiXS5pbmRleE9mKG8pJiYodFtvXT1hW3Rbb10tNDI2KzM1XSk7fSxlLkNGRi5yZWFkU3VicnM9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCxvKTt2YXIgcyxpPW8ubGVuZ3RoO3M9aTwxMjQwPzEwNzppPDMzOTAwPzExMzE6MzI3NjgsYS5CaWFzPXMsYS5TdWJycz1bXTtmb3IodmFyIGg9MDtoPG8ubGVuZ3RoLTE7aCsrKWEuU3VicnMucHVzaChuLnJlYWRCeXRlcyhyLHQrb1toXSxvW2grMV0tb1toXSkpO30sZS5DRkYudGFibGVTRT1bMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDkxLDkyLDkzLDk0LDk1LDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsOTYsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTAzLDEwNCwxMDUsMTA2LDEwNywxMDgsMTA5LDExMCwwLDExMSwxMTIsMTEzLDExNCwwLDExNSwxMTYsMTE3LDExOCwxMTksMTIwLDEyMSwxMjIsMCwxMjMsMCwxMjQsMTI1LDEyNiwxMjcsMTI4LDEyOSwxMzAsMTMxLDAsMTMyLDEzMywwLDEzNCwxMzUsMTM2LDEzNywwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEzOCwwLDEzOSwwLDAsMCwwLDE0MCwxNDEsMTQyLDE0MywwLDAsMCwwLDAsMTQ0LDAsMCwwLDE0NSwwLDAsMTQ2LDE0NywxNDgsMTQ5LDAsMCwwLDBdLGUuQ0ZGLmdseXBoQnlVbmljb2RlPWZ1bmN0aW9uKHIsZSl7Zm9yKHZhciB0PTA7dDxyLmNoYXJzZXQubGVuZ3RoO3QrKylpZihyLmNoYXJzZXRbdF09PWUpcmV0dXJuIHQ7cmV0dXJuIC0xfSxlLkNGRi5nbHlwaEJ5U0U9ZnVuY3Rpb24ocix0KXtyZXR1cm4gdDwwfHx0PjI1NT8tMTplLkNGRi5nbHlwaEJ5VW5pY29kZShyLGUuQ0ZGLnRhYmxlU0VbdF0pfSxlLkNGRi5yZWFkRW5jb2Rpbmc9ZnVuY3Rpb24ocix0LGEpe2UuX2Jpbjt2YXIgbj1bXCIubm90ZGVmXCJdLG89clt0XTtpZih0KyssMCE9byl0aHJvdyBcImVycm9yOiB1bmtub3duIGVuY29kaW5nIGZvcm1hdDogXCIrbzt2YXIgcz1yW3RdO3QrKztmb3IodmFyIGk9MDtpPHM7aSsrKW4ucHVzaChyW3QraV0pO3JldHVybiBufSxlLkNGRi5yZWFkQ2hhcnNldD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89W1wiLm5vdGRlZlwiXSxzPXJbdF07aWYodCsrLDA9PXMpZm9yKHZhciBpPTA7aTxhO2krKyl7dmFyIGg9bi5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnB1c2goaCk7fWVsc2Uge2lmKDEhPXMmJjIhPXMpdGhyb3cgXCJlcnJvcjogZm9ybWF0OiBcIitzO2Zvcig7by5sZW5ndGg8YTspe2g9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZD0wOzE9PXM/KGQ9clt0XSx0KyspOihkPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIpO2ZvcihpPTA7aTw9ZDtpKyspby5wdXNoKGgpLGgrKzt9fXJldHVybiBvfSxlLkNGRi5yZWFkSW5kZXg9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPW4ucmVhZFVzaG9ydChyLHQpKzEscz1yW3QrPTJdO2lmKHQrKywxPT1zKWZvcih2YXIgaT0wO2k8bztpKyspYS5wdXNoKHJbdCtpXSk7ZWxzZSBpZigyPT1zKWZvcihpPTA7aTxvO2krKylhLnB1c2gobi5yZWFkVXNob3J0KHIsdCsyKmkpKTtlbHNlIGlmKDM9PXMpZm9yKGk9MDtpPG87aSsrKWEucHVzaCgxNjc3NzIxNSZuLnJlYWRVaW50KHIsdCszKmktMSkpO2Vsc2UgaWYoMSE9byl0aHJvdyBcInVuc3VwcG9ydGVkIG9mZnNldCBzaXplOiBcIitzK1wiLCBjb3VudDogXCIrbztyZXR1cm4gKHQrPW8qcyktMX0sZS5DRkYuZ2V0Q2hhclN0cmluZz1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89clt0XSxzPXJbdCsxXTtyW3QrMl0sclt0KzNdLHJbdCs0XTt2YXIgaT0xLGg9bnVsbCxkPW51bGw7bzw9MjAmJihoPW8saT0xKSwxMj09byYmKGg9MTAwKm8rcyxpPTIpLDIxPD1vJiZvPD0yNyYmKGg9byxpPTEpLDI4PT1vJiYoZD1uLnJlYWRTaG9ydChyLHQrMSksaT0zKSwyOTw9byYmbzw9MzEmJihoPW8saT0xKSwzMjw9byYmbzw9MjQ2JiYoZD1vLTEzOSxpPTEpLDI0Nzw9byYmbzw9MjUwJiYoZD0yNTYqKG8tMjQ3KStzKzEwOCxpPTIpLDI1MTw9byYmbzw9MjU0JiYoZD0yNTYqLShvLTI1MSktcy0xMDgsaT0yKSwyNTU9PW8mJihkPW4ucmVhZEludChyLHQrMSkvNjU1MzUsaT01KSxhLnZhbD1udWxsIT1kP2Q6XCJvXCIraCxhLnNpemU9aTt9LGUuQ0ZGLnJlYWRDaGFyU3RyaW5nPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49dCthLG89ZS5fYmluLHM9W107dDxuOyl7dmFyIGk9clt0XSxoPXJbdCsxXTtyW3QrMl0sclt0KzNdLHJbdCs0XTt2YXIgZD0xLGY9bnVsbCx1PW51bGw7aTw9MjAmJihmPWksZD0xKSwxMj09aSYmKGY9MTAwKmkraCxkPTIpLDE5IT1pJiYyMCE9aXx8KGY9aSxkPTIpLDIxPD1pJiZpPD0yNyYmKGY9aSxkPTEpLDI4PT1pJiYodT1vLnJlYWRTaG9ydChyLHQrMSksZD0zKSwyOTw9aSYmaTw9MzEmJihmPWksZD0xKSwzMjw9aSYmaTw9MjQ2JiYodT1pLTEzOSxkPTEpLDI0Nzw9aSYmaTw9MjUwJiYodT0yNTYqKGktMjQ3KStoKzEwOCxkPTIpLDI1MTw9aSYmaTw9MjU0JiYodT0yNTYqLShpLTI1MSktaC0xMDgsZD0yKSwyNTU9PWkmJih1PW8ucmVhZEludChyLHQrMSkvNjU1MzUsZD01KSxzLnB1c2gobnVsbCE9dT91Olwib1wiK2YpLHQrPWQ7fXJldHVybiBzfSxlLkNGRi5yZWFkRGljdD1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPWUuX2JpbixvPXt9LHM9W107dDxhOyl7dmFyIGk9clt0XSxoPXJbdCsxXTtyW3QrMl0sclt0KzNdLHJbdCs0XTt2YXIgZD0xLGY9bnVsbCx1PW51bGw7aWYoMjg9PWkmJih1PW4ucmVhZFNob3J0KHIsdCsxKSxkPTMpLDI5PT1pJiYodT1uLnJlYWRJbnQocix0KzEpLGQ9NSksMzI8PWkmJmk8PTI0NiYmKHU9aS0xMzksZD0xKSwyNDc8PWkmJmk8PTI1MCYmKHU9MjU2KihpLTI0NykraCsxMDgsZD0yKSwyNTE8PWkmJmk8PTI1NCYmKHU9MjU2Ki0oaS0yNTEpLWgtMTA4LGQ9MiksMjU1PT1pKXRocm93IHU9bi5yZWFkSW50KHIsdCsxKS82NTUzNSxkPTUsXCJ1bmtub3duIG51bWJlclwiO2lmKDMwPT1pKXt2YXIgbD1bXTtmb3IoZD0xOzspe3ZhciB2PXJbdCtkXTtkKys7dmFyIGM9dj4+NCxwPTE1JnY7aWYoMTUhPWMmJmwucHVzaChjKSwxNSE9cCYmbC5wdXNoKHApLDE1PT1wKWJyZWFrfWZvcih2YXIgVT1cIlwiLGc9WzAsMSwyLDMsNCw1LDYsNyw4LDksXCIuXCIsXCJlXCIsXCJlLVwiLFwicmVzZXJ2ZWRcIixcIi1cIixcImVuZE9mTnVtYmVyXCJdLFM9MDtTPGwubGVuZ3RoO1MrKylVKz1nW2xbU11dO3U9cGFyc2VGbG9hdChVKTt9aWYoaTw9MjEpaWYoZj1bXCJ2ZXJzaW9uXCIsXCJOb3RpY2VcIixcIkZ1bGxOYW1lXCIsXCJGYW1pbHlOYW1lXCIsXCJXZWlnaHRcIixcIkZvbnRCQm94XCIsXCJCbHVlVmFsdWVzXCIsXCJPdGhlckJsdWVzXCIsXCJGYW1pbHlCbHVlc1wiLFwiRmFtaWx5T3RoZXJCbHVlc1wiLFwiU3RkSFdcIixcIlN0ZFZXXCIsXCJlc2NhcGVcIixcIlVuaXF1ZUlEXCIsXCJYVUlEXCIsXCJjaGFyc2V0XCIsXCJFbmNvZGluZ1wiLFwiQ2hhclN0cmluZ3NcIixcIlByaXZhdGVcIixcIlN1YnJzXCIsXCJkZWZhdWx0V2lkdGhYXCIsXCJub21pbmFsV2lkdGhYXCJdW2ldLGQ9MSwxMj09aSlmPVtcIkNvcHlyaWdodFwiLFwiaXNGaXhlZFBpdGNoXCIsXCJJdGFsaWNBbmdsZVwiLFwiVW5kZXJsaW5lUG9zaXRpb25cIixcIlVuZGVybGluZVRoaWNrbmVzc1wiLFwiUGFpbnRUeXBlXCIsXCJDaGFyc3RyaW5nVHlwZVwiLFwiRm9udE1hdHJpeFwiLFwiU3Ryb2tlV2lkdGhcIixcIkJsdWVTY2FsZVwiLFwiQmx1ZVNoaWZ0XCIsXCJCbHVlRnV6elwiLFwiU3RlbVNuYXBIXCIsXCJTdGVtU25hcFZcIixcIkZvcmNlQm9sZFwiLDAsMCxcIkxhbmd1YWdlR3JvdXBcIixcIkV4cGFuc2lvbkZhY3RvclwiLFwiaW5pdGlhbFJhbmRvbVNlZWRcIixcIlN5bnRoZXRpY0Jhc2VcIixcIlBvc3RTY3JpcHRcIixcIkJhc2VGb250TmFtZVwiLFwiQmFzZUZvbnRCbGVuZFwiLDAsMCwwLDAsMCwwLFwiUk9TXCIsXCJDSURGb250VmVyc2lvblwiLFwiQ0lERm9udFJldmlzaW9uXCIsXCJDSURGb250VHlwZVwiLFwiQ0lEQ291bnRcIixcIlVJREJhc2VcIixcIkZEQXJyYXlcIixcIkZEU2VsZWN0XCIsXCJGb250TmFtZVwiXVtoXSxkPTI7bnVsbCE9Zj8ob1tmXT0xPT1zLmxlbmd0aD9zWzBdOnMscz1bXSk6cy5wdXNoKHUpLHQrPWQ7fXJldHVybiBvfSxlLmNtYXA9e30sZS5jbWFwLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXtyPW5ldyBVaW50OEFycmF5KHIuYnVmZmVyLHQsYSksdD0wO3ZhciBuPWUuX2JpbixvPXt9O24ucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIHM9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgaT1bXTtvLnRhYmxlcz1bXTtmb3IodmFyIGg9MDtoPHM7aCsrKXt2YXIgZD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHU9bi5yZWFkVWludChyLHQpO3QrPTQ7dmFyIGw9XCJwXCIrZCtcImVcIitmLHY9aS5pbmRleE9mKHUpO2lmKC0xPT12KXt2YXIgYzt2PW8udGFibGVzLmxlbmd0aCxpLnB1c2godSk7dmFyIHA9bi5yZWFkVXNob3J0KHIsdSk7MD09cD9jPWUuY21hcC5wYXJzZTAocix1KTo0PT1wP2M9ZS5jbWFwLnBhcnNlNChyLHUpOjY9PXA/Yz1lLmNtYXAucGFyc2U2KHIsdSk6MTI9PXA/Yz1lLmNtYXAucGFyc2UxMihyLHUpOmNvbnNvbGUuZGVidWcoXCJ1bmtub3duIGZvcm1hdDogXCIrcCxkLGYsdSksby50YWJsZXMucHVzaChjKTt9aWYobnVsbCE9b1tsXSl0aHJvdyBcIm11bHRpcGxlIHRhYmxlcyBmb3Igb25lIHBsYXRmb3JtK2VuY29kaW5nXCI7b1tsXT12O31yZXR1cm4gb30sZS5jbWFwLnBhcnNlMD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4ubWFwPVtdO2Zvcih2YXIgcz0wO3M8by02O3MrKyluLm1hcC5wdXNoKHJbdCtzXSk7cmV0dXJuIG59LGUuY21hcC5wYXJzZTQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e307by5mb3JtYXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgcz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIGk9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgaD1pLzI7by5zZWFyY2hSYW5nZT1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8uZW50cnlTZWxlY3Rvcj1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ucmFuZ2VTaGlmdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8uZW5kQ291bnQ9YS5yZWFkVXNob3J0cyhyLHQsaCksdCs9MipoLHQrPTIsby5zdGFydENvdW50PWEucmVhZFVzaG9ydHMocix0LGgpLHQrPTIqaCxvLmlkRGVsdGE9W107Zm9yKHZhciBkPTA7ZDxoO2QrKylvLmlkRGVsdGEucHVzaChhLnJlYWRTaG9ydChyLHQpKSx0Kz0yO2ZvcihvLmlkUmFuZ2VPZmZzZXQ9YS5yZWFkVXNob3J0cyhyLHQsaCksdCs9MipoLG8uZ2x5cGhJZEFycmF5PVtdO3Q8bitzOylvLmdseXBoSWRBcnJheS5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO3JldHVybiBvfSxlLmNtYXAucGFyc2U2PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mb3JtYXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5maXJzdENvZGU9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG4uZ2x5cGhJZEFycmF5PVtdO2Zvcih2YXIgcz0wO3M8bztzKyspbi5nbHlwaElkQXJyYXkucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MjtyZXR1cm4gbn0sZS5jbWFwLnBhcnNlMTI9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTtuLmZvcm1hdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLHQrPTIsYS5yZWFkVWludChyLHQpLHQrPTQsYS5yZWFkVWludChyLHQpLHQrPTQ7dmFyIG89YS5yZWFkVWludChyLHQpO3QrPTQsbi5ncm91cHM9W107Zm9yKHZhciBzPTA7czxvO3MrKyl7dmFyIGk9dCsxMipzLGg9YS5yZWFkVWludChyLGkrMCksZD1hLnJlYWRVaW50KHIsaSs0KSxmPWEucmVhZFVpbnQocixpKzgpO24uZ3JvdXBzLnB1c2goW2gsZCxmXSk7fXJldHVybiBufSxlLmdseWY9e30sZS5nbHlmLnBhcnNlPWZ1bmN0aW9uKHIsZSx0LGEpe2Zvcih2YXIgbj1bXSxvPTA7bzxhLm1heHAubnVtR2x5cGhzO28rKyluLnB1c2gobnVsbCk7cmV0dXJuIG59LGUuZ2x5Zi5fcGFyc2VHbHlmPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49ci5fZGF0YSxvPWUuX3RhYk9mZnNldChuLFwiZ2x5ZlwiLHIuX29mZnNldCkrci5sb2NhW3RdO2lmKHIubG9jYVt0XT09ci5sb2NhW3QrMV0pcmV0dXJuIG51bGw7dmFyIHM9e307aWYocy5ub2M9YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueE1pbj1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy55TWluPWEucmVhZFNob3J0KG4sbyksbys9MixzLnhNYXg9YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueU1heD1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy54TWluPj1zLnhNYXh8fHMueU1pbj49cy55TWF4KXJldHVybiBudWxsO2lmKHMubm9jPjApe3MuZW5kUHRzPVtdO2Zvcih2YXIgaT0wO2k8cy5ub2M7aSsrKXMuZW5kUHRzLnB1c2goYS5yZWFkVXNob3J0KG4sbykpLG8rPTI7dmFyIGg9YS5yZWFkVXNob3J0KG4sbyk7aWYobys9MixuLmxlbmd0aC1vPGgpcmV0dXJuIG51bGw7cy5pbnN0cnVjdGlvbnM9YS5yZWFkQnl0ZXMobixvLGgpLG8rPWg7dmFyIGQ9cy5lbmRQdHNbcy5ub2MtMV0rMTtzLmZsYWdzPVtdO2ZvcihpPTA7aTxkO2krKyl7dmFyIGY9bltvXTtpZihvKysscy5mbGFncy5wdXNoKGYpLDAhPSg4JmYpKXt2YXIgdT1uW29dO28rKztmb3IodmFyIGw9MDtsPHU7bCsrKXMuZmxhZ3MucHVzaChmKSxpKys7fX1zLnhzPVtdO2ZvcihpPTA7aTxkO2krKyl7dmFyIHY9MCE9KDImcy5mbGFnc1tpXSksYz0wIT0oMTYmcy5mbGFnc1tpXSk7dj8ocy54cy5wdXNoKGM/bltvXTotbltvXSksbysrKTpjP3MueHMucHVzaCgwKToocy54cy5wdXNoKGEucmVhZFNob3J0KG4sbykpLG8rPTIpO31zLnlzPVtdO2ZvcihpPTA7aTxkO2krKyl7dj0wIT0oNCZzLmZsYWdzW2ldKSxjPTAhPSgzMiZzLmZsYWdzW2ldKTt2PyhzLnlzLnB1c2goYz9uW29dOi1uW29dKSxvKyspOmM/cy55cy5wdXNoKDApOihzLnlzLnB1c2goYS5yZWFkU2hvcnQobixvKSksbys9Mik7fXZhciBwPTAsVT0wO2ZvcihpPTA7aTxkO2krKylwKz1zLnhzW2ldLFUrPXMueXNbaV0scy54c1tpXT1wLHMueXNbaV09VTt9ZWxzZSB7dmFyIGc7cy5wYXJ0cz1bXTtkb3tnPWEucmVhZFVzaG9ydChuLG8pLG8rPTI7dmFyIFM9e206e2E6MSxiOjAsYzowLGQ6MSx0eDowLHR5OjB9LHAxOi0xLHAyOi0xfTtpZihzLnBhcnRzLnB1c2goUyksUy5nbHlwaEluZGV4PWEucmVhZFVzaG9ydChuLG8pLG8rPTIsMSZnKXt2YXIgbT1hLnJlYWRTaG9ydChuLG8pO28rPTI7dmFyIGI9YS5yZWFkU2hvcnQobixvKTtvKz0yO31lbHNlIHttPWEucmVhZEludDgobixvKTtvKys7Yj1hLnJlYWRJbnQ4KG4sbyk7bysrO30yJmc/KFMubS50eD1tLFMubS50eT1iKTooUy5wMT1tLFMucDI9YiksOCZnPyhTLm0uYT1TLm0uZD1hLnJlYWRGMmRvdDE0KG4sbyksbys9Mik6NjQmZz8oUy5tLmE9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIsUy5tLmQ9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIpOjEyOCZnJiYoUy5tLmE9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIsUy5tLmI9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIsUy5tLmM9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIsUy5tLmQ9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIpO313aGlsZSgzMiZnKTtpZigyNTYmZyl7dmFyIHk9YS5yZWFkVXNob3J0KG4sbyk7bys9MixzLmluc3RyPVtdO2ZvcihpPTA7aTx5O2krKylzLmluc3RyLnB1c2gobltvXSksbysrO319cmV0dXJuIHN9LGUuR0RFRj17fSxlLkdERUYucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7dmFyIG89dDt0Kz00O3ZhciBzPWUuX2Jpbi5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHtnbHlwaENsYXNzRGVmOjA9PT1zP251bGw6ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixvK3MpfX0sZS5HUE9TPXt9LGUuR1BPUy5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXtyZXR1cm4gZS5fbGN0Zi5wYXJzZShyLHQsYSxuLGUuR1BPUy5zdWJ0KX0sZS5HUE9TLnN1YnQ9ZnVuY3Rpb24ocix0LGEsbil7dmFyIG89ZS5fYmluLHM9YSxpPXt9O2lmKGkuZm10PW8ucmVhZFVzaG9ydChyLGEpLGErPTIsMT09dHx8Mj09dHx8Mz09dHx8Nz09dHx8OD09dCYmaS5mbXQ8PTIpe3ZhciBoPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5jb3ZlcmFnZT1lLl9sY3RmLnJlYWRDb3ZlcmFnZShyLGgrcyk7fWlmKDE9PXQmJjE9PWkuZm10KXt2YXIgZD1vLnJlYWRVc2hvcnQocixhKTthKz0yLDAhPWQmJihpLnBvcz1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIsYSxkKSk7fWVsc2UgaWYoMj09dCYmaS5mbXQ+PTEmJmkuZm10PD0yKXtkPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIGY9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgdT1lLl9sY3RmLm51bU9mT25lcyhkKSxsPWUuX2xjdGYubnVtT2ZPbmVzKGYpO2lmKDE9PWkuZm10KXtpLnBhaXJzZXRzPVtdO3ZhciB2PW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7Zm9yKHZhciBjPTA7Yzx2O2MrKyl7dmFyIHA9cytvLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBVPW8ucmVhZFVzaG9ydChyLHApO3ArPTI7Zm9yKHZhciBnPVtdLFM9MDtTPFU7UysrKXt2YXIgbT1vLnJlYWRVc2hvcnQocixwKTtwKz0yLDAhPWQmJihQPWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixwLGQpLHArPTIqdSksMCE9ZiYmKHg9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLHAsZikscCs9MipsKSxnLnB1c2goe2dpZDI6bSx2YWwxOlAsdmFsMjp4fSk7fWkucGFpcnNldHMucHVzaChnKTt9fWlmKDI9PWkuZm10KXt2YXIgYj1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciB5PW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIEY9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgQz1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuY2xhc3NEZWYxPWUuX2xjdGYucmVhZENsYXNzRGVmKHIscytiKSxpLmNsYXNzRGVmMj1lLl9sY3RmLnJlYWRDbGFzc0RlZihyLHMreSksaS5tYXRyaXg9W107Zm9yKGM9MDtjPEY7YysrKXt2YXIgXz1bXTtmb3IoUz0wO1M8QztTKyspe3ZhciBQPW51bGwseD1udWxsOzAhPWQmJihQPWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixhLGQpLGErPTIqdSksMCE9ZiYmKHg9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLGEsZiksYSs9MipsKSxfLnB1c2goe3ZhbDE6UCx2YWwyOnh9KTt9aS5tYXRyaXgucHVzaChfKTt9fX1lbHNlIGlmKDQ9PXQmJjE9PWkuZm10KWkubWFya0NvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIsby5yZWFkVXNob3J0KHIsYSkrcyksaS5iYXNlQ292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixvLnJlYWRVc2hvcnQocixhKzIpK3MpLGkubWFya0NsYXNzQ291bnQ9by5yZWFkVXNob3J0KHIsYSs0KSxpLm1hcmtBcnJheT1lLkdQT1MucmVhZE1hcmtBcnJheShyLG8ucmVhZFVzaG9ydChyLGErNikrcyksaS5iYXNlQXJyYXk9ZS5HUE9TLnJlYWRCYXNlQXJyYXkocixvLnJlYWRVc2hvcnQocixhKzgpK3MsaS5tYXJrQ2xhc3NDb3VudCk7ZWxzZSBpZig2PT10JiYxPT1pLmZtdClpLm1hcmsxQ292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixvLnJlYWRVc2hvcnQocixhKStzKSxpLm1hcmsyQ292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixvLnJlYWRVc2hvcnQocixhKzIpK3MpLGkubWFya0NsYXNzQ291bnQ9by5yZWFkVXNob3J0KHIsYSs0KSxpLm1hcmsxQXJyYXk9ZS5HUE9TLnJlYWRNYXJrQXJyYXkocixvLnJlYWRVc2hvcnQocixhKzYpK3MpLGkubWFyazJBcnJheT1lLkdQT1MucmVhZEJhc2VBcnJheShyLG8ucmVhZFVzaG9ydChyLGErOCkrcyxpLm1hcmtDbGFzc0NvdW50KTtlbHNlIHtpZig5PT10JiYxPT1pLmZtdCl7dmFyIEk9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgdz1vLnJlYWRVaW50KHIsYSk7aWYoYSs9NCw5PT1uLmx0eXBlKW4ubHR5cGU9STtlbHNlIGlmKG4ubHR5cGUhPUkpdGhyb3cgXCJpbnZhbGlkIGV4dGVuc2lvbiBzdWJzdGl0dXRpb25cIjtyZXR1cm4gZS5HUE9TLnN1YnQocixuLmx0eXBlLHMrdyl9Y29uc29sZS5kZWJ1ZyhcInVuc3VwcG9ydGVkIEdQT1MgdGFibGUgTG9va3VwVHlwZVwiLHQsXCJmb3JtYXRcIixpLmZtdCk7fXJldHVybiBpfSxlLkdQT1MucmVhZFZhbHVlUmVjb3JkPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1bXTtyZXR1cm4gby5wdXNoKDEmYT9uLnJlYWRTaG9ydChyLHQpOjApLHQrPTEmYT8yOjAsby5wdXNoKDImYT9uLnJlYWRTaG9ydChyLHQpOjApLHQrPTImYT8yOjAsby5wdXNoKDQmYT9uLnJlYWRTaG9ydChyLHQpOjApLHQrPTQmYT8yOjAsby5wdXNoKDgmYT9uLnJlYWRTaG9ydChyLHQpOjApLHQrPTgmYT8yOjAsb30sZS5HUE9TLnJlYWRCYXNlQXJyYXk9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPVtdLHM9dCxpPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPTA7aDxpO2grKyl7Zm9yKHZhciBkPVtdLGY9MDtmPGE7ZisrKWQucHVzaChlLkdQT1MucmVhZEFuY2hvclJlY29yZChyLHMrbi5yZWFkVXNob3J0KHIsdCkpKSx0Kz0yO28ucHVzaChkKTt9cmV0dXJuIG99LGUuR1BPUy5yZWFkTWFya0FycmF5PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49W10sbz10LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1lLkdQT1MucmVhZEFuY2hvclJlY29yZChyLGEucmVhZFVzaG9ydChyLHQrMikrbyk7aC5tYXJrQ2xhc3M9YS5yZWFkVXNob3J0KHIsdCksbi5wdXNoKGgpLHQrPTQ7fXJldHVybiBufSxlLkdQT1MucmVhZEFuY2hvclJlY29yZD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O3JldHVybiBuLmZtdD1hLnJlYWRVc2hvcnQocix0KSxuLng9YS5yZWFkU2hvcnQocix0KzIpLG4ueT1hLnJlYWRTaG9ydChyLHQrNCksbn0sZS5HU1VCPXt9LGUuR1NVQi5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXtyZXR1cm4gZS5fbGN0Zi5wYXJzZShyLHQsYSxuLGUuR1NVQi5zdWJ0KX0sZS5HU1VCLnN1YnQ9ZnVuY3Rpb24ocix0LGEsbil7dmFyIG89ZS5fYmluLHM9YSxpPXt9O2lmKGkuZm10PW8ucmVhZFVzaG9ydChyLGEpLGErPTIsMSE9dCYmMiE9dCYmNCE9dCYmNSE9dCYmNiE9dClyZXR1cm4gbnVsbDtpZigxPT10fHwyPT10fHw0PT10fHw1PT10JiZpLmZtdDw9Mnx8Nj09dCYmaS5mbXQ8PTIpe3ZhciBoPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5jb3ZlcmFnZT1lLl9sY3RmLnJlYWRDb3ZlcmFnZShyLHMraCk7fWlmKDE9PXQmJmkuZm10Pj0xJiZpLmZtdDw9Mil7aWYoMT09aS5mbXQpaS5kZWx0YT1vLnJlYWRTaG9ydChyLGEpLGErPTI7ZWxzZSBpZigyPT1pLmZtdCl7dmFyIGQ9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLm5ld2c9by5yZWFkVXNob3J0cyhyLGEsZCksYSs9MippLm5ld2cubGVuZ3RoO319ZWxzZSBpZigyPT10JiYxPT1pLmZtdCl7ZD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuc2Vxcz1bXTtmb3IodmFyIGY9MDtmPGQ7ZisrKXt2YXIgdT1vLnJlYWRVc2hvcnQocixhKStzO2ErPTI7dmFyIGw9by5yZWFkVXNob3J0KHIsdSk7aS5zZXFzLnB1c2goby5yZWFkVXNob3J0cyhyLHUrMixsKSk7fX1lbHNlIGlmKDQ9PXQpe2kudmFscz1bXTtkPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7Zm9yKGY9MDtmPGQ7ZisrKXt2YXIgdj1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkudmFscy5wdXNoKGUuR1NVQi5yZWFkTGlnYXR1cmVTZXQocixzK3YpKTt9fWVsc2UgaWYoNT09dCYmMj09aS5mbXQpe2lmKDI9PWkuZm10KXt2YXIgYz1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuY0RlZj1lLl9sY3RmLnJlYWRDbGFzc0RlZihyLHMrYyksaS5zY3NldD1bXTt2YXIgcD1vLnJlYWRVc2hvcnQocixhKTthKz0yO2ZvcihmPTA7ZjxwO2YrKyl7dmFyIFU9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLnNjc2V0LnB1c2goMD09VT9udWxsOmUuR1NVQi5yZWFkU3ViQ2xhc3NTZXQocixzK1UpKTt9fX1lbHNlIGlmKDY9PXQmJjM9PWkuZm10KXtpZigzPT1pLmZtdCl7Zm9yKGY9MDtmPDM7ZisrKXtkPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7Zm9yKHZhciBnPVtdLFM9MDtTPGQ7UysrKWcucHVzaChlLl9sY3RmLnJlYWRDb3ZlcmFnZShyLHMrby5yZWFkVXNob3J0KHIsYSsyKlMpKSk7YSs9MipkLDA9PWYmJihpLmJhY2tDdmc9ZyksMT09ZiYmKGkuaW5wdEN2Zz1nKSwyPT1mJiYoaS5haGVkQ3ZnPWcpO31kPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5sb29rdXBSZWM9ZS5HU1VCLnJlYWRTdWJzdExvb2t1cFJlY29yZHMocixhLGQpO319ZWxzZSB7aWYoNz09dCYmMT09aS5mbXQpe3ZhciBtPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIGI9by5yZWFkVWludChyLGEpO2lmKGErPTQsOT09bi5sdHlwZSluLmx0eXBlPW07ZWxzZSBpZihuLmx0eXBlIT1tKXRocm93IFwiaW52YWxpZCBleHRlbnNpb24gc3Vic3RpdHV0aW9uXCI7cmV0dXJuIGUuR1NVQi5zdWJ0KHIsbi5sdHlwZSxzK2IpfWNvbnNvbGUuZGVidWcoXCJ1bnN1cHBvcnRlZCBHU1VCIHRhYmxlIExvb2t1cFR5cGVcIix0LFwiZm9ybWF0XCIsaS5mbXQpO31yZXR1cm4gaX0sZS5HU1VCLnJlYWRTdWJDbGFzc1NldD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2Jpbi5yZWFkVXNob3J0LG49dCxvPVtdLHM9YShyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9YShyLHQpO3QrPTIsby5wdXNoKGUuR1NVQi5yZWFkU3ViQ2xhc3NSdWxlKHIsbitoKSk7fXJldHVybiBvfSxlLkdTVUIucmVhZFN1YkNsYXNzUnVsZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2Jpbi5yZWFkVXNob3J0LG49e30sbz1hKHIsdCkscz1hKHIsdCs9Mik7dCs9MixuLmlucHV0PVtdO2Zvcih2YXIgaT0wO2k8by0xO2krKyluLmlucHV0LnB1c2goYShyLHQpKSx0Kz0yO3JldHVybiBuLnN1YnN0TG9va3VwUmVjb3Jkcz1lLkdTVUIucmVhZFN1YnN0TG9va3VwUmVjb3JkcyhyLHQscyksbn0sZS5HU1VCLnJlYWRTdWJzdExvb2t1cFJlY29yZHM9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1lLl9iaW4ucmVhZFVzaG9ydCxvPVtdLHM9MDtzPGE7cysrKW8ucHVzaChuKHIsdCksbihyLHQrMikpLHQrPTQ7cmV0dXJuIG99LGUuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1NldD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz1bXSxzPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnB1c2goZS5HU1VCLnJlYWRDaGFpblN1YkNsYXNzUnVsZShyLG4raCkpO31yZXR1cm4gb30sZS5HU1VCLnJlYWRDaGFpblN1YkNsYXNzUnVsZT1mdW5jdGlvbihyLHQpe2Zvcih2YXIgYT1lLl9iaW4sbj17fSxvPVtcImJhY2t0cmFja1wiLFwiaW5wdXRcIixcImxvb2thaGVhZFwiXSxzPTA7czxvLmxlbmd0aDtzKyspe3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsMT09cyYmaS0tLG5bb1tzXV09YS5yZWFkVXNob3J0cyhyLHQsaSksdCs9MipuW29bc11dLmxlbmd0aDt9aT1hLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MixuLnN1YnN0PWEucmVhZFVzaG9ydHMocix0LDIqaSksdCs9MipuLnN1YnN0Lmxlbmd0aCxufSxlLkdTVUIucmVhZExpZ2F0dXJlU2V0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPVtdLHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8ucHVzaChlLkdTVUIucmVhZExpZ2F0dXJlKHIsbitoKSk7fXJldHVybiBvfSxlLkdTVUIucmVhZExpZ2F0dXJlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e2NoYWluOltdfTtuLm5nbHlwaD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBzPTA7czxvLTE7cysrKW4uY2hhaW4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MjtyZXR1cm4gbn0sZS5oZWFkPXt9LGUuaGVhZC5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e307cmV0dXJuIG4ucmVhZEZpeGVkKHIsdCksdCs9NCxvLmZvbnRSZXZpc2lvbj1uLnJlYWRGaXhlZChyLHQpLHQrPTQsbi5yZWFkVWludChyLHQpLHQrPTQsbi5yZWFkVWludChyLHQpLHQrPTQsby5mbGFncz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8udW5pdHNQZXJFbT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8uY3JlYXRlZD1uLnJlYWRVaW50NjQocix0KSx0Kz04LG8ubW9kaWZpZWQ9bi5yZWFkVWludDY0KHIsdCksdCs9OCxvLnhNaW49bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueU1pbj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby54TWF4PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnlNYXg9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ubWFjU3R5bGU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLmxvd2VzdFJlY1BQRU09bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLmZvbnREaXJlY3Rpb25IaW50PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmluZGV4VG9Mb2NGb3JtYXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uZ2x5cGhEYXRhRm9ybWF0PW4ucmVhZFNob3J0KHIsdCksdCs9MixvfSxlLmhoZWE9e30sZS5oaGVhLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fTtyZXR1cm4gbi5yZWFkRml4ZWQocix0KSx0Kz00LG8uYXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uZGVzY2VuZGVyPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmxpbmVHYXA9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uYWR2YW5jZVdpZHRoTWF4PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5taW5MZWZ0U2lkZUJlYXJpbmc9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ubWluUmlnaHRTaWRlQmVhcmluZz1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby54TWF4RXh0ZW50PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmNhcmV0U2xvcGVSaXNlPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmNhcmV0U2xvcGVSdW49bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uY2FyZXRPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLHQrPTgsby5tZXRyaWNEYXRhRm9ybWF0PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLm51bWJlck9mSE1ldHJpY3M9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvfSxlLmhtdHg9e30sZS5obXR4LnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe2Zvcih2YXIgbz1lLl9iaW4scz17YVdpZHRoOltdLGxzQmVhcmluZzpbXX0saT0wLGg9MCxkPTA7ZDxuLm1heHAubnVtR2x5cGhzO2QrKylkPG4uaGhlYS5udW1iZXJPZkhNZXRyaWNzJiYoaT1vLnJlYWRVc2hvcnQocix0KSx0Kz0yLGg9by5yZWFkU2hvcnQocix0KSx0Kz0yKSxzLmFXaWR0aC5wdXNoKGkpLHMubHNCZWFyaW5nLnB1c2goaCk7cmV0dXJuIHN9LGUua2Vybj17fSxlLmtlcm4ucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7dmFyIG89ZS5fYmluLHM9by5yZWFkVXNob3J0KHIsdCk7aWYodCs9MiwxPT1zKXJldHVybiBlLmtlcm4ucGFyc2VWMShyLHQtMixhLG4pO3ZhciBpPW8ucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPXtnbHlwaDE6W10scnZhbDpbXX0sZD0wO2Q8aTtkKyspe3QrPTI7YT1vLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPW8ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHU9Zj4+Pjg7aWYoMCE9KHUmPTE1KSl0aHJvdyBcInVua25vd24ga2VybiB0YWJsZSBmb3JtYXQ6IFwiK3U7dD1lLmtlcm4ucmVhZEZvcm1hdDAocix0LGgpO31yZXR1cm4gaH0sZS5rZXJuLnBhcnNlVjE9ZnVuY3Rpb24ocix0LGEsbil7dmFyIG89ZS5fYmluO28ucmVhZEZpeGVkKHIsdCksdCs9NDt2YXIgcz1vLnJlYWRVaW50KHIsdCk7dCs9NDtmb3IodmFyIGk9e2dseXBoMTpbXSxydmFsOltdfSxoPTA7aDxzO2grKyl7by5yZWFkVWludChyLHQpLHQrPTQ7dmFyIGQ9by5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBmPWQ+Pj44O2lmKDAhPShmJj0xNSkpdGhyb3cgXCJ1bmtub3duIGtlcm4gdGFibGUgZm9ybWF0OiBcIitmO3Q9ZS5rZXJuLnJlYWRGb3JtYXQwKHIsdCxpKTt9cmV0dXJuIGl9LGUua2Vybi5yZWFkRm9ybWF0MD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89LTEscz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yLG4ucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5yZWFkVXNob3J0KHIsdCksdCs9MixuLnJlYWRVc2hvcnQocix0KSx0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGQ9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZj1uLnJlYWRTaG9ydChyLHQpO3QrPTIsaCE9byYmKGEuZ2x5cGgxLnB1c2goaCksYS5ydmFsLnB1c2goe2dseXBoMjpbXSx2YWxzOltdfSkpO3ZhciB1PWEucnZhbFthLnJ2YWwubGVuZ3RoLTFdO3UuZ2x5cGgyLnB1c2goZCksdS52YWxzLnB1c2goZiksbz1oO31yZXR1cm4gdH0sZS5sb2NhPXt9LGUubG9jYS5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1bXSxpPW4uaGVhZC5pbmRleFRvTG9jRm9ybWF0LGg9bi5tYXhwLm51bUdseXBocysxO2lmKDA9PWkpZm9yKHZhciBkPTA7ZDxoO2QrKylzLnB1c2goby5yZWFkVXNob3J0KHIsdCsoZDw8MSkpPDwxKTtpZigxPT1pKWZvcihkPTA7ZDxoO2QrKylzLnB1c2goby5yZWFkVWludChyLHQrKGQ8PDIpKSk7cmV0dXJuIHN9LGUubWF4cD17fSxlLm1heHAucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9LHM9bi5yZWFkVWludChyLHQpO3JldHVybiB0Kz00LG8ubnVtR2x5cGhzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsNjU1MzY9PXMmJihvLm1heFBvaW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29udG91cnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvc2l0ZVBvaW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29tcG9zaXRlQ29udG91cnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFpvbmVzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhUd2lsaWdodFBvaW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4U3RvcmFnZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4RnVuY3Rpb25EZWZzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhJbnN0cnVjdGlvbkRlZnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFN0YWNrRWxlbWVudHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFNpemVPZkluc3RydWN0aW9ucz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29tcG9uZW50RWxlbWVudHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvbmVudERlcHRoPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIpLG99LGUubmFtZT17fSxlLm5hbWUucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O24ucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIHM9bi5yZWFkVXNob3J0KHIsdCk7dCs9MixuLnJlYWRVc2hvcnQocix0KTtmb3IodmFyIGksaD1bXCJjb3B5cmlnaHRcIixcImZvbnRGYW1pbHlcIixcImZvbnRTdWJmYW1pbHlcIixcIklEXCIsXCJmdWxsTmFtZVwiLFwidmVyc2lvblwiLFwicG9zdFNjcmlwdE5hbWVcIixcInRyYWRlbWFya1wiLFwibWFudWZhY3R1cmVyXCIsXCJkZXNpZ25lclwiLFwiZGVzY3JpcHRpb25cIixcInVybFZlbmRvclwiLFwidXJsRGVzaWduZXJcIixcImxpY2VuY2VcIixcImxpY2VuY2VVUkxcIixcIi0tLVwiLFwidHlwb0ZhbWlseU5hbWVcIixcInR5cG9TdWJmYW1pbHlOYW1lXCIsXCJjb21wYXRpYmxlRnVsbFwiLFwic2FtcGxlVGV4dFwiLFwicG9zdFNjcmlwdENJRFwiLFwid3dzRmFtaWx5TmFtZVwiLFwid3dzU3ViZmFtaWx5TmFtZVwiLFwibGlnaHRQYWxldHRlXCIsXCJkYXJrUGFsZXR0ZVwiXSxkPXQrPTIsZj0wO2Y8cztmKyspe3ZhciB1PW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGw9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdj1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBjPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHA9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgVT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBnLFM9aFtjXSxtPWQrMTIqcytVO2lmKDA9PXUpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2UgaWYoMz09dSYmMD09bClnPW4ucmVhZFVuaWNvZGUocixtLHAvMik7ZWxzZSBpZigwPT1sKWc9bi5yZWFkQVNDSUkocixtLHApO2Vsc2UgaWYoMT09bClnPW4ucmVhZFVuaWNvZGUocixtLHAvMik7ZWxzZSBpZigzPT1sKWc9bi5yZWFkVW5pY29kZShyLG0scC8yKTtlbHNlIHtpZigxIT11KXRocm93IFwidW5rbm93biBlbmNvZGluZyBcIitsK1wiLCBwbGF0Zm9ybUlEOiBcIit1O2c9bi5yZWFkQVNDSUkocixtLHApLGNvbnNvbGUuZGVidWcoXCJyZWFkaW5nIHVua25vd24gTUFDIGVuY29kaW5nIFwiK2wrXCIgYXMgQVNDSUlcIik7fXZhciBiPVwicFwiK3UrXCIsXCIrdi50b1N0cmluZygxNik7bnVsbD09b1tiXSYmKG9bYl09e30pLG9bYl1bdm9pZCAwIT09Uz9TOmNdPWcsb1tiXS5fbGFuZz12O31mb3IodmFyIHkgaW4gbylpZihudWxsIT1vW3ldLnBvc3RTY3JpcHROYW1lJiYxMDMzPT1vW3ldLl9sYW5nKXJldHVybiBvW3ldO2Zvcih2YXIgeSBpbiBvKWlmKG51bGwhPW9beV0ucG9zdFNjcmlwdE5hbWUmJjA9PW9beV0uX2xhbmcpcmV0dXJuIG9beV07Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSYmMzA4ND09b1t5XS5fbGFuZylyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbylpZihudWxsIT1vW3ldLnBvc3RTY3JpcHROYW1lKXJldHVybiBvW3ldO2Zvcih2YXIgeSBpbiBvKXtpPXk7YnJlYWt9cmV0dXJuIGNvbnNvbGUuZGVidWcoXCJyZXR1cm5pbmcgbmFtZSB0YWJsZSB3aXRoIGxhbmd1YWdlSUQgXCIrb1tpXS5fbGFuZyksb1tpXX0sZVtcIk9TLzJcIl09e30sZVtcIk9TLzJcIl0ucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2Jpbi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgbz17fTtpZigwPT1uKWVbXCJPUy8yXCJdLnZlcnNpb24wKHIsdCxvKTtlbHNlIGlmKDE9PW4pZVtcIk9TLzJcIl0udmVyc2lvbjEocix0LG8pO2Vsc2UgaWYoMj09bnx8Mz09bnx8ND09billW1wiT1MvMlwiXS52ZXJzaW9uMihyLHQsbyk7ZWxzZSB7aWYoNSE9bil0aHJvdyBcInVua25vd24gT1MvMiB0YWJsZSB2ZXJzaW9uOiBcIituO2VbXCJPUy8yXCJdLnZlcnNpb241KHIsdCxvKTt9cmV0dXJuIG99LGVbXCJPUy8yXCJdLnZlcnNpb24wPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47cmV0dXJuIGEueEF2Z0NoYXJXaWR0aD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS51c1dlaWdodENsYXNzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c1dpZHRoQ2xhc3M9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLmZzVHlwZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFhTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdWJzY3JpcHRZU2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3Vic2NyaXB0WE9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3Vic2NyaXB0WU9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3VwZXJzY3JpcHRYU2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3VwZXJzY3JpcHRZU2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3VwZXJzY3JpcHRYT2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdXBlcnNjcmlwdFlPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN0cmlrZW91dFNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN0cmlrZW91dFBvc2l0aW9uPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnNGYW1pbHlDbGFzcz1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5wYW5vc2U9bi5yZWFkQnl0ZXMocix0LDEwKSx0Kz0xMCxhLnVsVW5pY29kZVJhbmdlMT1uLnJlYWRVaW50KHIsdCksdCs9NCxhLnVsVW5pY29kZVJhbmdlMj1uLnJlYWRVaW50KHIsdCksdCs9NCxhLnVsVW5pY29kZVJhbmdlMz1uLnJlYWRVaW50KHIsdCksdCs9NCxhLnVsVW5pY29kZVJhbmdlND1uLnJlYWRVaW50KHIsdCksdCs9NCxhLmFjaFZlbmRJRD1bbi5yZWFkSW50OChyLHQpLG4ucmVhZEludDgocix0KzEpLG4ucmVhZEludDgocix0KzIpLG4ucmVhZEludDgocix0KzMpXSx0Kz00LGEuZnNTZWxlY3Rpb249bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzRmlyc3RDaGFySW5kZXg9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzTGFzdENoYXJJbmRleD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEuc1R5cG9Bc2NlbmRlcj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zVHlwb0Rlc2NlbmRlcj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zVHlwb0xpbmVHYXA9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEudXNXaW5Bc2NlbnQ9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzV2luRGVzY2VudD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yfSxlW1wiT1MvMlwiXS52ZXJzaW9uMT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluO3JldHVybiB0PWVbXCJPUy8yXCJdLnZlcnNpb24wKHIsdCxhKSxhLnVsQ29kZVBhZ2VSYW5nZTE9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bENvZGVQYWdlUmFuZ2UyPW4ucmVhZFVpbnQocix0KSx0Kz00fSxlW1wiT1MvMlwiXS52ZXJzaW9uMj1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluO3JldHVybiB0PWVbXCJPUy8yXCJdLnZlcnNpb24xKHIsdCxhKSxhLnN4SGVpZ2h0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnNDYXBIZWlnaHQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEudXNEZWZhdWx0PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c0JyZWFrPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c01heENvbnRleHQ9bi5yZWFkVXNob3J0KHIsdCksdCs9Mn0sZVtcIk9TLzJcIl0udmVyc2lvbjU9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gdD1lW1wiT1MvMlwiXS52ZXJzaW9uMihyLHQsYSksYS51c0xvd2VyT3B0aWNhbFBvaW50U2l6ZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNVcHBlck9wdGljYWxQb2ludFNpemU9bi5yZWFkVXNob3J0KHIsdCksdCs9Mn0sZS5wb3N0PXt9LGUucG9zdC5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e307cmV0dXJuIG8udmVyc2lvbj1uLnJlYWRGaXhlZChyLHQpLHQrPTQsby5pdGFsaWNBbmdsZT1uLnJlYWRGaXhlZChyLHQpLHQrPTQsby51bmRlcmxpbmVQb3NpdGlvbj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby51bmRlcmxpbmVUaGlja25lc3M9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG99LG51bGw9PWUmJihlPXt9KSxudWxsPT1lLlUmJihlLlU9e30pLGUuVS5jb2RlVG9HbHlwaD1mdW5jdGlvbihyLGUpe3ZhciB0PXIuY21hcCxhPS0xO2lmKG51bGwhPXQucDBlND9hPXQucDBlNDpudWxsIT10LnAzZTE/YT10LnAzZTE6bnVsbCE9dC5wMWUwP2E9dC5wMWUwOm51bGwhPXQucDBlMyYmKGE9dC5wMGUzKSwtMT09YSl0aHJvdyBcIm5vIGZhbWlsaWFyIHBsYXRmb3JtIGFuZCBlbmNvZGluZyFcIjt2YXIgbj10LnRhYmxlc1thXTtpZigwPT1uLmZvcm1hdClyZXR1cm4gZT49bi5tYXAubGVuZ3RoPzA6bi5tYXBbZV07aWYoND09bi5mb3JtYXQpe2Zvcih2YXIgbz0tMSxzPTA7czxuLmVuZENvdW50Lmxlbmd0aDtzKyspaWYoZTw9bi5lbmRDb3VudFtzXSl7bz1zO2JyZWFrfWlmKC0xPT1vKXJldHVybiAwO2lmKG4uc3RhcnRDb3VudFtvXT5lKXJldHVybiAwO3JldHVybiA2NTUzNSYoMCE9bi5pZFJhbmdlT2Zmc2V0W29dP24uZ2x5cGhJZEFycmF5W2Utbi5zdGFydENvdW50W29dKyhuLmlkUmFuZ2VPZmZzZXRbb10+PjEpLShuLmlkUmFuZ2VPZmZzZXQubGVuZ3RoLW8pXTplK24uaWREZWx0YVtvXSl9aWYoMTI9PW4uZm9ybWF0KXtpZihlPm4uZ3JvdXBzW24uZ3JvdXBzLmxlbmd0aC0xXVsxXSlyZXR1cm4gMDtmb3Iocz0wO3M8bi5ncm91cHMubGVuZ3RoO3MrKyl7dmFyIGk9bi5ncm91cHNbc107aWYoaVswXTw9ZSYmZTw9aVsxXSlyZXR1cm4gaVsyXSsoZS1pWzBdKX1yZXR1cm4gMH10aHJvdyBcInVua25vd24gY21hcCB0YWJsZSBmb3JtYXQgXCIrbi5mb3JtYXR9LGUuVS5nbHlwaFRvUGF0aD1mdW5jdGlvbihyLHQpe3ZhciBhPXtjbWRzOltdLGNyZHM6W119O2lmKHIuU1ZHJiZyLlNWRy5lbnRyaWVzW3RdKXt2YXIgbj1yLlNWRy5lbnRyaWVzW3RdO3JldHVybiBudWxsPT1uP2E6KFwic3RyaW5nXCI9PXR5cGVvZiBuJiYobj1lLlNWRy50b1BhdGgobiksci5TVkcuZW50cmllc1t0XT1uKSxuKX1pZihyLkNGRil7dmFyIG89e3g6MCx5OjAsc3RhY2s6W10sblN0ZW1zOjAsaGF2ZVdpZHRoOiExLHdpZHRoOnIuQ0ZGLlByaXZhdGU/ci5DRkYuUHJpdmF0ZS5kZWZhdWx0V2lkdGhYOjAsb3BlbjohMX0scz1yLkNGRixpPXIuQ0ZGLlByaXZhdGU7aWYocy5ST1Mpe2Zvcih2YXIgaD0wO3MuRkRTZWxlY3RbaCsyXTw9dDspaCs9MjtpPXMuRkRBcnJheVtzLkZEU2VsZWN0W2grMV1dLlByaXZhdGU7fWUuVS5fZHJhd0NGRihyLkNGRi5DaGFyU3RyaW5nc1t0XSxvLHMsaSxhKTt9ZWxzZSByLmdseWYmJmUuVS5fZHJhd0dseWYodCxyLGEpO3JldHVybiBhfSxlLlUuX2RyYXdHbHlmPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj10LmdseWZbcl07bnVsbD09biYmKG49dC5nbHlmW3JdPWUuZ2x5Zi5fcGFyc2VHbHlmKHQscikpLG51bGwhPW4mJihuLm5vYz4tMT9lLlUuX3NpbXBsZUdseXBoKG4sYSk6ZS5VLl9jb21wb0dseXBoKG4sdCxhKSk7fSxlLlUuX3NpbXBsZUdseXBoPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBhPTA7YTxyLm5vYzthKyspe2Zvcih2YXIgbj0wPT1hPzA6ci5lbmRQdHNbYS0xXSsxLG89ci5lbmRQdHNbYV0scz1uO3M8PW87cysrKXt2YXIgaT1zPT1uP286cy0xLGg9cz09bz9uOnMrMSxkPTEmci5mbGFnc1tzXSxmPTEmci5mbGFnc1tpXSx1PTEmci5mbGFnc1toXSxsPXIueHNbc10sdj1yLnlzW3NdO2lmKHM9PW4paWYoZCl7aWYoIWYpe2UuVS5QLm1vdmVUbyh0LGwsdik7Y29udGludWV9ZS5VLlAubW92ZVRvKHQsci54c1tpXSxyLnlzW2ldKTt9ZWxzZSBmP2UuVS5QLm1vdmVUbyh0LHIueHNbaV0sci55c1tpXSk6ZS5VLlAubW92ZVRvKHQsKHIueHNbaV0rbCkvMiwoci55c1tpXSt2KS8yKTtkP2YmJmUuVS5QLmxpbmVUbyh0LGwsdik6dT9lLlUuUC5xY3VydmVUbyh0LGwsdixyLnhzW2hdLHIueXNbaF0pOmUuVS5QLnFjdXJ2ZVRvKHQsbCx2LChsK3IueHNbaF0pLzIsKHYrci55c1toXSkvMik7fWUuVS5QLmNsb3NlUGF0aCh0KTt9fSxlLlUuX2NvbXBvR2x5cGg9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj0wO248ci5wYXJ0cy5sZW5ndGg7bisrKXt2YXIgbz17Y21kczpbXSxjcmRzOltdfSxzPXIucGFydHNbbl07ZS5VLl9kcmF3R2x5ZihzLmdseXBoSW5kZXgsdCxvKTtmb3IodmFyIGk9cy5tLGg9MDtoPG8uY3Jkcy5sZW5ndGg7aCs9Mil7dmFyIGQ9by5jcmRzW2hdLGY9by5jcmRzW2grMV07YS5jcmRzLnB1c2goZCppLmErZippLmIraS50eCksYS5jcmRzLnB1c2goZCppLmMrZippLmQraS50eSk7fWZvcihoPTA7aDxvLmNtZHMubGVuZ3RoO2grKylhLmNtZHMucHVzaChvLmNtZHNbaF0pO319LGUuVS5fZ2V0R2x5cGhDbGFzcz1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2xjdGYuZ2V0SW50ZXJ2YWwodCxyKTtyZXR1cm4gLTE9PWE/MDp0W2ErMl19LGUuVS5fYXBwbHlTdWJzPWZ1bmN0aW9uKHIsdCxhLG4pe2Zvcih2YXIgbz1yLmxlbmd0aC10LTEscz0wO3M8YS50YWJzLmxlbmd0aDtzKyspaWYobnVsbCE9YS50YWJzW3NdKXt2YXIgaSxoPWEudGFic1tzXTtpZighaC5jb3ZlcmFnZXx8LTEhPShpPWUuX2xjdGYuY292ZXJhZ2VJbmRleChoLmNvdmVyYWdlLHJbdF0pKSlpZigxPT1hLmx0eXBlKXJbdF0sMT09aC5mbXQ/clt0XT1yW3RdK2guZGVsdGE6clt0XT1oLm5ld2dbaV07ZWxzZSBpZig0PT1hLmx0eXBlKWZvcih2YXIgZD1oLnZhbHNbaV0sZj0wO2Y8ZC5sZW5ndGg7ZisrKXt2YXIgdT1kW2ZdLGw9dS5jaGFpbi5sZW5ndGg7aWYoIShsPm8pKXtmb3IodmFyIHY9ITAsYz0wLHA9MDtwPGw7cCsrKXtmb3IoOy0xPT1yW3QrYysoMStwKV07KWMrKzt1LmNoYWluW3BdIT1yW3QrYysoMStwKV0mJih2PSExKTt9aWYodil7clt0XT11Lm5nbHlwaDtmb3IocD0wO3A8bCtjO3ArKylyW3QrcCsxXT0tMTticmVha319fWVsc2UgaWYoNT09YS5sdHlwZSYmMj09aC5mbXQpZm9yKHZhciBVPWUuX2xjdGYuZ2V0SW50ZXJ2YWwoaC5jRGVmLHJbdF0pLGc9aC5jRGVmW1UrMl0sUz1oLnNjc2V0W2ddLG09MDttPFMubGVuZ3RoO20rKyl7dmFyIGI9U1ttXSx5PWIuaW5wdXQ7aWYoISh5Lmxlbmd0aD5vKSl7Zm9yKHY9ITAscD0wO3A8eS5sZW5ndGg7cCsrKXt2YXIgRj1lLl9sY3RmLmdldEludGVydmFsKGguY0RlZixyW3QrMStwXSk7aWYoLTE9PVUmJmguY0RlZltGKzJdIT15W3BdKXt2PSExO2JyZWFrfX1pZih2KXt2YXIgQz1iLnN1YnN0TG9va3VwUmVjb3Jkcztmb3IoZj0wO2Y8Qy5sZW5ndGg7Zis9MilDW2ZdLENbZisxXTt9fX1lbHNlIGlmKDY9PWEubHR5cGUmJjM9PWguZm10KXtpZighZS5VLl9nbHNDb3ZlcmVkKHIsaC5iYWNrQ3ZnLHQtaC5iYWNrQ3ZnLmxlbmd0aCkpY29udGludWU7aWYoIWUuVS5fZ2xzQ292ZXJlZChyLGguaW5wdEN2Zyx0KSljb250aW51ZTtpZighZS5VLl9nbHNDb3ZlcmVkKHIsaC5haGVkQ3ZnLHQraC5pbnB0Q3ZnLmxlbmd0aCkpY29udGludWU7dmFyIF89aC5sb29rdXBSZWM7Zm9yKG09MDttPF8ubGVuZ3RoO20rPTIpe1U9X1ttXTt2YXIgUD1uW19bbSsxXV07ZS5VLl9hcHBseVN1YnMocix0K1UsUCxuKTt9fX19LGUuVS5fZ2xzQ292ZXJlZD1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe2lmKC0xPT1lLl9sY3RmLmNvdmVyYWdlSW5kZXgodFtuXSxyW2Erbl0pKXJldHVybiAhMX1yZXR1cm4gITB9LGUuVS5nbHlwaHNUb1BhdGg9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj17Y21kczpbXSxjcmRzOltdfSxvPTAscz0wO3M8dC5sZW5ndGg7cysrKXt2YXIgaT10W3NdO2lmKC0xIT1pKXtmb3IodmFyIGg9czx0Lmxlbmd0aC0xJiYtMSE9dFtzKzFdP3RbcysxXTowLGQ9ZS5VLmdseXBoVG9QYXRoKHIsaSksZj0wO2Y8ZC5jcmRzLmxlbmd0aDtmKz0yKW4uY3Jkcy5wdXNoKGQuY3Jkc1tmXStvKSxuLmNyZHMucHVzaChkLmNyZHNbZisxXSk7YSYmbi5jbWRzLnB1c2goYSk7Zm9yKGY9MDtmPGQuY21kcy5sZW5ndGg7ZisrKW4uY21kcy5wdXNoKGQuY21kc1tmXSk7YSYmbi5jbWRzLnB1c2goXCJYXCIpLG8rPXIuaG10eC5hV2lkdGhbaV0sczx0Lmxlbmd0aC0xJiYobys9ZS5VLmdldFBhaXJBZGp1c3RtZW50KHIsaSxoKSk7fX1yZXR1cm4gbn0sZS5VLlA9e30sZS5VLlAubW92ZVRvPWZ1bmN0aW9uKHIsZSx0KXtyLmNtZHMucHVzaChcIk1cIiksci5jcmRzLnB1c2goZSx0KTt9LGUuVS5QLmxpbmVUbz1mdW5jdGlvbihyLGUsdCl7ci5jbWRzLnB1c2goXCJMXCIpLHIuY3Jkcy5wdXNoKGUsdCk7fSxlLlUuUC5jdXJ2ZVRvPWZ1bmN0aW9uKHIsZSx0LGEsbixvLHMpe3IuY21kcy5wdXNoKFwiQ1wiKSxyLmNyZHMucHVzaChlLHQsYSxuLG8scyk7fSxlLlUuUC5xY3VydmVUbz1mdW5jdGlvbihyLGUsdCxhLG4pe3IuY21kcy5wdXNoKFwiUVwiKSxyLmNyZHMucHVzaChlLHQsYSxuKTt9LGUuVS5QLmNsb3NlUGF0aD1mdW5jdGlvbihyKXtyLmNtZHMucHVzaChcIlpcIik7fSxlLlUuX2RyYXdDRkY9ZnVuY3Rpb24ocix0LGEsbixvKXtmb3IodmFyIHM9dC5zdGFjayxpPXQublN0ZW1zLGg9dC5oYXZlV2lkdGgsZD10LndpZHRoLGY9dC5vcGVuLHU9MCxsPXQueCx2PXQueSxjPTAscD0wLFU9MCxnPTAsUz0wLG09MCxiPTAseT0wLEY9MCxDPTAsXz17dmFsOjAsc2l6ZTowfTt1PHIubGVuZ3RoOyl7ZS5DRkYuZ2V0Q2hhclN0cmluZyhyLHUsXyk7dmFyIFA9Xy52YWw7aWYodSs9Xy5zaXplLFwibzFcIj09UHx8XCJvMThcIj09UClzLmxlbmd0aCUyIT0wJiYhaCYmKGQ9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCksaSs9cy5sZW5ndGg+PjEscy5sZW5ndGg9MCxoPSEwO2Vsc2UgaWYoXCJvM1wiPT1QfHxcIm8yM1wiPT1QKXtzLmxlbmd0aCUyIT0wJiYhaCYmKGQ9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCksaSs9cy5sZW5ndGg+PjEscy5sZW5ndGg9MCxoPSEwO31lbHNlIGlmKFwibzRcIj09UClzLmxlbmd0aD4xJiYhaCYmKGQ9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCxoPSEwKSxmJiZlLlUuUC5jbG9zZVBhdGgobyksdis9cy5wb3AoKSxlLlUuUC5tb3ZlVG8obyxsLHYpLGY9ITA7ZWxzZSBpZihcIm81XCI9PVApZm9yKDtzLmxlbmd0aD4wOylsKz1zLnNoaWZ0KCksdis9cy5zaGlmdCgpLGUuVS5QLmxpbmVUbyhvLGwsdik7ZWxzZSBpZihcIm82XCI9PVB8fFwibzdcIj09UClmb3IodmFyIHg9cy5sZW5ndGgsST1cIm82XCI9PVAsdz0wO3c8eDt3Kyspe3ZhciBrPXMuc2hpZnQoKTtJP2wrPWs6dis9ayxJPSFJLGUuVS5QLmxpbmVUbyhvLGwsdik7fWVsc2UgaWYoXCJvOFwiPT1QfHxcIm8yNFwiPT1QKXt4PXMubGVuZ3RoO2Zvcih2YXIgRz0wO0crNjw9eDspYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxsPVUrcy5zaGlmdCgpLHY9ZytzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KSxHKz02O1wibzI0XCI9PVAmJihsKz1zLnNoaWZ0KCksdis9cy5zaGlmdCgpLGUuVS5QLmxpbmVUbyhvLGwsdikpO31lbHNlIHtpZihcIm8xMVwiPT1QKWJyZWFrO2lmKFwibzEyMzRcIj09UHx8XCJvMTIzNVwiPT1QfHxcIm8xMjM2XCI9PVB8fFwibzEyMzdcIj09UClcIm8xMjM0XCI9PVAmJihwPXYsVT0oYz1sK3Muc2hpZnQoKSkrcy5zaGlmdCgpLEM9Zz1wK3Muc2hpZnQoKSxtPWcseT12LGw9KGI9KFM9KEY9VStzLnNoaWZ0KCkpK3Muc2hpZnQoKSkrcy5zaGlmdCgpKStzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixDKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKSxcIm8xMjM1XCI9PVAmJihjPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLEY9VStzLnNoaWZ0KCksQz1nK3Muc2hpZnQoKSxTPUYrcy5zaGlmdCgpLG09QytzLnNoaWZ0KCksYj1TK3Muc2hpZnQoKSx5PW0rcy5zaGlmdCgpLGw9YitzLnNoaWZ0KCksdj15K3Muc2hpZnQoKSxzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixDKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKSxcIm8xMjM2XCI9PVAmJihjPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxDPWc9cCtzLnNoaWZ0KCksbT1nLGI9KFM9KEY9VStzLnNoaWZ0KCkpK3Muc2hpZnQoKSkrcy5zaGlmdCgpLHk9bStzLnNoaWZ0KCksbD1iK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxGLEMpLGUuVS5QLmN1cnZlVG8obyxTLG0sYix5LGwsdikpLFwibzEyMzdcIj09UCYmKGM9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksRj1VK3Muc2hpZnQoKSxDPWcrcy5zaGlmdCgpLFM9RitzLnNoaWZ0KCksbT1DK3Muc2hpZnQoKSxiPVMrcy5zaGlmdCgpLHk9bStzLnNoaWZ0KCksTWF0aC5hYnMoYi1sKT5NYXRoLmFicyh5LXYpP2w9YitzLnNoaWZ0KCk6dj15K3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxGLEMpLGUuVS5QLmN1cnZlVG8obyxTLG0sYix5LGwsdikpO2Vsc2UgaWYoXCJvMTRcIj09UCl7aWYocy5sZW5ndGg+MCYmIWgmJihkPXMuc2hpZnQoKSthLm5vbWluYWxXaWR0aFgsaD0hMCksND09cy5sZW5ndGgpe3ZhciBPPXMuc2hpZnQoKSxUPXMuc2hpZnQoKSxEPXMuc2hpZnQoKSxCPXMuc2hpZnQoKSxBPWUuQ0ZGLmdseXBoQnlTRShhLEQpLFI9ZS5DRkYuZ2x5cGhCeVNFKGEsQik7ZS5VLl9kcmF3Q0ZGKGEuQ2hhclN0cmluZ3NbQV0sdCxhLG4sbyksdC54PU8sdC55PVQsZS5VLl9kcmF3Q0ZGKGEuQ2hhclN0cmluZ3NbUl0sdCxhLG4sbyk7fWYmJihlLlUuUC5jbG9zZVBhdGgobyksZj0hMSk7fWVsc2UgaWYoXCJvMTlcIj09UHx8XCJvMjBcIj09UCl7cy5sZW5ndGglMiE9MCYmIWgmJihkPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgpLGkrPXMubGVuZ3RoPj4xLHMubGVuZ3RoPTAsaD0hMCx1Kz1pKzc+PjM7fWVsc2UgaWYoXCJvMjFcIj09UClzLmxlbmd0aD4yJiYhaCYmKGQ9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCxoPSEwKSx2Kz1zLnBvcCgpLGwrPXMucG9wKCksZiYmZS5VLlAuY2xvc2VQYXRoKG8pLGUuVS5QLm1vdmVUbyhvLGwsdiksZj0hMDtlbHNlIGlmKFwibzIyXCI9PVApcy5sZW5ndGg+MSYmIWgmJihkPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgsaD0hMCksbCs9cy5wb3AoKSxmJiZlLlUuUC5jbG9zZVBhdGgobyksZS5VLlAubW92ZVRvKG8sbCx2KSxmPSEwO2Vsc2UgaWYoXCJvMjVcIj09UCl7Zm9yKDtzLmxlbmd0aD42OylsKz1zLnNoaWZ0KCksdis9cy5zaGlmdCgpLGUuVS5QLmxpbmVUbyhvLGwsdik7Yz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxsPVUrcy5zaGlmdCgpLHY9ZytzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KTt9ZWxzZSBpZihcIm8yNlwiPT1QKWZvcihzLmxlbmd0aCUyJiYobCs9cy5zaGlmdCgpKTtzLmxlbmd0aD4wOyljPWwscD12K3Muc2hpZnQoKSxsPVU9YytzLnNoaWZ0KCksdj0oZz1wK3Muc2hpZnQoKSkrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdik7ZWxzZSBpZihcIm8yN1wiPT1QKWZvcihzLmxlbmd0aCUyJiYodis9cy5zaGlmdCgpKTtzLmxlbmd0aD4wOylwPXYsVT0oYz1sK3Muc2hpZnQoKSkrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSx2PWcsZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KTtlbHNlIGlmKFwibzEwXCI9PVB8fFwibzI5XCI9PVApe3ZhciBMPVwibzEwXCI9PVA/bjphO2lmKDA9PXMubGVuZ3RoKWNvbnNvbGUuZGVidWcoXCJlcnJvcjogZW1wdHkgc3RhY2tcIik7ZWxzZSB7dmFyIFc9cy5wb3AoKSxNPUwuU3VicnNbVytMLkJpYXNdO3QueD1sLHQueT12LHQublN0ZW1zPWksdC5oYXZlV2lkdGg9aCx0LndpZHRoPWQsdC5vcGVuPWYsZS5VLl9kcmF3Q0ZGKE0sdCxhLG4sbyksbD10Lngsdj10LnksaT10Lm5TdGVtcyxoPXQuaGF2ZVdpZHRoLGQ9dC53aWR0aCxmPXQub3Blbjt9fWVsc2UgaWYoXCJvMzBcIj09UHx8XCJvMzFcIj09UCl7dmFyIFY9cy5sZW5ndGgsRT0oRz0wLFwibzMxXCI9PVApO2ZvcihHKz1WLSh4PS0zJlYpO0c8eDspRT8ocD12LFU9KGM9bCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSx2PShnPXArcy5zaGlmdCgpKStzLnNoaWZ0KCkseC1HPT01PyhsPVUrcy5zaGlmdCgpLEcrKyk6bD1VLEU9ITEpOihjPWwscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSx4LUc9PTU/KHY9ZytzLnNoaWZ0KCksRysrKTp2PWcsRT0hMCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KSxHKz00O31lbHNlIHtpZihcIm9cIj09KFArXCJcIikuY2hhckF0KDApKXRocm93IGNvbnNvbGUuZGVidWcoXCJVbmtub3duIG9wZXJhdGlvbjogXCIrUCxyKSxQO3MucHVzaChQKTt9fX10Lng9bCx0Lnk9dix0Lm5TdGVtcz1pLHQuaGF2ZVdpZHRoPWgsdC53aWR0aD1kLHQub3Blbj1mO307dmFyIHQ9ZSxhPXtUeXByOnR9O3JldHVybiByLlR5cHI9dCxyLmRlZmF1bHQ9YSxPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyfSh7fSkuVHlwcn1cblxuLyohXG5DdXN0b20gYnVuZGxlIG9mIHdvZmYyb3RmIChodHRwczovL2dpdGh1Yi5jb20vYXJ0eS1uYW1lL3dvZmYyb3RmKSB3aXRoIGZmbGF0ZVxuKGh0dHBzOi8vZ2l0aHViLmNvbS8xMDFhcnJvd3ovZmZsYXRlKSBmb3IgdXNlIGluIFRyb2lrYSB0ZXh0IHJlbmRlcmluZy4gXG5PcmlnaW5hbCBsaWNlbnNlcyBhcHBseTogXG4tIGZmbGF0ZTogaHR0cHM6Ly9naXRodWIuY29tLzEwMWFycm93ei9mZmxhdGUvYmxvYi9tYXN0ZXIvTElDRU5TRSAoTUlUKVxuLSB3b2ZmMm90Zi5qczogaHR0cHM6Ly9naXRodWIuY29tL2FydHktbmFtZS93b2ZmMm90Zi9ibG9iL21hc3Rlci93b2ZmMm90Zi5qcyAoQXBhY2hlMilcbiovXG5mdW5jdGlvbiB3b2ZmMm90ZkZhY3RvcnkoKXtyZXR1cm4gZnVuY3Rpb24ocil7dmFyIGU9VWludDhBcnJheSxuPVVpbnQxNkFycmF5LHQ9VWludDMyQXJyYXksYT1uZXcgZShbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwLDAsMCwwXSksaT1uZXcgZShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxMywwLDBdKSxvPW5ldyBlKFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSksZj1mdW5jdGlvbihyLGUpe2Zvcih2YXIgYT1uZXcgbigzMSksaT0wO2k8MzE7KytpKWFbaV09ZSs9MTw8cltpLTFdO3ZhciBvPW5ldyB0KGFbMzBdKTtmb3IoaT0xO2k8MzA7KytpKWZvcih2YXIgZj1hW2ldO2Y8YVtpKzFdOysrZilvW2ZdPWYtYVtpXTw8NXxpO3JldHVybiBbYSxvXX0sdT1mKGEsMiksdj11WzBdLHM9dVsxXTt2WzI4XT0yNTgsc1syNThdPTI4O2Zvcih2YXIgbD1mKGksMClbMF0sYz1uZXcgbigzMjc2OCksZz0wO2c8MzI3Njg7KytnKXt2YXIgaD0oNDM2OTAmZyk+Pj4xfCgyMTg0NSZnKTw8MTtoPSg2MTY4MCYoaD0oNTI0MjgmaCk+Pj4yfCgxMzEwNyZoKTw8MikpPj4+NHwoMzg1NSZoKTw8NCxjW2ddPSgoNjUyODAmaCk+Pj44fCgyNTUmaCk8PDgpPj4+MTt9dmFyIHc9ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1yLmxlbmd0aCxpPTAsbz1uZXcgbihlKTtpPGE7KytpKSsrb1tyW2ldLTFdO3ZhciBmLHU9bmV3IG4oZSk7Zm9yKGk9MDtpPGU7KytpKXVbaV09dVtpLTFdK29baS0xXTw8MTtpZih0KXtmPW5ldyBuKDE8PGUpO3ZhciB2PTE1LWU7Zm9yKGk9MDtpPGE7KytpKWlmKHJbaV0pZm9yKHZhciBzPWk8PDR8cltpXSxsPWUtcltpXSxnPXVbcltpXS0xXSsrPDxsLGg9Z3woMTw8bCktMTtnPD1oOysrZylmW2NbZ10+Pj52XT1zO31lbHNlIGZvcihmPW5ldyBuKGEpLGk9MDtpPGE7KytpKXJbaV0mJihmW2ldPWNbdVtyW2ldLTFdKytdPj4+MTUtcltpXSk7cmV0dXJuIGZ9LGQ9bmV3IGUoMjg4KTtmb3IoZz0wO2c8MTQ0OysrZylkW2ddPTg7Zm9yKGc9MTQ0O2c8MjU2OysrZylkW2ddPTk7Zm9yKGc9MjU2O2c8MjgwOysrZylkW2ddPTc7Zm9yKGc9MjgwO2c8Mjg4OysrZylkW2ddPTg7dmFyIG09bmV3IGUoMzIpO2ZvcihnPTA7ZzwzMjsrK2cpbVtnXT01O3ZhciBiPXcoZCw5LDEpLHA9dyhtLDUsMSkseT1mdW5jdGlvbihyKXtmb3IodmFyIGU9clswXSxuPTE7bjxyLmxlbmd0aDsrK24pcltuXT5lJiYoZT1yW25dKTtyZXR1cm4gZX0sTD1mdW5jdGlvbihyLGUsbil7dmFyIHQ9ZS84fDA7cmV0dXJuIChyW3RdfHJbdCsxXTw8OCk+Pig3JmUpJm59LFU9ZnVuY3Rpb24ocixlKXt2YXIgbj1lLzh8MDtyZXR1cm4gKHJbbl18cltuKzFdPDw4fHJbbisyXTw8MTYpPj4oNyZlKX0saz1bXCJ1bmV4cGVjdGVkIEVPRlwiLFwiaW52YWxpZCBibG9jayB0eXBlXCIsXCJpbnZhbGlkIGxlbmd0aC9saXRlcmFsXCIsXCJpbnZhbGlkIGRpc3RhbmNlXCIsXCJzdHJlYW0gZmluaXNoZWRcIixcIm5vIHN0cmVhbSBoYW5kbGVyXCIsLFwibm8gY2FsbGJhY2tcIixcImludmFsaWQgVVRGLTggZGF0YVwiLFwiZXh0cmEgZmllbGQgdG9vIGxvbmdcIixcImRhdGUgbm90IGluIHJhbmdlIDE5ODAtMjA5OVwiLFwiZmlsZW5hbWUgdG9vIGxvbmdcIixcInN0cmVhbSBmaW5pc2hpbmdcIixcImludmFsaWQgemlwIGRhdGFcIl0sVD1mdW5jdGlvbihyLGUsbil7dmFyIHQ9bmV3IEVycm9yKGV8fGtbcl0pO2lmKHQuY29kZT1yLEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0LFQpLCFuKXRocm93IHQ7cmV0dXJuIHR9LE89ZnVuY3Rpb24ocixmLHUpe3ZhciBzPXIubGVuZ3RoO2lmKCFzfHx1JiYhdS5sJiZzPDUpcmV0dXJuIGZ8fG5ldyBlKDApO3ZhciBjPSFmfHx1LGc9IXV8fHUuaTt1fHwodT17fSksZnx8KGY9bmV3IGUoMypzKSk7dmFyIGgsZD1mdW5jdGlvbihyKXt2YXIgbj1mLmxlbmd0aDtpZihyPm4pe3ZhciB0PW5ldyBlKE1hdGgubWF4KDIqbixyKSk7dC5zZXQoZiksZj10O319LG09dS5mfHwwLGs9dS5wfHwwLE89dS5ifHwwLEE9dS5sLHg9dS5kLEU9dS5tLEQ9dS5uLE09OCpzO2Rve2lmKCFBKXt1LmY9bT1MKHIsaywxKTt2YXIgUz1MKHIsaysxLDMpO2lmKGsrPTMsIVMpe3ZhciBWPXJbKEk9KChoPWspLzh8MCkrKDcmaCYmMSkrNCktNF18cltJLTNdPDw4LF89SStWO2lmKF8+cyl7ZyYmVCgwKTticmVha31jJiZkKE8rViksZi5zZXQoci5zdWJhcnJheShJLF8pLE8pLHUuYj1PKz1WLHUucD1rPTgqXztjb250aW51ZX1pZigxPT1TKUE9Yix4PXAsRT05LEQ9NTtlbHNlIGlmKDI9PVMpe3ZhciBqPUwocixrLDMxKSsyNTcsej1MKHIsaysxMCwxNSkrNCxDPWorTChyLGsrNSwzMSkrMTtrKz0xNDtmb3IodmFyIEY9bmV3IGUoQyksUD1uZXcgZSgxOSkscT0wO3E8ejsrK3EpUFtvW3FdXT1MKHIsayszKnEsNyk7ays9Myp6O3ZhciBCPXkoUCksRz0oMTw8QiktMSxIPXcoUCxCLDEpO2ZvcihxPTA7cTxDOyl7dmFyIEksSj1IW0wocixrLEcpXTtpZihrKz0xNSZKLChJPUo+Pj40KTwxNilGW3ErK109STtlbHNlIHt2YXIgSz0wLE49MDtmb3IoMTY9PUk/KE49MytMKHIsaywzKSxrKz0yLEs9RltxLTFdKToxNz09ST8oTj0zK0wocixrLDcpLGsrPTMpOjE4PT1JJiYoTj0xMStMKHIsaywxMjcpLGsrPTcpO04tLTspRltxKytdPUs7fX12YXIgUT1GLnN1YmFycmF5KDAsaiksUj1GLnN1YmFycmF5KGopO0U9eShRKSxEPXkoUiksQT13KFEsRSwxKSx4PXcoUixELDEpO31lbHNlIFQoMSk7aWYoaz5NKXtnJiZUKDApO2JyZWFrfX1jJiZkKE8rMTMxMDcyKTtmb3IodmFyIFc9KDE8PEUpLTEsWD0oMTw8RCktMSxZPWs7O1k9ayl7dmFyIFo9KEs9QVtVKHIsaykmV10pPj4+NDtpZigoays9MTUmSyk+TSl7ZyYmVCgwKTticmVha31pZihLfHxUKDIpLFo8MjU2KWZbTysrXT1aO2Vsc2Uge2lmKDI1Nj09Wil7WT1rLEE9bnVsbDticmVha312YXIgJD1aLTI1NDtpZihaPjI2NCl7dmFyIHJyPWFbcT1aLTI1N107JD1MKHIsaywoMTw8cnIpLTEpK3ZbcV0says9cnI7fXZhciBlcj14W1UocixrKSZYXSxucj1lcj4+PjQ7ZXJ8fFQoMyksays9MTUmZXI7Uj1sW25yXTtpZihucj4zKXtycj1pW25yXTtSKz1VKHIsaykmKDE8PHJyKS0xLGsrPXJyO31pZihrPk0pe2cmJlQoMCk7YnJlYWt9YyYmZChPKzEzMTA3Mik7Zm9yKHZhciB0cj1PKyQ7Tzx0cjtPKz00KWZbT109ZltPLVJdLGZbTysxXT1mW08rMS1SXSxmW08rMl09ZltPKzItUl0sZltPKzNdPWZbTyszLVJdO089dHI7fX11Lmw9QSx1LnA9WSx1LmI9TyxBJiYobT0xLHUubT1FLHUuZD14LHUubj1EKTt9d2hpbGUoIW0pO3JldHVybiBPPT1mLmxlbmd0aD9mOmZ1bmN0aW9uKHIsYSxpKXsobnVsbD09YXx8YTwwKSYmKGE9MCksKG51bGw9PWl8fGk+ci5sZW5ndGgpJiYoaT1yLmxlbmd0aCk7dmFyIG89bmV3KHIgaW5zdGFuY2VvZiBuP246ciBpbnN0YW5jZW9mIHQ/dDplKShpLWEpO3JldHVybiBvLnNldChyLnN1YmFycmF5KGEsaSkpLG99KGYsMCxPKX0sQT1uZXcgZSgwKTt2YXIgeD1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXImJm5ldyBUZXh0RGVjb2Rlcjt0cnl7eC5kZWNvZGUoQSx7c3RyZWFtOiEwfSksMTt9Y2F0Y2gocil7fXJldHVybiByLmNvbnZlcnRfc3RyZWFtcz1mdW5jdGlvbihyKXt2YXIgZT1uZXcgRGF0YVZpZXcociksbj0wO2Z1bmN0aW9uIHQoKXt2YXIgcj1lLmdldFVpbnQxNihuKTtyZXR1cm4gbis9MixyfWZ1bmN0aW9uIGEoKXt2YXIgcj1lLmdldFVpbnQzMihuKTtyZXR1cm4gbis9NCxyfWZ1bmN0aW9uIGkocil7bS5zZXRVaW50MTYoYixyKSxiKz0yO31mdW5jdGlvbiBvKHIpe20uc2V0VWludDMyKGIsciksYis9NDt9Zm9yKHZhciBmPXtzaWduYXR1cmU6YSgpLGZsYXZvcjphKCksbGVuZ3RoOmEoKSxudW1UYWJsZXM6dCgpLHJlc2VydmVkOnQoKSx0b3RhbFNmbnRTaXplOmEoKSxtYWpvclZlcnNpb246dCgpLG1pbm9yVmVyc2lvbjp0KCksbWV0YU9mZnNldDphKCksbWV0YUxlbmd0aDphKCksbWV0YU9yaWdMZW5ndGg6YSgpLHByaXZPZmZzZXQ6YSgpLHByaXZMZW5ndGg6YSgpfSx1PTA7TWF0aC5wb3coMix1KTw9Zi5udW1UYWJsZXM7KXUrKzt1LS07Zm9yKHZhciB2PTE2Kk1hdGgucG93KDIsdSkscz0xNipmLm51bVRhYmxlcy12LGw9MTIsYz1bXSxnPTA7ZzxmLm51bVRhYmxlcztnKyspYy5wdXNoKHt0YWc6YSgpLG9mZnNldDphKCksY29tcExlbmd0aDphKCksb3JpZ0xlbmd0aDphKCksb3JpZ0NoZWNrc3VtOmEoKX0pLGwrPTE2O3ZhciBoLHc9bmV3IFVpbnQ4QXJyYXkoMTIrMTYqYy5sZW5ndGgrYy5yZWR1Y2UoKGZ1bmN0aW9uKHIsZSl7cmV0dXJuIHIrZS5vcmlnTGVuZ3RoKzR9KSwwKSksZD13LmJ1ZmZlcixtPW5ldyBEYXRhVmlldyhkKSxiPTA7cmV0dXJuIG8oZi5mbGF2b3IpLGkoZi5udW1UYWJsZXMpLGkodiksaSh1KSxpKHMpLGMuZm9yRWFjaCgoZnVuY3Rpb24ocil7byhyLnRhZyksbyhyLm9yaWdDaGVja3N1bSksbyhsKSxvKHIub3JpZ0xlbmd0aCksci5vdXRPZmZzZXQ9bCwobCs9ci5vcmlnTGVuZ3RoKSU0IT0wJiYobCs9NC1sJTQpO30pKSxjLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuLHQ9ci5zbGljZShlLm9mZnNldCxlLm9mZnNldCtlLmNvbXBMZW5ndGgpO2lmKGUuY29tcExlbmd0aCE9ZS5vcmlnTGVuZ3RoKXt2YXIgYT1uZXcgVWludDhBcnJheShlLm9yaWdMZW5ndGgpO249bmV3IFVpbnQ4QXJyYXkodCwyKSxPKG4sYSk7fWVsc2UgYT1uZXcgVWludDhBcnJheSh0KTt3LnNldChhLGUub3V0T2Zmc2V0KTt2YXIgaT0wOyhsPWUub3V0T2Zmc2V0K2Uub3JpZ0xlbmd0aCklNCE9MCYmKGk9NC1sJTQpLHcuc2V0KG5ldyBVaW50OEFycmF5KGkpLmJ1ZmZlcixlLm91dE9mZnNldCtlLm9yaWdMZW5ndGgpLGg9bCtpO30pKSxkLnNsaWNlKDAsaCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHJ9KHt9KS5jb252ZXJ0X3N0cmVhbXN9XG5cbi8qKlxuICogQSBmYWN0b3J5IHdyYXBwZXIgcGFyc2luZyBhIGZvbnQgZmlsZSB1c2luZyBUeXByLlxuICogQWxzbyBhZGRzIHN1cHBvcnQgZm9yIFdPRkYgZmlsZXMgKG5vdCBXT0ZGMikuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBQYXJzZWRGb250XG4gKiBAcHJvcGVydHkge251bWJlcn0gYXNjZW5kZXJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZXNjZW5kZXJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SGVpZ2h0XG4gKiBAcHJvcGVydHkgeyhudW1iZXIpID0+IGJvb2xlYW59IHN1cHBvcnRzQ29kZVBvaW50XG4gKiBAcHJvcGVydHkgeyh0ZXh0OnN0cmluZywgZm9udFNpemU6bnVtYmVyLCBsZXR0ZXJTcGFjaW5nOm51bWJlciwgY2FsbGJhY2spID0+IG51bWJlcn0gZm9yRWFjaEdseXBoXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZUdhcFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNhcEhlaWdodFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVuaXRzUGVyRW1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoYnVmZmVyOiBBcnJheUJ1ZmZlcikgPT4gUGFyc2VkRm9udH0gRm9udFBhcnNlclxuICovXG5cbi8qKlxuICogQHJldHVybnMge0ZvbnRQYXJzZXJ9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlckZhY3RvcnkoVHlwciwgd29mZjJvdGYpIHtcbiAgY29uc3QgY21kQXJnTGVuZ3RocyA9IHtcbiAgICBNOiAyLFxuICAgIEw6IDIsXG4gICAgUTogNCxcbiAgICBDOiA2LFxuICAgIFo6IDBcbiAgfTtcblxuICAvLyB7am9pblR5cGU6IFwic2tpcCtzdGVwLC4uLlwifVxuICBjb25zdCBqb2luaW5nVHlwZVJhd0RhdGEgPSB7XCJDXCI6XCIxOGcsY2EsMzY4LDFrelwiLFwiRFwiOlwiMTdrLDYsMiwyKzQsNStjLDIrNiwyKzEsMTArMSw5K2YsaisxMSwyKzEsYSwyLDIrMSwxNSsyLDMsaisyLDYrMywyKzgsMiwyLDIrMSx3K2EsNCtlLDMrMywyLDMrMiwzKzUsMjMrdywyZis0LDMsMis5LDIsYiwyKzMsMywxays5LDYrMSwzKzEsMisyLDIrZCwzMGcscCt5LDEsMSsxZyxmK3gsMixzZDIrMWQsamYzKzQsZiszLDIrNCwyKzIsYiszLDQyLDIsNCsyLDIrMSwyLDMsdCsxLDlmK3csMixlbCsyLDIrZyxkKzIsMmwsMisxLDUsMysxLDIrMSwyLDMsNiwxNndtKzF2XCIsXCJSXCI6XCIxN20rMywyLDIsNiszLG0sMTUrMiwyKzIsaCtoLDEzLDMrOCwyLDIsMysxLDIscCsxLHgsNSs0LDUsYSwyLDIsMyx1LGMrMixnKzEsNSwyKzEsNCsxLDVqLDYrMSwyLGIsMisyLGYsMisxLDFzKzIsMiwzKzEsNywxZXowLDIsMisxLDQrNCxiLDQsMyxiLDQyLDIrMiw0LDMsMisxLDIsbyszLGFlLGVwLHgsMm8rMiwzKzEsMyw1KzEsNlwiLFwiTFwiOlwieDl1LGpmZixhLGZkLGp2XCIsXCJUXCI6XCI0dCxnaiszMyw3bys0LDErMSw3YysxOCwyLDIrMSwyKzEsMiwyMSthLDIsMWIrayxoLDJ1KzYsMys1LDMrMSwyKzMseSwyLHYrcSwyaythLDFuKzgsYSxwKzMsMis4LDIrMiwyKzQsMTgrMiwzYytlLDIrdiwxaywyLDUrNyw1LDQrNixiKzEsdSwxbiw1KzMsOSxsKzEsciwzKzEsMW0sNSsxLDUrMSwzKzIsNCx2KzEsNCxjKzEsMW0sNSs0LDIrMSw1LGwrMSxuKzUsMiwxbiwzLDIrMyw5LDgrMSxjKzEsdiwxcSxkLDFmLDQsMW0rMiw2KzIsMiszLDgrMSxjKzEsdSwxbiwzLDcsNisxLGwrMSx0KzEsMW0rMSw1KzMsOSxsKzEsdSwyMSw4KzIsMiwyaiwzKzYsZCs3LDJyLDMrOCxjKzUsMjMrMSxzLDIsMiwxaytkLDIrNCwyKzEsNithLDIreixhLDJ2KzMsMis1LDIrMSwzKzEscSsxLDUrMixoKzMsZSwzKzEsNyxnLGprKzIscWIrMix1KzIsdSsxLHYrMSwxdCsxLDIrNiw5LDMrYSxhLDFhKzIsM2MrMSx6LDNiKzIsNSsxLGEsNysyLDY0KzEsMywxbiwyKzYsMiwyLDMrNyw3KzksMywxZCtkLDEsMSsxLDFzKzMsMWQsMis0LDIsNiwxNSs4LGQrMSx4KzMsMysxLDIrMiwxbCwyKzEsNCwyKzIsMW4rNywzKzEsNDkrMiwyK2MsMis2LDUsNyw0KzEsNWorMWwsMis0LGVrLDMrMSxyKzQsMWUrNCw2KzUsMnArYywxKzMsMSwxKzIsMStiLDJkYisyLDN5LDJwK3YsZmYrMywzMCsxLG45eCwxKzIsMis5LHgrMSwyOSsxLDdsLDQsNSxxKzEsNiw0OCsxLHIraCxlLDEzKzcscSthLDFiKzIsMWQsMyszLDMrMSwxNCwxdys1LDMrMSwzKzEsZCw5LDFjLDFnLDIrMiwzKzEsNisxLDIsMTcrMSw5LDZuLDMsNSxmbjUsa2krZixoK2YsNXMsNnkrMixlYSw2Yiw0Nis0LDFhZisyLDIrMSw2KzMsMTUrMiw1LDRtKzEsZnkrMyxhcysxLDRhK2EsNHgsMWorZSwxbCsyLDFlKzMsMysxLDF5KzIsMTErNCwyKzcsMXIsZCsxLDFoKzgsYiszLDMsMm8rMiwzLDIrMSw3LDRoLDQrNyxtKzEsMW0rMSw0LDEyKzYsNCs0LDVnKzcsMysyLDIsbywyZCs1LDIsNSsxLDIrMSw2biszLDcrMSwyKzEscysxLDJlKzcsMywyKzEsMnosMiwzKzUsMiwydSsyLDMrMywyKzQsNzgrOCwyKzEsNzUrMSwyLDUsNDErMywzKzEsNSx4KzksMTUrNSwzKzMsOSxhKzUsMysyLDFiK2MsMisxLGJiKzYsMis1LDIsMmIrbCwzKzYsMisxLDIrMSwzZis1LDQsMisxLDIrNiwyLDIxKzEsNCwyLDlvKzEsNDcwKzgsYXQ0KzQsMW8rNix0NSwxcyszLDJhLGY1bCsxLDIrMyw0M28rMixhKzcsMSs3LDMrNix2KzMsNDUrMiwxajArMWksNSsxZCw5LGYsbis0LDIrZSwxMXQrNiwyK2csMys2LDIrMSwyKzQsN2ErNixjNiszLDE1dCs2LDMyKzYsMSxnemF1LHYrMm4sM2wrNm5cIn07XG5cbiAgY29uc3QgSlRfTEVGVCA9IDEsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIsIGJ1dCBkb2VzIG5vdCBqb2luIHdpdGggdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIuXG4gICAgSlRfUklHSFQgPSAyLCAvL2luZGljYXRlcyB0aGF0IGEgY2hhcmFjdGVyIGpvaW5zIHdpdGggdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIsIGJ1dCBkb2VzIG5vdCBqb2luIHdpdGggdGhlIHN1YnNlcXVlbnQgY2hhcmFjdGVyLlxuICAgIEpUX0RVQUwgPSA0LCAvL2luZGljYXRlcyB0aGF0IGEgY2hhcmFjdGVyIGpvaW5zIHdpdGggdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIgYW5kIGpvaW5zIHdpdGggdGhlIHN1YnNlcXVlbnQgY2hhcmFjdGVyLlxuICAgIEpUX1RSQU5TUEFSRU5UID0gOCwgLy9pbmRpY2F0ZXMgdGhhdCB0aGUgY2hhcmFjdGVyIGRvZXMgbm90IGpvaW4gd2l0aCBhZGphY2VudCBjaGFyYWN0ZXJzIGFuZCB0aGF0IHRoZSBjaGFyYWN0ZXIgbXVzdCBiZSBza2lwcGVkIG92ZXIgd2hlbiB0aGUgc2hhcGluZyBlbmdpbmUgaXMgZXZhbHVhdGluZyB0aGUgam9pbmluZyBwb3NpdGlvbnMgaW4gYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLiBXaGVuIGEgSlRfVFJBTlNQQVJFTlQgY2hhcmFjdGVyIGlzIGVuY291bnRlcmVkIGluIGEgc2VxdWVuY2UsIHRoZSBKT0lOSU5HX1RZUEUgb2YgdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIgcGFzc2VzIHRocm91Z2guIERpYWNyaXRpY2FsIG1hcmtzIGFyZSBmcmVxdWVudGx5IGFzc2lnbmVkIHRoaXMgdmFsdWUuXG4gICAgSlRfSk9JTl9DQVVTSU5HID0gMTYsIC8vaW5kaWNhdGVzIHRoYXQgdGhlIGNoYXJhY3RlciBmb3JjZXMgdGhlIHVzZSBvZiBqb2luaW5nIGZvcm1zIHdpdGggdGhlIHByZWNlZGluZyBhbmQgc3Vic2VxdWVudCBjaGFyYWN0ZXJzLiBLYXNoaWRhcyBhbmQgdGhlIFplcm8gV2lkdGggSm9pbmVyIChVKzIwMEQpIGFyZSBib3RoIEpPSU5fQ0FVU0lORyBjaGFyYWN0ZXJzLlxuICAgIEpUX05PTl9KT0lOSU5HID0gMzI7IC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgZG9lcyBub3Qgam9pbiB3aXRoIHRoZSBwcmVjZWRpbmcgb3Igd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIuLFxuXG4gIGxldCBqb2luaW5nVHlwZU1hcDtcbiAgZnVuY3Rpb24gZ2V0Q2hhckpvaW5pbmdUeXBlKGNoKSB7XG4gICAgaWYgKCFqb2luaW5nVHlwZU1hcCkge1xuICAgICAgY29uc3QgbSA9IHtcbiAgICAgICAgUjogSlRfUklHSFQsXG4gICAgICAgIEw6IEpUX0xFRlQsXG4gICAgICAgIEQ6IEpUX0RVQUwsXG4gICAgICAgIEM6IEpUX0pPSU5fQ0FVU0lORyxcbiAgICAgICAgVTogSlRfTk9OX0pPSU5JTkcsXG4gICAgICAgIFQ6IEpUX1RSQU5TUEFSRU5UXG4gICAgICB9O1xuICAgICAgam9pbmluZ1R5cGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGxldCB0eXBlIGluIGpvaW5pbmdUeXBlUmF3RGF0YSkge1xuICAgICAgICBsZXQgbGFzdENvZGUgPSAwO1xuICAgICAgICBqb2luaW5nVHlwZVJhd0RhdGFbdHlwZV0uc3BsaXQoJywnKS5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgICAgICBsZXQgW3NraXAsIHN0ZXBdID0gcmFuZ2Uuc3BsaXQoJysnKTtcbiAgICAgICAgICBza2lwID0gcGFyc2VJbnQoc2tpcCwzNik7XG4gICAgICAgICAgc3RlcCA9IHN0ZXAgPyBwYXJzZUludChzdGVwLCAzNikgOiAwO1xuICAgICAgICAgIGpvaW5pbmdUeXBlTWFwLnNldChsYXN0Q29kZSArPSBza2lwLCBtW3R5cGVdKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RlcDsgaS0tOykge1xuICAgICAgICAgICAgam9pbmluZ1R5cGVNYXAuc2V0KCsrbGFzdENvZGUsIG1bdHlwZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqb2luaW5nVHlwZU1hcC5nZXQoY2gpIHx8IEpUX05PTl9KT0lOSU5HXG4gIH1cblxuICBjb25zdCBJU09MID0gMSwgSU5JVCA9IDIsIEZJTkEgPSAzLCBNRURJID0gNDtcbiAgY29uc3QgZm9ybXNUb0ZlYXR1cmVzID0gW251bGwsICdpc29sJywgJ2luaXQnLCAnZmluYScsICdtZWRpJ107XG5cbiAgZnVuY3Rpb24gZGV0ZWN0Sm9pbmluZ0Zvcm1zKHN0cikge1xuICAgIC8vIFRoaXMgaW1wbGVtZW50cyB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBoZXJlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uOHdpbGxpcy9vcGVudHlwZS1zaGFwaW5nLWRvY3VtZW50cy9ibG9iL21hc3Rlci9vcGVudHlwZS1zaGFwaW5nLWFyYWJpYy1nZW5lcmFsLm1kXG4gICAgY29uc3Qgam9pbmluZ0Zvcm1zID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgbGV0IHByZXZKb2luaW5nVHlwZSA9IEpUX05PTl9KT0lOSU5HO1xuICAgIGxldCBwcmV2Rm9ybSA9IElTT0w7XG4gICAgbGV0IHByZXZJbmRleCA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2RlID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgICAgbGV0IGpvaW5pbmdUeXBlID0gZ2V0Q2hhckpvaW5pbmdUeXBlKGNvZGUpIHwgMDtcbiAgICAgIGxldCBmb3JtID0gSVNPTDtcbiAgICAgIGlmIChqb2luaW5nVHlwZSAmIEpUX1RSQU5TUEFSRU5UKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZiAocHJldkpvaW5pbmdUeXBlICYgKEpUX0xFRlQgfCBKVF9EVUFMIHwgSlRfSk9JTl9DQVVTSU5HKSkge1xuICAgICAgICBpZiAoam9pbmluZ1R5cGUgJiAoSlRfUklHSFQgfCBKVF9EVUFMIHwgSlRfSk9JTl9DQVVTSU5HKSkge1xuICAgICAgICAgIGZvcm0gPSBGSU5BO1xuICAgICAgICAgIC8vIGlzb2wtPmluaXQsIGZpbmEtPm1lZGlcbiAgICAgICAgICBpZiAocHJldkZvcm0gPT09IElTT0wgfHwgcHJldkZvcm0gPT09IEZJTkEpIHtcbiAgICAgICAgICAgIGpvaW5pbmdGb3Jtc1twcmV2SW5kZXhdKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpvaW5pbmdUeXBlICYgKEpUX0xFRlQgfCBKVF9OT05fSk9JTklORykpIHtcbiAgICAgICAgICAvLyBtZWRpLT5maW5hLCBpbml0LT5pc29sXG4gICAgICAgICAgaWYgKHByZXZGb3JtID09PSBJTklUIHx8IHByZXZGb3JtID09PSBNRURJKSB7XG4gICAgICAgICAgICBqb2luaW5nRm9ybXNbcHJldkluZGV4XS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAocHJldkpvaW5pbmdUeXBlICYgKEpUX1JJR0hUIHwgSlRfTk9OX0pPSU5JTkcpKSB7XG4gICAgICAgIC8vIG1lZGktPmZpbmEsIGluaXQtPmlzb2xcbiAgICAgICAgaWYgKHByZXZGb3JtID09PSBJTklUIHx8IHByZXZGb3JtID09PSBNRURJKSB7XG4gICAgICAgICAgam9pbmluZ0Zvcm1zW3ByZXZJbmRleF0tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJldkZvcm0gPSBqb2luaW5nRm9ybXNbaV0gPSBmb3JtO1xuICAgICAgcHJldkpvaW5pbmdUeXBlID0gam9pbmluZ1R5cGU7XG4gICAgICBwcmV2SW5kZXggPSBpO1xuICAgICAgaWYgKGNvZGUgPiAweGZmZmYpIGkrKztcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coc3RyLnNwbGl0KCcnKS5tYXAoY2ggPT4gY2guY29kZVBvaW50QXQoMCkudG9TdHJpbmcoMTYpKSlcbiAgICAvLyBjb25zb2xlLmxvZyhzdHIuc3BsaXQoJycpLm1hcChjaCA9PiBnZXRDaGFySm9pbmluZ1R5cGUoY2guY29kZVBvaW50QXQoMCkpKSlcbiAgICAvLyBjb25zb2xlLmxvZyhBcnJheS5mcm9tKGpvaW5pbmdGb3JtcykubWFwKGYgPT4gZm9ybXNUb0ZlYXR1cmVzW2ZdIHx8ICdub25lJykpXG4gICAgcmV0dXJuIGpvaW5pbmdGb3Jtc1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5nVG9HbHlwaHMgKGZvbnQsIHN0cikge1xuICAgIGNvbnN0IGdseXBoSWRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNjID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgICAgaWYgKGNjID4gMHhmZmZmKSBpKys7XG4gICAgICBnbHlwaElkcy5wdXNoKFR5cHIuVS5jb2RlVG9HbHlwaChmb250LCBjYykpO1xuICAgIH1cblxuICAgIGNvbnN0IGdzdWIgPSBmb250WydHU1VCJ107XG4gICAgaWYgKGdzdWIpIHtcbiAgICAgIGNvbnN0IHtsb29rdXBMaXN0LCBmZWF0dXJlTGlzdH0gPSBnc3ViO1xuICAgICAgbGV0IGpvaW5pbmdGb3JtcztcbiAgICAgIGNvbnN0IHN1cHBvcnRlZEZlYXR1cmVzID0gL14ocmxpZ3xsaWdhfG1zZXR8aXNvbHxpbml0fGZpbmF8bWVkaXxoYWxmfHByZXN8Ymx3c3xjY21wKSQvO1xuICAgICAgY29uc3QgdXNlZExvb2t1cHMgPSBbXTtcbiAgICAgIGZlYXR1cmVMaXN0LmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgICAgIGlmIChzdXBwb3J0ZWRGZWF0dXJlcy50ZXN0KGZlYXR1cmUudGFnKSkge1xuICAgICAgICAgIGZvciAobGV0IHRpID0gMDsgdGkgPCBmZWF0dXJlLnRhYi5sZW5ndGg7IHRpKyspIHtcbiAgICAgICAgICAgIGlmICh1c2VkTG9va3Vwc1tmZWF0dXJlLnRhYlt0aV1dKSBjb250aW51ZVxuICAgICAgICAgICAgdXNlZExvb2t1cHNbZmVhdHVyZS50YWJbdGldXSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB0YWIgPSBsb29rdXBMaXN0W2ZlYXR1cmUudGFiW3RpXV07XG4gICAgICAgICAgICBjb25zdCBpc0pvaW5pbmdGZWF0dXJlID0gL14oaXNvbHxpbml0fGZpbmF8bWVkaSkkLy50ZXN0KGZlYXR1cmUudGFnKTtcbiAgICAgICAgICAgIGlmIChpc0pvaW5pbmdGZWF0dXJlICYmICFqb2luaW5nRm9ybXMpIHsgLy9sYXp5XG4gICAgICAgICAgICAgIGpvaW5pbmdGb3JtcyA9IGRldGVjdEpvaW5pbmdGb3JtcyhzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY2kgPSAwOyBjaSA8IGdseXBoSWRzLmxlbmd0aDsgY2krKykge1xuICAgICAgICAgICAgICBpZiAoIWpvaW5pbmdGb3JtcyB8fCAhaXNKb2luaW5nRmVhdHVyZSB8fCBmb3Jtc1RvRmVhdHVyZXNbam9pbmluZ0Zvcm1zW2NpXV0gPT09IGZlYXR1cmUudGFnKSB7XG4gICAgICAgICAgICAgICAgVHlwci5VLl9hcHBseVN1YnMoZ2x5cGhJZHMsIGNpLCB0YWIsIGxvb2t1cExpc3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGhJZHNcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBhZHZhbmNlcyBhbmQgeC95IG9mZnNldHMgZm9yIGVhY2ggZ2x5cGgsIGUuZy4ga2VybmluZyBhbmQgbWFya1xuICAvLyBhdHRhY2htZW50cy4gVGhpcyBpcyBhIG1vcmUgY29tcGxldGUgdmVyc2lvbiBvZiBUeXByLlUuZ2V0UGFpckFkanVzdG1lbnRcbiAgLy8gYW5kIHNob3VsZCBiZWNvbWUgYW4gdXBzdHJlYW0gcmVwbGFjZW1lbnQgZXZlbnR1YWxseS5cbiAgZnVuY3Rpb24gY2FsY0dseXBoUG9zaXRpb25zKGZvbnQsIGdseXBoSWRzKSB7XG4gICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEludDE2QXJyYXkoZ2x5cGhJZHMubGVuZ3RoICogMyk7IC8vIFtvZmZzZXRYLCBvZmZzZXRZLCBhZHZhbmNlWCwgLi4uXVxuICAgIGxldCBnbHlwaEluZGV4ID0gMDtcbiAgICBmb3IgKDsgZ2x5cGhJbmRleCA8IGdseXBoSWRzLmxlbmd0aDsgZ2x5cGhJbmRleCsrKSB7XG4gICAgICBjb25zdCBnbHlwaElkID0gZ2x5cGhJZHNbZ2x5cGhJbmRleF07XG4gICAgICBpZiAoZ2x5cGhJZCA9PT0gLTEpIGNvbnRpbnVlO1xuXG4gICAgICBwb3NpdGlvbnNbZ2x5cGhJbmRleCAqIDMgKyAyXSA9IGZvbnQuaG10eC5hV2lkdGhbZ2x5cGhJZF07IC8vIHBvcHVsYXRlIGFkdmFuY2VYIGluLi4uYWR2YW5jZS5cblxuICAgICAgY29uc3QgZ3BvcyA9IGZvbnQuR1BPUztcbiAgICAgIGlmIChncG9zKSB7XG4gICAgICAgIGNvbnN0IGxsaXN0ID0gZ3Bvcy5sb29rdXBMaXN0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbG9va3VwID0gbGxpc3RbaV07XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb29rdXAudGFicy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgdGFiID0gbG9va3VwLnRhYnNbal07XG4gICAgICAgICAgICAvLyBTaW5nbGUgY2hhciBwbGFjZW1lbnRcbiAgICAgICAgICAgIGlmIChsb29rdXAubHR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgY29uc3QgaW5kID0gVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRhYi5jb3ZlcmFnZSwgZ2x5cGhJZCk7XG4gICAgICAgICAgICAgIGlmIChpbmQgIT09IC0xICYmIHRhYi5wb3MpIHtcbiAgICAgICAgICAgICAgICBhcHBseVZhbHVlUmVjb3JkKHRhYi5wb3MsIGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhaXJzIChrZXJuaW5nKVxuICAgICAgICAgICAgZWxzZSBpZiAobG9va3VwLmx0eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgIGxldCBhZGogPSBudWxsO1xuICAgICAgICAgICAgICBsZXQgcHJldkdseXBoSW5kZXggPSBnZXRQcmV2R2x5cGhJbmRleCgpO1xuICAgICAgICAgICAgICBpZiAocHJldkdseXBoSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY292ZXJhZ2VJbmRleCA9IFR5cHIuX2xjdGYuY292ZXJhZ2VJbmRleCh0YWIuY292ZXJhZ2UsIGdseXBoSWRzW3ByZXZHbHlwaEluZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvdmVyYWdlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGFiLmZtdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IHRhYi5wYWlyc2V0c1tjb3ZlcmFnZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByaWdodC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodFtrXS5naWQyID09PSBnbHlwaElkKSBhZGogPSByaWdodFtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWIuZm10ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMxID0gVHlwci5VLl9nZXRHbHlwaENsYXNzKGdseXBoSWRzW3ByZXZHbHlwaEluZGV4XSwgdGFiLmNsYXNzRGVmMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMyID0gVHlwci5VLl9nZXRHbHlwaENsYXNzKGdseXBoSWQsIHRhYi5jbGFzc0RlZjIpO1xuICAgICAgICAgICAgICAgICAgICBhZGogPSB0YWIubWF0cml4W2MxXVtjMl07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoYWRqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGoudmFsMSkgYXBwbHlWYWx1ZVJlY29yZChhZGoudmFsMSwgcHJldkdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRqLnZhbDIpIGFwcGx5VmFsdWVSZWNvcmQoYWRqLnZhbDIsIGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFyayB0byBiYXNlXG4gICAgICAgICAgICBlbHNlIGlmIChsb29rdXAubHR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWFya0FyckluZGV4ID0gVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRhYi5tYXJrQ292ZXJhZ2UsIGdseXBoSWQpO1xuICAgICAgICAgICAgICBpZiAobWFya0FyckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VHbHlwaEluZGV4ID0gZ2V0UHJldkdseXBoSW5kZXgoaXNCYXNlR2x5cGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VBcnJJbmRleCA9IGJhc2VHbHlwaEluZGV4ID09PSAtMSA/IC0xIDogVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRhYi5iYXNlQ292ZXJhZ2UsIGdseXBoSWRzW2Jhc2VHbHlwaEluZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VBcnJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtSZWNvcmQgPSB0YWIubWFya0FycmF5W21hcmtBcnJJbmRleF07XG4gICAgICAgICAgICAgICAgICBjb25zdCBiYXNlQW5jaG9yID0gdGFiLmJhc2VBcnJheVtiYXNlQXJySW5kZXhdW21hcmtSZWNvcmQubWFya0NsYXNzXTtcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tnbHlwaEluZGV4ICogM10gPSBiYXNlQW5jaG9yLnggLSBtYXJrUmVjb3JkLnggKyBwb3NpdGlvbnNbYmFzZUdseXBoSW5kZXggKiAzXSAtIHBvc2l0aW9uc1tiYXNlR2x5cGhJbmRleCAqIDMgKyAyXTtcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tnbHlwaEluZGV4ICogMyArIDFdID0gYmFzZUFuY2hvci55IC0gbWFya1JlY29yZC55ICsgcG9zaXRpb25zW2Jhc2VHbHlwaEluZGV4ICogMyArIDFdO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYXJrIHRvIG1hcmtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvb2t1cC5sdHlwZSA9PT0gNikge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrMUFyckluZGV4ID0gVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRhYi5tYXJrMUNvdmVyYWdlLCBnbHlwaElkKTtcbiAgICAgICAgICAgICAgaWYgKG1hcmsxQXJySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkdseXBoSW5kZXggPSBnZXRQcmV2R2x5cGhJbmRleCgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2R2x5cGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZHbHlwaElkID0gZ2x5cGhJZHNbcHJldkdseXBoSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgaWYgKGdldEdseXBoQ2xhc3MoZm9udCwgcHJldkdseXBoSWQpID09PSAzKSB7IC8vIG9ubHkgY2hlY2sgbWFyayBnbHlwaHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFyazJBcnJJbmRleCA9IFR5cHIuX2xjdGYuY292ZXJhZ2VJbmRleCh0YWIubWFyazJDb3ZlcmFnZSwgcHJldkdseXBoSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFyazJBcnJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrMVJlY29yZCA9IHRhYi5tYXJrMUFycmF5W21hcmsxQXJySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmsyQW5jaG9yID0gdGFiLm1hcmsyQXJyYXlbbWFyazJBcnJJbmRleF1bbWFyazFSZWNvcmQubWFya0NsYXNzXTtcbiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbZ2x5cGhJbmRleCAqIDNdID0gbWFyazJBbmNob3IueCAtIG1hcmsxUmVjb3JkLnggKyBwb3NpdGlvbnNbcHJldkdseXBoSW5kZXggKiAzXSAtIHBvc2l0aW9uc1twcmV2R2x5cGhJbmRleCAqIDMgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbZ2x5cGhJbmRleCAqIDMgKyAxXSA9IG1hcmsyQW5jaG9yLnkgLSBtYXJrMVJlY29yZC55ICsgcG9zaXRpb25zW3ByZXZHbHlwaEluZGV4ICogMyArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBrZXJuIHRhYmxlIGlmIG5vIEdQT1NcbiAgICAgIGVsc2UgaWYgKGZvbnQua2VybiAmJiAhZm9udC5jZmYpIHtcbiAgICAgICAgY29uc3QgcHJldkdseXBoSW5kZXggPSBnZXRQcmV2R2x5cGhJbmRleCgpO1xuICAgICAgICBpZiAocHJldkdseXBoSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgaW5kMSA9IGZvbnQua2Vybi5nbHlwaDEuaW5kZXhPZihnbHlwaElkc1twcmV2R2x5cGhJbmRleF0pO1xuICAgICAgICAgIGlmIChpbmQxICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgaW5kMiA9IGZvbnQua2Vybi5ydmFsW2luZDFdLmdseXBoMi5pbmRleE9mKGdseXBoSWQpO1xuICAgICAgICAgICAgaWYgKGluZDIgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uc1twcmV2R2x5cGhJbmRleCAqIDMgKyAyXSArPSBmb250Lmtlcm4ucnZhbFtpbmQxXS52YWxzW2luZDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwb3NpdGlvbnM7XG5cbiAgICBmdW5jdGlvbiBnZXRQcmV2R2x5cGhJbmRleChmaWx0ZXIpIHtcbiAgICAgIGZvciAobGV0IGkgPSBnbHlwaEluZGV4IC0gMTsgaSA+PTA7IGktLSkge1xuICAgICAgICBpZiAoZ2x5cGhJZHNbaV0gIT09IC0xICYmICghZmlsdGVyIHx8IGZpbHRlcihnbHlwaElkc1tpXSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmFzZUdseXBoKGdseXBoSWQpIHtcbiAgICAgIHJldHVybiBnZXRHbHlwaENsYXNzKGZvbnQsIGdseXBoSWQpID09PSAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VmFsdWVSZWNvcmQoc291cmNlLCBnaSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgcG9zaXRpb25zW2dpICogMyArIGldICs9IHNvdXJjZVtpXSB8fCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEdseXBoQ2xhc3MoZm9udCwgZ2x5cGhJZCkge1xuICAgIGNvbnN0IGNsYXNzRGVmID0gZm9udC5HREVGICYmIGZvbnQuR0RFRi5nbHlwaENsYXNzRGVmO1xuICAgIHJldHVybiBjbGFzc0RlZiA/IFR5cHIuVS5fZ2V0R2x5cGhDbGFzcyhnbHlwaElkLCBjbGFzc0RlZikgOiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyc3ROdW0oLi4uYXJncykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gYXJnc1tpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBQYXJzZWRGb250XG4gICAqL1xuICBmdW5jdGlvbiB3cmFwRm9udE9iaih0eXByRm9udCkge1xuICAgIGNvbnN0IGdseXBoTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGNvbnN0IG9zMiA9IHR5cHJGb250WydPUy8yJ107XG4gICAgY29uc3QgaGhlYSA9IHR5cHJGb250LmhoZWE7XG4gICAgY29uc3QgdW5pdHNQZXJFbSA9IHR5cHJGb250LmhlYWQudW5pdHNQZXJFbTtcbiAgICBjb25zdCBhc2NlbmRlciA9IGZpcnN0TnVtKG9zMiAmJiBvczIuc1R5cG9Bc2NlbmRlciwgaGhlYSAmJiBoaGVhLmFzY2VuZGVyLCB1bml0c1BlckVtKTtcblxuICAgIC8qKiBAdHlwZSBQYXJzZWRGb250ICovXG4gICAgY29uc3QgZm9udE9iaiA9IHtcbiAgICAgIHVuaXRzUGVyRW0sXG4gICAgICBhc2NlbmRlcixcbiAgICAgIGRlc2NlbmRlcjogZmlyc3ROdW0ob3MyICYmIG9zMi5zVHlwb0Rlc2NlbmRlciwgaGhlYSAmJiBoaGVhLmRlc2NlbmRlciwgMCksXG4gICAgICBjYXBIZWlnaHQ6IGZpcnN0TnVtKG9zMiAmJiBvczIuc0NhcEhlaWdodCwgYXNjZW5kZXIpLFxuICAgICAgeEhlaWdodDogZmlyc3ROdW0ob3MyICYmIG9zMi5zeEhlaWdodCwgYXNjZW5kZXIpLFxuICAgICAgbGluZUdhcDogZmlyc3ROdW0ob3MyICYmIG9zMi5zVHlwb0xpbmVHYXAsIGhoZWEgJiYgaGhlYS5saW5lR2FwKSxcbiAgICAgIHN1cHBvcnRzQ29kZVBvaW50KGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIFR5cHIuVS5jb2RlVG9HbHlwaCh0eXByRm9udCwgY29kZSkgPiAwXG4gICAgICB9LFxuICAgICAgZm9yRWFjaEdseXBoKHRleHQsIGZvbnRTaXplLCBsZXR0ZXJTcGFjaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgcGVuWCA9IDA7XG4gICAgICAgIGNvbnN0IGZvbnRTY2FsZSA9IDEgLyBmb250T2JqLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcblxuICAgICAgICBjb25zdCBnbHlwaElkcyA9IHN0cmluZ1RvR2x5cGhzKHR5cHJGb250LCB0ZXh0KTtcbiAgICAgICAgbGV0IGNoYXJJbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IGNhbGNHbHlwaFBvc2l0aW9ucyh0eXByRm9udCwgZ2x5cGhJZHMpO1xuXG4gICAgICAgIGdseXBoSWRzLmZvckVhY2goKGdseXBoSWQsIGkpID0+IHtcbiAgICAgICAgICAvLyBUeXByIHJldHVybnMgYSBnbHlwaCBpbmRleCBwZXIgc3RyaW5nIGNvZGVwb2ludCwgd2l0aCAtMXMgaW4gcGxhY2Ugb2YgdGhvc2UgdGhhdFxuICAgICAgICAgIC8vIHdlcmUgb21pdHRlZCBkdWUgdG8gbGlnYXR1cmUgc3Vic3RpdHV0aW9uLiBTbyB3ZSBjYW4gdHJhY2sgb3JpZ2luYWwgaW5kZXggaW4gdGhlXG4gICAgICAgICAgLy8gc3RyaW5nIHZpYSBzaW1wbGUgaW5jcmVtZW50LCBhbmQgc2tpcCBldmVyeXRoaW5nIGVsc2Ugd2hlbiBzZWVpbmcgYSAtMS5cbiAgICAgICAgICBpZiAoZ2x5cGhJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBnbHlwaE9iaiA9IGdseXBoTWFwW2dseXBoSWRdO1xuICAgICAgICAgICAgaWYgKCFnbHlwaE9iaikge1xuICAgICAgICAgICAgICBjb25zdCB7Y21kcywgY3Jkc30gPSBUeXByLlUuZ2x5cGhUb1BhdGgodHlwckZvbnQsIGdseXBoSWQpO1xuXG4gICAgICAgICAgICAgIC8vIEJ1aWxkIHBhdGggc3RyaW5nXG4gICAgICAgICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgICAgICAgIGxldCBjcmRzSWR4ID0gMDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNtZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1BcmdzID0gY21kQXJnTGVuZ3Roc1tjbWRzW2ldXTtcbiAgICAgICAgICAgICAgICBwYXRoICs9IGNtZHNbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPD0gbnVtQXJnczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBwYXRoICs9IChqID4gMSA/ICcsJyA6ICcnKSArIGNyZHNbY3Jkc0lkeCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBGaW5kIGV4dGVudHMgLSBHbHlmIGdpdmVzIHRoaXMgaW4gbWV0YWRhdGEgYnV0IG5vdCBDRkYsIGFuZCBUeXByIGRvZXNuJ3RcbiAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIHRoZSB0d28sIHNvIGl0J3Mgc2ltcGxlc3QganVzdCB0byBpdGVyYXRlIG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgbGV0IHhNaW4sIHlNaW4sIHhNYXgsIHlNYXg7XG4gICAgICAgICAgICAgIGlmIChjcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHhNaW4gPSB5TWluID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgeE1heCA9IHlNYXggPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNyZHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgIGxldCB4ID0gY3Jkc1tpXTtcbiAgICAgICAgICAgICAgICAgIGxldCB5ID0gY3Jkc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICBpZiAoeCA8IHhNaW4pIHhNaW4gPSB4O1xuICAgICAgICAgICAgICAgICAgaWYgKHkgPCB5TWluKSB5TWluID0geTtcbiAgICAgICAgICAgICAgICAgIGlmICh4ID4geE1heCkgeE1heCA9IHg7XG4gICAgICAgICAgICAgICAgICBpZiAoeSA+IHlNYXgpIHlNYXggPSB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4TWluID0geE1heCA9IHlNaW4gPSB5TWF4ID0gMDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdseXBoT2JqID0gZ2x5cGhNYXBbZ2x5cGhJZF0gPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGdseXBoSWQsXG4gICAgICAgICAgICAgICAgYWR2YW5jZVdpZHRoOiB0eXByRm9udC5obXR4LmFXaWR0aFtnbHlwaElkXSxcbiAgICAgICAgICAgICAgICB4TWluLFxuICAgICAgICAgICAgICAgIHlNaW4sXG4gICAgICAgICAgICAgICAgeE1heCxcbiAgICAgICAgICAgICAgICB5TWF4LFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGdseXBoT2JqLFxuICAgICAgICAgICAgICBwZW5YICsgcG9zaXRpb25zW2kgKiAzXSAqIGZvbnRTY2FsZSxcbiAgICAgICAgICAgICAgcG9zaXRpb25zW2kgKiAzICsgMV0gKiBmb250U2NhbGUsXG4gICAgICAgICAgICAgIGNoYXJJbmRleFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcGVuWCArPSBwb3NpdGlvbnNbaSAqIDMgKyAyXSAqIGZvbnRTY2FsZTtcbiAgICAgICAgICAgIGlmIChsZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgICAgICAgIHBlblggKz0gbGV0dGVyU3BhY2luZyAqIGZvbnRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjaGFySW5kZXggKz0gKHRleHQuY29kZVBvaW50QXQoY2hhckluZGV4KSA+IDB4ZmZmZiA/IDIgOiAxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBlblhcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZvbnRPYmpcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSBGb250UGFyc2VyXG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gcGFyc2UoYnVmZmVyKSB7XG4gICAgLy8gTG9vayB0byBzZWUgaWYgd2UgaGF2ZSBhIFdPRkYgZmlsZSBhbmQgY29udmVydCBpdCBpZiBzbzpcbiAgICBjb25zdCBwZWVrID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCA0KTtcbiAgICBjb25zdCB0YWcgPSBUeXByLl9iaW4ucmVhZEFTQ0lJKHBlZWssIDAsIDQpO1xuICAgIGlmICh0YWcgPT09ICd3T0ZGJykge1xuICAgICAgYnVmZmVyID0gd29mZjJvdGYoYnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3dPRjInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvZmYyIGZvbnRzIG5vdCBzdXBwb3J0ZWQnKVxuICAgIH1cbiAgICByZXR1cm4gd3JhcEZvbnRPYmooVHlwci5wYXJzZShidWZmZXIpWzBdKVxuICB9XG59XG5cblxuY29uc3Qgd29ya2VyTW9kdWxlID0gLyojX19QVVJFX18qL2RlZmluZVdvcmtlck1vZHVsZSh7XG4gIG5hbWU6ICdUeXByIEZvbnQgUGFyc2VyJyxcbiAgZGVwZW5kZW5jaWVzOiBbdHlwckZhY3RvcnksIHdvZmYyb3RmRmFjdG9yeSwgcGFyc2VyRmFjdG9yeV0sXG4gIGluaXQodHlwckZhY3RvcnksIHdvZmYyb3RmRmFjdG9yeSwgcGFyc2VyRmFjdG9yeSkge1xuICAgIGNvbnN0IFR5cHIgPSB0eXByRmFjdG9yeSgpO1xuICAgIGNvbnN0IHdvZmYyb3RmID0gd29mZjJvdGZGYWN0b3J5KCk7XG4gICAgcmV0dXJuIHBhcnNlckZhY3RvcnkoVHlwciwgd29mZjJvdGYpXG4gIH1cbn0pO1xuXG4vKiFcbkN1c3RvbSBidW5kbGUgb2YgQHVuaWNvZGUtZm9udC1yZXNvbHZlci9jbGllbnQgdjEuMC4yIChodHRwczovL2dpdGh1Yi5jb20vbG9qamljL3VuaWNvZGUtZm9udC1yZXNvbHZlcilcbmZvciB1c2UgaW4gVHJvaWthIHRleHQgcmVuZGVyaW5nLiBcbk9yaWdpbmFsIE1JVCBsaWNlbnNlIGFwcGxpZXNcbiovXG5mdW5jdGlvbiB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50RmFjdG9yeSgpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgbj1mdW5jdGlvbigpe3RoaXMuYnVja2V0cz1uZXcgTWFwO307bi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3ZhciBuPXQ+PjU7dGhpcy5idWNrZXRzLnNldChuLCh0aGlzLmJ1Y2tldHMuZ2V0KG4pfHwwKXwxPDwoMzEmdCkpO30sbi5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMuYnVja2V0cy5nZXQodD4+NSk7cmV0dXJuIHZvaWQgMCE9PW4mJjAhPShuJjE8PCgzMSZ0KSl9LG4ucHJvdG90eXBlLnNlcmlhbGl6ZT1mdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0aGlzLmJ1Y2tldHMuZm9yRWFjaCgoZnVuY3Rpb24obixyKXt0LnB1c2goKCtyKS50b1N0cmluZygzNikrXCI6XCIrbi50b1N0cmluZygzNikpO30pKSx0LmpvaW4oXCIsXCIpfSxuLnByb3RvdHlwZS5kZXNlcmlhbGl6ZT1mdW5jdGlvbih0KXt2YXIgbj10aGlzO3RoaXMuYnVja2V0cy5jbGVhcigpLHQuc3BsaXQoXCIsXCIpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciByPXQuc3BsaXQoXCI6XCIpO24uYnVja2V0cy5zZXQocGFyc2VJbnQoclswXSwzNikscGFyc2VJbnQoclsxXSwzNikpO30pKTt9O3ZhciByPU1hdGgucG93KDIsOCksZT1yLTEsbz1+ZTtmdW5jdGlvbiBhKHQpe3ZhciBuPWZ1bmN0aW9uKHQpe3JldHVybiB0Jm99KHQpLnRvU3RyaW5nKDE2KSxlPWZ1bmN0aW9uKHQpe3JldHVybiAodCZvKStyLTF9KHQpLnRvU3RyaW5nKDE2KTtyZXR1cm4gXCJjb2RlcG9pbnQtaW5kZXgvcGxhbmVcIisodD4+MTYpK1wiL1wiK24rXCItXCIrZStcIi5qc29uXCJ9ZnVuY3Rpb24gaSh0LG4pe3ZhciByPXQmZSxvPW4uY29kZVBvaW50QXQoci82fDApO3JldHVybiAwIT0oKG89KG98fDQ4KS00OCkmMTw8ciU2KX1mdW5jdGlvbiB1KHQsbil7dmFyIHI7KHI9dCxyLnJlcGxhY2UoL1VcXCsvZ2ksXCJcIikucmVwbGFjZSgvXiwrfCwrJC9nLFwiXCIpLnNwbGl0KC8sKy8pLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3BsaXQoXCItXCIpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHBhcnNlSW50KHQudHJpbSgpLDE2KX0pKX0pKSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIHI9dFswXSxlPXRbMV07dm9pZCAwPT09ZSYmKGU9ciksbihyLGUpO30pKTt9ZnVuY3Rpb24gYyh0LG4pe3UodCwoZnVuY3Rpb24odCxyKXtmb3IodmFyIGU9dDtlPD1yO2UrKyluKGUpO30pKTt9dmFyIHM9e30sZj17fSxsPW5ldyBXZWFrTWFwLHY9XCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvZ2gvbG9qamljL3VuaWNvZGUtZm9udC1yZXNvbHZlckB2MS4wLjEvcGFja2FnZXMvZGF0YVwiO2Z1bmN0aW9uIGQodCl7dmFyIHI9bC5nZXQodCk7cmV0dXJuIHJ8fChyPW5ldyBuLGModC5yYW5nZXMsKGZ1bmN0aW9uKHQpe3JldHVybiByLmFkZCh0KX0pKSxsLnNldCh0LHIpKSxyfXZhciBoLHA9bmV3IE1hcDtmdW5jdGlvbiBnKHQsbixyKXtyZXR1cm4gdFtuXT9uOnRbcl0/cjpmdW5jdGlvbih0KXtmb3IodmFyIG4gaW4gdClyZXR1cm4gbn0odCl9ZnVuY3Rpb24gdyh0LG4pe3ZhciByPW47aWYoIXQuaW5jbHVkZXMocikpe3I9MS8wO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKU1hdGguYWJzKHRbZV0tbik8TWF0aC5hYnMoci1uKSYmKHI9dFtlXSk7fXJldHVybiByfWZ1bmN0aW9uIGsodCl7cmV0dXJuIGh8fChoPW5ldyBTZXQsYyhcIjktRCwyMCw4NSxBMCwxNjgwLDIwMDAtMjAwQSwyMDI4LTIwMkYsMjA1RiwzMDAwXCIsKGZ1bmN0aW9uKHQpe2guYWRkKHQpO30pKSksaC5oYXModCl9cmV0dXJuIHQuQ29kZVBvaW50U2V0PW4sdC5jbGVhckNhY2hlPWZ1bmN0aW9uKCl7cz17fSxmPXt9O30sdC5nZXRGb250c0ZvclN0cmluZz1mdW5jdGlvbih0LG4pe3ZvaWQgMD09PW4mJihuPXt9KTt2YXIgcixlPW4ubGFuZzt2b2lkIDA9PT1lJiYoZT0vXFxwe1NjcmlwdD1IYW5ndWx9L3UudGVzdChyPXQpP1wia29cIjovXFxwe1NjcmlwdD1IaXJhZ2FuYX18XFxwe1NjcmlwdD1LYXRha2FuYX0vdS50ZXN0KHIpP1wiamFcIjpcImVuXCIpO3ZhciBvPW4uY2F0ZWdvcnk7dm9pZCAwPT09byYmKG89XCJzYW5zLXNlcmlmXCIpO3ZhciB1PW4uc3R5bGU7dm9pZCAwPT09dSYmKHU9XCJub3JtYWxcIik7dmFyIGM9bi53ZWlnaHQ7dm9pZCAwPT09YyYmKGM9NDAwKTt2YXIgbD0obi5kYXRhVXJsfHx2KS5yZXBsYWNlKC9cXC8kL2csXCJcIiksaD1uZXcgTWFwLHk9bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpLGI9e30sbT17fSxBPW5ldyBBcnJheSh0Lmxlbmd0aCksUz1uZXcgTWFwLGo9ITE7ZnVuY3Rpb24gTSh0KXt2YXIgbj1wLmdldCh0KTtyZXR1cm4gbnx8KG49ZmV0Y2gobCtcIi9cIit0KS50aGVuKChmdW5jdGlvbih0KXtpZighdC5vayl0aHJvdyBuZXcgRXJyb3IodC5zdGF0dXNUZXh0KTtyZXR1cm4gdC5qc29uKCkudGhlbigoZnVuY3Rpb24odCl7aWYoIUFycmF5LmlzQXJyYXkodCl8fDEhPT10WzBdKXRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBzY2hlbWEgdmVyc2lvbjsgbmVlZCAxLCBnb3QgXCIrdFswXSk7cmV0dXJuIHRbMV19KSl9KSkuY2F0Y2goKGZ1bmN0aW9uKG4pe2lmKGwhPT12KXJldHVybiBqfHwoY29uc29sZS5lcnJvcigndW5pY29kZS1mb250LXJlc29sdmVyOiBGYWlsZWQgbG9hZGluZyBmcm9tIGRhdGFVcmwgXCInK2wrJ1wiLCB0cnlpbmcgZGVmYXVsdCBDRE4uICcrbi5tZXNzYWdlKSxqPSEwKSxsPXYscC5kZWxldGUodCksTSh0KTt0aHJvdyBufSkpLHAuc2V0KHQsbikpLG59Zm9yKHZhciBQPWZ1bmN0aW9uKG4pe3ZhciByPXQuY29kZVBvaW50QXQobiksZT1hKHIpO0Fbbl09ZSxzW2VdfHxTLmhhcyhlKXx8Uy5zZXQoZSxNKGUpLnRoZW4oKGZ1bmN0aW9uKHQpe3NbZV09dDt9KSkpLHI+NjU1MzUmJihuKyssRT1uKTt9LEU9MDtFPHQubGVuZ3RoO0UrKylQKEUpO3JldHVybiBQcm9taXNlLmFsbChTLnZhbHVlcygpKS50aGVuKChmdW5jdGlvbigpe1MuY2xlYXIoKTtmb3IodmFyIG49ZnVuY3Rpb24obil7dmFyIG89dC5jb2RlUG9pbnRBdChuKSxhPW51bGwsdT1zW0Fbbl1dLGM9dm9pZCAwO2Zvcih2YXIgbCBpbiB1KXt2YXIgdj1tW2xdO2lmKHZvaWQgMD09PXYmJih2PW1bbF09bmV3IFJlZ0V4cChsKS50ZXN0KGV8fFwiZW5cIikpLHYpe2Zvcih2YXIgZCBpbiBjPWwsdVtsXSlpZihpKG8sdVtsXVtkXSkpe2E9ZDticmVha31icmVha319aWYoIWEpdDpmb3IodmFyIGggaW4gdSlpZihoIT09Yylmb3IodmFyIHAgaW4gdVtoXSlpZihpKG8sdVtoXVtwXSkpe2E9cDticmVhayB0fWF8fChjb25zb2xlLmRlYnVnKFwiTm8gZm9udCBjb3ZlcmFnZSBmb3IgVStcIitvLnRvU3RyaW5nKDE2KSksYT1cImxhdGluXCIpLEFbbl09YSxmW2FdfHxTLmhhcyhhKXx8Uy5zZXQoYSxNKFwiZm9udC1tZXRhL1wiK2ErXCIuanNvblwiKS50aGVuKChmdW5jdGlvbih0KXtmW2FdPXQ7fSkpKSxvPjY1NTM1JiYobisrLHI9bik7fSxyPTA7cjx0Lmxlbmd0aDtyKyspbihyKTtyZXR1cm4gUHJvbWlzZS5hbGwoUy52YWx1ZXMoKSl9KSkudGhlbigoZnVuY3Rpb24oKXtmb3IodmFyIG4scj1udWxsLGU9MDtlPHQubGVuZ3RoO2UrKyl7dmFyIGE9dC5jb2RlUG9pbnRBdChlKTtpZihyJiYoayhhKXx8ZChyKS5oYXMoYSkpKXlbZV09eVtlLTFdO2Vsc2Uge3I9ZltBW2VdXTt2YXIgaT1iW3IuaWRdO2lmKCFpKXt2YXIgcz1yLnR5cGVmb3Jtcyx2PWcocyxvLFwic2Fucy1zZXJpZlwiKSxwPWcoc1t2XSx1LFwibm9ybWFsXCIpLG09dyhudWxsPT09KG49c1t2XSl8fHZvaWQgMD09PW4/dm9pZCAwOm5bcF0sYyk7aT1iW3IuaWRdPWwrXCIvZm9udC1maWxlcy9cIityLmlkK1wiL1wiK3YrXCIuXCIrcCtcIi5cIittK1wiLndvZmZcIjt9dmFyIFM9aC5nZXQoaSk7bnVsbD09UyYmKFM9aC5zaXplLGguc2V0KGksUykpLHlbZV09Uzt9YT42NTUzNSYmKGUrKyx5W2VdPXlbZS0xXSk7fXJldHVybiB7Zm9udFVybHM6QXJyYXkuZnJvbShoLmtleXMoKSksY2hhcnM6eX19KSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHR9KHt9KX1cblxuLyoqXG4gKiBAdHlwZWRlZiB7c3RyaW5nIHwge3NyYzpzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIHVuaWNvZGVSYW5nZT86c3RyaW5nLCBsYW5nPzpzdHJpbmd9fSBVc2VyRm9udFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0NsaWVudE9wdGlvbnN9IEZvbnRSZXNvbHZlck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8VXNlckZvbnQ+fFVzZXJGb250fSBbZm9udHNdXG4gKiBAcHJvcGVydHkgeydub3JtYWwnfCdpdGFsaWMnfSBbc3R5bGVdXG4gKiBAcHJvcGVydHkgeydub3JtYWwnfCdib2xkJ3xudW1iZXJ9IFtzdHlsZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdW5pY29kZUZvbnRzVVJMXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRm9udFJlc29sdmVyUmVzdWx0XG4gKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IGNoYXJzXG4gKiBAcHJvcGVydHkge0FycmF5PFBhcnNlZEZvbnQgJiB7c3JjOnN0cmluZ30+fSBmb250c1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9ufSBGb250UmVzb2x2ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0geyhGb250UmVzb2x2ZXJSZXN1bHQpID0+IHZvaWR9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0ZvbnRSZXNvbHZlck9wdGlvbnN9IFtvcHRpb25zXVxuICovXG5cbi8qKlxuICogRmFjdG9yeSBmb3IgdGhlIEZvbnRSZXNvbHZlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Rm9udFBhcnNlcn0gZm9udFBhcnNlclxuICogQHBhcmFtIHt7Z2V0Rm9udHNGb3JTdHJpbmc6IGZ1bmN0aW9uLCBDb2RlUG9pbnRTZXQ6IGZ1bmN0aW9ufX0gdW5pY29kZUZvbnRSZXNvbHZlckNsaWVudFxuICogQHJldHVybiB7Rm9udFJlc29sdmVyfVxuICovXG5mdW5jdGlvbiBjcmVhdGVGb250UmVzb2x2ZXIoZm9udFBhcnNlciwgdW5pY29kZUZvbnRSZXNvbHZlckNsaWVudCkge1xuICAvKipcbiAgICogQHR5cGUge1JlY29yZDxzdHJpbmcsIFBhcnNlZEZvbnQ+fVxuICAgKi9cbiAgY29uc3QgcGFyc2VkRm9udHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgQXJyYXk8KFBhcnNlZEZvbnQpID0+IHZvaWQ+Pn1cbiAgICovXG4gIGNvbnN0IGxvYWRpbmdGb250cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLyoqXG4gICAqIExvYWQgYSBnaXZlbiBmb250IHVybFxuICAgKi9cbiAgZnVuY3Rpb24gZG9Mb2FkRm9udCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgb25FcnJvciA9IGVyciA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsdXJlIGxvYWRpbmcgZm9udCAke3VybH1gLCBlcnIpO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHJlcXVlc3Qub3BlbignZ2V0JywgdXJsLCB0cnVlKTtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgb25FcnJvcihuZXcgRXJyb3IocmVxdWVzdC5zdGF0dXNUZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPiAwKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRPYmogPSBmb250UGFyc2VyKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgZm9udE9iai5zcmMgPSB1cmw7XG4gICAgICAgICAgICBjYWxsYmFjayhmb250T2JqKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IG9uRXJyb3I7XG4gICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgb25FcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIExvYWQgYSBnaXZlbiBmb250IHVybCBpZiBuZWVkZWQsIGludm9raW5nIGEgY2FsbGJhY2sgd2hlbiBpdCdzIGxvYWRlZC4gSWYgYWxyZWFkeVxuICAgKiBsb2FkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udFVybFxuICAgKiBAcGFyYW0geyhmb250OiBQYXJzZWRGb250KSA9PiB2b2lkfSBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gbG9hZEZvbnQoZm9udFVybCwgY2FsbGJhY2spIHtcbiAgICBsZXQgZm9udCA9IHBhcnNlZEZvbnRzW2ZvbnRVcmxdO1xuICAgIGlmIChmb250KSB7XG4gICAgICBjYWxsYmFjayhmb250KTtcbiAgICB9IGVsc2UgaWYgKGxvYWRpbmdGb250c1tmb250VXJsXSkge1xuICAgICAgbG9hZGluZ0ZvbnRzW2ZvbnRVcmxdLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkaW5nRm9udHNbZm9udFVybF0gPSBbY2FsbGJhY2tdO1xuICAgICAgZG9Mb2FkRm9udChmb250VXJsLCBmb250T2JqID0+IHtcbiAgICAgICAgZm9udE9iai5zcmMgPSBmb250VXJsO1xuICAgICAgICBwYXJzZWRGb250c1tmb250VXJsXSA9IGZvbnRPYmo7XG4gICAgICAgIGxvYWRpbmdGb250c1tmb250VXJsXS5mb3JFYWNoKGNiID0+IGNiKGZvbnRPYmopKTtcbiAgICAgICAgZGVsZXRlIGxvYWRpbmdGb250c1tmb250VXJsXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYSBnaXZlbiBzdHJpbmcgb2YgdGV4dCwgZGV0ZXJtaW5lIHdoaWNoIGZvbnRzIGFyZSByZXF1aXJlZCB0byBmdWxseSByZW5kZXIgaXQgYW5kXG4gICAqIGVuc3VyZSB0aG9zZSBmb250cyBhcmUgbG9hZGVkLlxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0LCBjYWxsYmFjaywge1xuICAgIGxhbmcsXG4gICAgZm9udHM6IHVzZXJGb250cyA9IFtdLFxuICAgIHN0eWxlID0gJ25vcm1hbCcsXG4gICAgd2VpZ2h0ID0gJ25vcm1hbCcsXG4gICAgdW5pY29kZUZvbnRzVVJMXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGNoYXJSZXNvbHV0aW9ucyA9IG5ldyBVaW50OEFycmF5KHRleHQubGVuZ3RoKTtcbiAgICBjb25zdCBmb250UmVzb2x1dGlvbnMgPSBbXTtcbiAgICBpZiAoIXRleHQubGVuZ3RoKSB7XG4gICAgICBhbGxEb25lKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9udEluZGljZXMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZmFsbGJhY2tSYW5nZXMgPSBbXTsgLy8gW1tzdGFydCwgZW5kXSwgLi4uXVxuXG4gICAgaWYgKHN0eWxlICE9PSAnaXRhbGljJykgc3R5bGUgPSAnbm9ybWFsJztcbiAgICBpZiAodHlwZW9mIHdlaWdodCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHdlaWdodCA9IHdlaWdodCA9PT0gJ2JvbGQnID8gNzAwIDogNDAwO1xuICAgIH1cblxuICAgIGlmICh1c2VyRm9udHMgJiYgIUFycmF5LmlzQXJyYXkodXNlckZvbnRzKSkge1xuICAgICAgdXNlckZvbnRzID0gW3VzZXJGb250c107XG4gICAgfVxuICAgIHVzZXJGb250cyA9IHVzZXJGb250cy5zbGljZSgpXG4gICAgICAvLyBmaWx0ZXIgYnkgbGFuZ3VhZ2VcbiAgICAgIC5maWx0ZXIoZGVmID0+ICFkZWYubGFuZyB8fCBkZWYubGFuZy50ZXN0KGxhbmcpKVxuICAgICAgLy8gc3dpdGNoIG9yZGVyIGZvciBlYXNpZXIgaXRlcmF0aW9uXG4gICAgICAucmV2ZXJzZSgpO1xuICAgIGlmICh1c2VyRm9udHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBVTktOT1dOID0gMDtcbiAgICAgIGNvbnN0IFJFU09MVkVEID0gMTtcbiAgICAgIGNvbnN0IE5FRURTX0ZBTExCQUNLID0gMjtcbiAgICAgIGxldCBwcmV2Q2hhclJlc3VsdCA9IFVOS05PV05cblxuICAgICAgOyhmdW5jdGlvbiByZXNvbHZlVXNlckZvbnRzIChzdGFydEluZGV4ID0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleCwgaUxlbiA9IHRleHQubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY29kZVBvaW50ID0gdGV4dC5jb2RlUG9pbnRBdChpKTtcbiAgICAgICAgICAvLyBDYXJyeSBwcmV2aW91cyBjaGFyYWN0ZXIncyByZXN1bHQgZm9yd2FyZCBpZjpcbiAgICAgICAgICAvLyAtIGl0IHJlc29sdmVkIHRvIGEgZm9udCB0aGF0IGFsc28gY292ZXJzIHRoaXMgY2hhcmFjdGVyXG4gICAgICAgICAgLy8gLSB0aGlzIGNoYXJhY3RlciBpcyB3aGl0ZXNwYWNlXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHByZXZDaGFyUmVzdWx0ID09PSBSRVNPTFZFRCAmJiBmb250UmVzb2x1dGlvbnNbY2hhclJlc29sdXRpb25zW2kgLSAxXV0uc3VwcG9ydHNDb2RlUG9pbnQoY29kZVBvaW50KSkgfHxcbiAgICAgICAgICAgIChpID4gMCAmJiAvXFxzLy50ZXN0KHRleHRbaV0pKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW2ldID0gY2hhclJlc29sdXRpb25zW2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2Q2hhclJlc3VsdCA9PT0gTkVFRFNfRkFMTEJBQ0spIHtcbiAgICAgICAgICAgICAgZmFsbGJhY2tSYW5nZXNbZmFsbGJhY2tSYW5nZXMubGVuZ3RoIC0gMV1bMV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gY2hhclJlc29sdXRpb25zW2ldLCBqTGVuID0gdXNlckZvbnRzLmxlbmd0aDsgaiA8PSBqTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKGogPT09IGpMZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBub25lIG9mIHRoZSB1c2VyIGZvbnRzIG1hdGNoZWQ7IG5lZWRzIGZhbGxiYWNrXG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBwcmV2Q2hhclJlc3VsdCA9PT0gTkVFRFNfRkFMTEJBQ0sgP1xuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tSYW5nZXNbZmFsbGJhY2tSYW5nZXMubGVuZ3RoIC0gMV0gOlxuICAgICAgICAgICAgICAgICAgKGZhbGxiYWNrUmFuZ2VzW2ZhbGxiYWNrUmFuZ2VzLmxlbmd0aF0gPSBbaSwgaV0pO1xuICAgICAgICAgICAgICAgIHJhbmdlWzFdID0gaTtcbiAgICAgICAgICAgICAgICBwcmV2Q2hhclJlc3VsdCA9IE5FRURTX0ZBTExCQUNLO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYXJSZXNvbHV0aW9uc1tpXSA9IGo7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzcmMsIHVuaWNvZGVSYW5nZSB9ID0gdXNlckZvbnRzW2pdO1xuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBieSBvcHRpb25hbCBleHBsaWNpdCB1bmljb2RlIHJhbmdlc1xuICAgICAgICAgICAgICAgIGlmICghdW5pY29kZVJhbmdlIHx8IGlzQ29kZUluUmFuZ2VzKGNvZGVQb2ludCwgdW5pY29kZVJhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZm9udE9iaiA9IHBhcnNlZEZvbnRzW3NyY107XG4gICAgICAgICAgICAgICAgICAvLyBmb250IG5vdCB5ZXQgbG9hZGVkLCBsb2FkIGl0IGFuZCByZXN1bWVcbiAgICAgICAgICAgICAgICAgIGlmICghZm9udE9iaikge1xuICAgICAgICAgICAgICAgICAgICBsb2FkRm9udChzcmMsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlVXNlckZvbnRzKGkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZvbnQgYWN0dWFsbHkgY29udGFpbnMgYSBnbHlwaCBmb3IgdGhpcyBjaGFyLCBsb2NrIGl0IGluXG4gICAgICAgICAgICAgICAgICBpZiAoZm9udE9iai5zdXBwb3J0c0NvZGVQb2ludChjb2RlUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb250SW5kZXggPSBmb250SW5kaWNlcy5nZXQoZm9udE9iaik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9udEluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvbnRJbmRleCA9IGZvbnRSZXNvbHV0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgZm9udFJlc29sdXRpb25zLnB1c2goZm9udE9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgZm9udEluZGljZXMuc2V0KGZvbnRPYmosIGZvbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW2ldID0gZm9udEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBwcmV2Q2hhclJlc3VsdCA9IFJFU09MVkVEO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhmZmZmICYmIGkgKyAxIDwgaUxlbikge1xuICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW2kgKyAxXSA9IGNoYXJSZXNvbHV0aW9uc1tpXTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChwcmV2Q2hhclJlc3VsdCA9PT0gTkVFRFNfRkFMTEJBQ0spIHtcbiAgICAgICAgICAgICAgZmFsbGJhY2tSYW5nZXNbZmFsbGJhY2tSYW5nZXMubGVuZ3RoIC0gMV1bMV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlRmFsbGJhY2tzKCk7XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmYWxsYmFja1Jhbmdlcy5wdXNoKFswLCB0ZXh0Lmxlbmd0aCAtIDFdKTtcbiAgICAgIHJlc29sdmVGYWxsYmFja3MoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlRmFsbGJhY2tzKCkge1xuICAgICAgaWYgKGZhbGxiYWNrUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAvLyBDb21iaW5lIGFsbCBmYWxsYmFjayBzdWJzdHJpbmdzIGludG8gYSBzaW5nbGUgc3RyaW5nIGZvciBxdWVyeWluZ1xuICAgICAgICBjb25zdCBmYWxsYmFja1N0cmluZyA9IGZhbGxiYWNrUmFuZ2VzLm1hcChyYW5nZSA9PiB0ZXh0LnN1YnN0cmluZyhyYW5nZVswXSwgcmFuZ2VbMV0gKyAxKSkuam9pbignXFxuJyk7XG4gICAgICAgIHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnQuZ2V0Rm9udHNGb3JTdHJpbmcoZmFsbGJhY2tTdHJpbmcsIHtcbiAgICAgICAgICBsYW5nOiBsYW5nIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICB3ZWlnaHQsXG4gICAgICAgICAgZGF0YVVybDogdW5pY29kZUZvbnRzVVJMXG4gICAgICAgIH0pLnRoZW4oKHtmb250VXJscywgY2hhcnN9KSA9PiB7XG4gICAgICAgICAgLy8gRXh0cmFjdCByZXN1bHRzIGFuZCBwdXQgdGhlbSBiYWNrIGluIHRoZSBtYWluIGFycmF5XG4gICAgICAgICAgY29uc3QgZm9udEluZGV4T2Zmc2V0ID0gZm9udFJlc29sdXRpb25zLmxlbmd0aDtcbiAgICAgICAgICBsZXQgY2hhcklkeCA9IDA7XG4gICAgICAgICAgZmFsbGJhY2tSYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgZW5kSWR4ID0gcmFuZ2VbMV0gLSByYW5nZVswXTsgaSA8PSBlbmRJZHg7IGkrKykge1xuICAgICAgICAgICAgICBjaGFyUmVzb2x1dGlvbnNbcmFuZ2VbMF0gKyBpXSA9IGNoYXJzW2NoYXJJZHgrK10gKyBmb250SW5kZXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFySWR4Kys7IC8vc2tpcCBzZWdtZW50IHNlcGFyYXRvclxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gTG9hZCBhbmQgcGFyc2UgdGhlIGZhbGxiYWNrIGZvbnRzIC0gYXZvaWRpbmcgUHJvbWlzZSBoZXJlIHRvIHByZXZlbnQgcG9seWZpbGxzIGluIHRoZSB3b3JrZXJcbiAgICAgICAgICBsZXQgbG9hZGVkQ291bnQgPSAwO1xuICAgICAgICAgIGZvbnRVcmxzLmZvckVhY2goKHVybCwgaSkgPT4ge1xuICAgICAgICAgICAgbG9hZEZvbnQodXJsLCBmb250T2JqID0+IHtcbiAgICAgICAgICAgICAgZm9udFJlc29sdXRpb25zW2kgKyBmb250SW5kZXhPZmZzZXRdID0gZm9udE9iajtcbiAgICAgICAgICAgICAgaWYgKCsrbG9hZGVkQ291bnQgPT09IGZvbnRVcmxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFsbERvbmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsRG9uZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsbERvbmUoKSB7XG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIGNoYXJzOiBjaGFyUmVzb2x1dGlvbnMsXG4gICAgICAgIGZvbnRzOiBmb250UmVzb2x1dGlvbnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQ29kZUluUmFuZ2VzKGNvZGUsIHJhbmdlcykge1xuICAgICAgLy8gdG9kbyBvcHRpbWl6ZSBzZWFyY2ggLSBDb2RlUG9pbnRTZXQgZnJvbSB1bmljb2RlLWZvbnQtcmVzb2x2ZXI/XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJhbmdlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICBjb25zdCBbc3RhcnQsIGVuZCA9IHN0YXJ0XSA9IHJhbmdlc1trXTtcbiAgICAgICAgaWYgKHN0YXJ0IDw9IGNvZGUgJiYgY29kZSA8PSBlbmQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZm9udFJlc29sdmVyV29ya2VyTW9kdWxlID0gLyojX19QVVJFX18qL2RlZmluZVdvcmtlck1vZHVsZSh7XG4gIG5hbWU6ICdGb250UmVzb2x2ZXInLFxuICBkZXBlbmRlbmNpZXM6IFtcbiAgICBjcmVhdGVGb250UmVzb2x2ZXIsXG4gICAgd29ya2VyTW9kdWxlLFxuICAgIHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnRGYWN0b3J5LFxuICBdLFxuICBpbml0KGNyZWF0ZUZvbnRSZXNvbHZlciwgZm9udFBhcnNlciwgdW5pY29kZUZvbnRSZXNvbHZlckNsaWVudEZhY3RvcnkpIHtcbiAgICByZXR1cm4gY3JlYXRlRm9udFJlc29sdmVyKGZvbnRQYXJzZXIsIHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnRGYWN0b3J5KCkpO1xuICB9XG59KTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7bnVtYmVyfCdsZWZ0J3wnY2VudGVyJ3wncmlnaHQnfSBBbmNob3JYVmFsdWVcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7bnVtYmVyfCd0b3AnfCd0b3AtYmFzZWxpbmUnfCd0b3AtY2FwJ3wndG9wLWV4J3wnbWlkZGxlJ3wnYm90dG9tLWJhc2VsaW5lJ3wnYm90dG9tJ30gQW5jaG9yWVZhbHVlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUeXBlc2V0UGFyYW1zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGV4dFxuICogQHByb3BlcnR5IHtVc2VyRm9udHxVc2VyRm9udFtdfSBbZm9udF1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFuZ11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2RmR2x5cGhTaXplPTY0XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmb250U2l6ZT0xXVxuICogQHByb3BlcnR5IHtudW1iZXJ8J25vcm1hbCd8J2JvbGQnfSBbZm9udFdlaWdodD0nbm9ybWFsJ11cbiAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8J2l0YWxpYyd9IFtmb250U3R5bGU9J25vcm1hbCddXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xldHRlclNwYWNpbmc9MF1cbiAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8bnVtYmVyfSBbbGluZUhlaWdodD0nbm9ybWFsJ11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4V2lkdGhdXG4gKiBAcHJvcGVydHkgeydsdHInfCdydGwnfSBbZGlyZWN0aW9uPSdsdHInXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0ZXh0QWxpZ249J2xlZnQnXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0ZXh0SW5kZW50PTBdXG4gKiBAcHJvcGVydHkgeydub3JtYWwnfCdub3dyYXAnfSBbd2hpdGVTcGFjZT0nbm9ybWFsJ11cbiAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8J2JyZWFrLXdvcmQnfSBbb3ZlcmZsb3dXcmFwPSdub3JtYWwnXVxuICogQHByb3BlcnR5IHtBbmNob3JYVmFsdWV9IFthbmNob3JYPTBdXG4gKiBAcHJvcGVydHkge0FuY2hvcllWYWx1ZX0gW2FuY2hvclk9MF1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21ldHJpY3NPbmx5PWZhbHNlXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1bmljb2RlRm9udHNVUkxdXG4gKiBAcHJvcGVydHkge0ZvbnRSZXNvbHZlclJlc3VsdH0gW3ByZVJlc29sdmVkRm9udHNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbmNsdWRlQ2FyZXRQb3NpdGlvbnM9ZmFsc2VdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NodW5rZWRCb3VuZHNTaXplPTgxOTJdXG4gKiBAcHJvcGVydHkge3tbcmFuZ2VTdGFydEluZGV4XTogbnVtYmVyfX0gW2NvbG9yUmFuZ2VzXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVHlwZXNldFJlc3VsdFxuICogQHByb3BlcnR5IHtVaW50MTZBcnJheX0gZ2x5cGhJZHMgaWQgZm9yIGVhY2ggZ2x5cGgsIHNwZWNpZmljIHRvIHRoYXQgZ2x5cGgncyBmb250XG4gKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IGdseXBoRm9udEluZGljZXMgaW5kZXggaW50byBmb250RGF0YSBmb3IgZWFjaCBnbHlwaFxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGdseXBoUG9zaXRpb25zIHgseSBvZiBlYWNoIGdseXBoJ3Mgb3JpZ2luIGluIGxheW91dFxuICogQHByb3BlcnR5IHt7W2ZvbnRdOiB7W2dseXBoSWRdOiB7cGF0aDogc3RyaW5nLCBwYXRoQm91bmRzOiBudW1iZXJbXX19fX0gZ2x5cGhEYXRhIGRhdGEgYWJvdXQgZWFjaCBnbHlwaCBhcHBlYXJpbmcgaW4gdGhlIHRleHRcbiAqIEBwcm9wZXJ0eSB7VHlwZXNldEZvbnREYXRhW119IGZvbnREYXRhIGRhdGEgYWJvdXQgZWFjaCBmb250IHVzZWQgaW4gdGhlIHRleHRcbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBbY2FyZXRQb3NpdGlvbnNdIHN0YXJ0WCxlbmRYLGJvdHRvbVkgY2FyZXQgcG9zaXRpb25zIGZvciBlYWNoIGNoYXJcbiAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW2dseXBoQ29sb3JzXSBjb2xvciBmb3IgZWFjaCBnbHlwaCwgaWYgY29sb3IgcmFuZ2VzIHN1cHBsaWVkXG4gKiAgICAgICAgIGNodW5rZWRCb3VuZHMsIC8vdG90YWwgcmVjdHMgcGVyIChuPWNodW5rZWRCb3VuZHNTaXplKSBjb25zZWN1dGl2ZSBnbHlwaHNcbiAqICAgICAgICAgZm9udFNpemUsIC8vY2FsY3VsYXRlZCBlbSBoZWlnaHRcbiAqICAgICAgICAgdG9wQmFzZWxpbmU6IGFuY2hvcllPZmZzZXQgKyBsaW5lc1swXS5iYXNlbGluZSwgLy95IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsaW5lJ3MgYmFzZWxpbmVcbiAqICAgICAgICAgYmxvY2tCb3VuZHM6IFsgLy9ib3VuZHMgZm9yIHRoZSB3aG9sZSBibG9jayBvZiB0ZXh0LCBpbmNsdWRpbmcgdmVydGljYWwgcGFkZGluZyBmb3IgbGluZUhlaWdodFxuICogICAgICAgICAgIGFuY2hvclhPZmZzZXQsXG4gKiAgICAgICAgICAgYW5jaG9yWU9mZnNldCAtIHRvdGFsSGVpZ2h0LFxuICogICAgICAgICAgIGFuY2hvclhPZmZzZXQgKyBtYXhMaW5lV2lkdGgsXG4gKiAgICAgICAgICAgYW5jaG9yWU9mZnNldFxuICogICAgICAgICBdLFxuICogICAgICAgICB2aXNpYmxlQm91bmRzLCAvL3RvdGFsIGJvdW5kcyBvZiB2aXNpYmxlIHRleHQgcGF0aHMsIG1heSBiZSBsYXJnZXIgb3Igc21hbGxlciB0aGFuIGJsb2NrQm91bmRzXG4gKiAgICAgICAgIHRpbWluZ3NcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFR5cGVzZXRGb250RGF0YVxuICogQHByb3BlcnR5IHNyY1xuICogQHByb3BlcnR5IHVuaXRzUGVyRW1cbiAqIEBwcm9wZXJ0eSBhc2NlbmRlclxuICogQHByb3BlcnR5IGRlc2NlbmRlclxuICogQHByb3BlcnR5IGxpbmVIZWlnaHRcbiAqIEBwcm9wZXJ0eSBjYXBIZWlnaHRcbiAqIEBwcm9wZXJ0eSB4SGVpZ2h0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb259IFR5cGVzZXR0ZXJUeXBlc2V0RnVuY3Rpb24gLSBjb21wdXRlIGZvbnRzIGFuZCBsYXlvdXQgZm9yIHNvbWUgdGV4dC5cbiAqIEBwYXJhbSB7VHlwZXNldFBhcmFtc30gcGFyYW1zXG4gKiBAcGFyYW0geyhUeXBlc2V0UmVzdWx0KSA9PiB2b2lkfSBjYWxsYmFjayAtIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHR5cGVzZXR0aW5nIGlzIGNvbXBsZXRlLlxuICogICAgSWYgdGhlIHBhcmFtcyBpbmNsdWRlZCBgcHJlUmVzb2x2ZWRGb250c2AsIHRoaXMgd2lsbCBiZSBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gVHlwZXNldHRlck1lYXN1cmVGdW5jdGlvbiAtIGNvbXB1dGUgd2lkdGgvaGVpZ2h0IGZvciBzb21lIHRleHQuXG4gKiBAcGFyYW0ge1R5cGVzZXRQYXJhbXN9IHBhcmFtc1xuICogQHBhcmFtIHsod2lkdGg6bnVtYmVyLCBoZWlnaHQ6bnVtYmVyKSA9PiB2b2lkfSBjYWxsYmFjayAtIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIG1lYXN1cmVtZW50IGlzIGNvbXBsZXRlLlxuICogICAgSWYgdGhlIHBhcmFtcyBpbmNsdWRlZCBgcHJlUmVzb2x2ZWRGb250c2AsIHRoaXMgd2lsbCBiZSBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAqL1xuXG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzZWxmLWNvbnRhaW5lZCBlbnZpcm9ubWVudCBmb3IgcHJvY2Vzc2luZyB0ZXh0IHR5cGVzZXR0aW5nIHJlcXVlc3RzLlxuICpcbiAqIEl0IGlzIGltcG9ydGFudCB0aGF0IHRoaXMgZnVuY3Rpb24gaGFzIG5vIGNsb3N1cmUgZGVwZW5kZW5jaWVzLCBzbyB0aGF0IGl0IGNhbiBiZSBlYXNpbHkgaW5qZWN0ZWRcbiAqIGludG8gdGhlIHNvdXJjZSBmb3IgYSBXb3JrZXIgd2l0aG91dCByZXF1aXJpbmcgYSBidWlsZCBzdGVwIG9yIGNvbXBsZXggZGVwZW5kZW5jeSBsb2FkaW5nLiBBbGwgaXRzXG4gKiBkZXBlbmRlbmNpZXMgbXVzdCBiZSBwYXNzZWQgaW4gYXQgaW5pdGlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIHtGb250UmVzb2x2ZXJ9IHJlc29sdmVGb250cyAtIGZ1bmN0aW9uIHRvIHJlc29sdmUgYSBzdHJpbmcgdG8gcGFyc2VkIGZvbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gYmlkaSAtIHRoZSBiaWRpLmpzIGltcGxlbWVudGF0aW9uIG9iamVjdFxuICogQHJldHVybiB7e3R5cGVzZXQ6IFR5cGVzZXR0ZXJUeXBlc2V0RnVuY3Rpb24sIG1lYXN1cmU6IFR5cGVzZXR0ZXJNZWFzdXJlRnVuY3Rpb259fVxuICovXG5mdW5jdGlvbiBjcmVhdGVUeXBlc2V0dGVyKHJlc29sdmVGb250cywgYmlkaSkge1xuICBjb25zdCBJTkYgPSBJbmZpbml0eTtcblxuICAvLyBTZXQgb2YgVW5pY29kZSBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IGNoYXJhY3RlcnMsIHRoZXNlIHdpbGwgbm90IHByb2R1Y2UgdmlzaWJsZSBnbHlwaHNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1pc2xlYWRpbmctY2hhcmFjdGVyLWNsYXNzXG4gIGNvbnN0IERFRkFVTFRfSUdOT1JBQkxFX0NIQVJTID0gL1tcXHUwMEFEXFx1MDM0RlxcdTA2MUNcXHUxMTVGLVxcdTExNjBcXHUxN0I0LVxcdTE3QjVcXHUxODBCLVxcdTE4MEVcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNkZcXHUzMTY0XFx1RkUwMC1cXHVGRTBGXFx1RkVGRlxcdUZGQTBcXHVGRkYwLVxcdUZGRjhdLztcblxuICAvLyBUaGlzIHJlZ2V4IChpbnN0ZWFkIG9mIC9cXHMvKSBhbGxvd3MgdXMgdG8gc2VsZWN0IGFsbCB3aGl0ZXNwYWNlIEVYQ0VQVCBmb3Igbm9uLWJyZWFraW5nIHdoaXRlIHNwYWNlc1xuICBjb25zdCBsaW5lQnJlYWtpbmdXaGl0ZVNwYWNlID0gYFteXFxcXFNcXFxcdTAwQTBdYDtcblxuICAvLyBJbmNvbXBsZXRlIHNldCBvZiBjaGFyYWN0ZXJzIHRoYXQgYWxsb3cgbGluZSBicmVha2luZyBhZnRlciB0aGVtXG4gIC8vIEluIHRoZSBmdXR1cmUgd2UgbWF5IGNvbnNpZGVyIGEgZnVsbCBVbmljb2RlIGxpbmUgYnJlYWtpbmcgYWxnb3JpdGhtIGltcGw6IGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIxNFxuICBjb25zdCBCUkVBS19BRlRFUl9DSEFSUyA9IG5ldyBSZWdFeHAoYCR7bGluZUJyZWFraW5nV2hpdGVTcGFjZX18W1xcXFwtXFxcXHUwMDdDXFxcXHUwMEFEXFxcXHUyMDEwXFxcXHUyMDEyLVxcXFx1MjAxNFxcXFx1MjAyN1xcXFx1MjA1NlxcXFx1MkUxN1xcXFx1MkU0MF1gKTtcblxuICAvKipcbiAgICogTG9hZCBhbmQgcGFyc2UgYWxsIHRoZSBuZWNlc3NhcnkgZm9udHMgdG8gcmVuZGVyIGEgZ2l2ZW4gc3RyaW5nIG9mIHRleHQsIHRoZW4gZ3JvdXBcbiAgICogdGhlbSBpbnRvIGNvbnNlY3V0aXZlIHJ1bnMgb2YgY2hhcmFjdGVycyBzaGFyaW5nIGEgZm9udC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUZvbnRSdW5zKHt0ZXh0LCBsYW5nLCBmb250cywgc3R5bGUsIHdlaWdodCwgcHJlUmVzb2x2ZWRGb250cywgdW5pY29kZUZvbnRzVVJMfSwgb25Eb25lKSB7XG4gICAgY29uc3Qgb25SZXNvbHZlZCA9ICh7Y2hhcnMsIGZvbnRzOiBwYXJzZWRGb250c30pID0+IHtcbiAgICAgIGxldCBjdXJSdW4sIHByZXZWYWw7XG4gICAgICBjb25zdCBydW5zID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGFyc1tpXSAhPT0gcHJldlZhbCkge1xuICAgICAgICAgIHByZXZWYWwgPSBjaGFyc1tpXTtcbiAgICAgICAgICBydW5zLnB1c2goY3VyUnVuID0geyBzdGFydDogaSwgZW5kOiBpLCBmb250T2JqOiBwYXJzZWRGb250c1tjaGFyc1tpXV19KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJSdW4uZW5kID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25Eb25lKHJ1bnMpO1xuICAgIH07XG4gICAgaWYgKHByZVJlc29sdmVkRm9udHMpIHtcbiAgICAgIG9uUmVzb2x2ZWQocHJlUmVzb2x2ZWRGb250cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVGb250cyhcbiAgICAgICAgdGV4dCxcbiAgICAgICAgb25SZXNvbHZlZCxcbiAgICAgICAgeyBsYW5nLCBmb250cywgc3R5bGUsIHdlaWdodCwgdW5pY29kZUZvbnRzVVJMIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1haW4gZW50cnkgcG9pbnQuXG4gICAqIFByb2Nlc3MgYSB0ZXh0IHN0cmluZyB3aXRoIGdpdmVuIGZvbnQgYW5kIGZvcm1hdHRpbmcgcGFyYW1ldGVycywgYW5kIHJldHVybiBhbGwgaW5mb1xuICAgKiBuZWNlc3NhcnkgdG8gcmVuZGVyIGFsbCBpdHMgZ2x5cGhzLlxuICAgKiBAdHlwZSBUeXBlc2V0dGVyVHlwZXNldEZ1bmN0aW9uXG4gICAqL1xuICBmdW5jdGlvbiB0eXBlc2V0KFxuICAgIHtcbiAgICAgIHRleHQ9JycsXG4gICAgICBmb250LFxuICAgICAgbGFuZyxcbiAgICAgIHNkZkdseXBoU2l6ZT02NCxcbiAgICAgIGZvbnRTaXplPTQwMCxcbiAgICAgIGZvbnRXZWlnaHQ9MSxcbiAgICAgIGZvbnRTdHlsZT0nbm9ybWFsJyxcbiAgICAgIGxldHRlclNwYWNpbmc9MCxcbiAgICAgIGxpbmVIZWlnaHQ9J25vcm1hbCcsXG4gICAgICBtYXhXaWR0aD1JTkYsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0ZXh0QWxpZ249J2xlZnQnLFxuICAgICAgdGV4dEluZGVudD0wLFxuICAgICAgd2hpdGVTcGFjZT0nbm9ybWFsJyxcbiAgICAgIG92ZXJmbG93V3JhcD0nbm9ybWFsJyxcbiAgICAgIGFuY2hvclggPSAwLFxuICAgICAgYW5jaG9yWSA9IDAsXG4gICAgICBtZXRyaWNzT25seT1mYWxzZSxcbiAgICAgIHVuaWNvZGVGb250c1VSTCxcbiAgICAgIHByZVJlc29sdmVkRm9udHM9bnVsbCxcbiAgICAgIGluY2x1ZGVDYXJldFBvc2l0aW9ucz1mYWxzZSxcbiAgICAgIGNodW5rZWRCb3VuZHNTaXplPTgxOTIsXG4gICAgICBjb2xvclJhbmdlcz1udWxsXG4gICAgfSxcbiAgICBjYWxsYmFja1xuICApIHtcbiAgICBjb25zdCBtYWluU3RhcnQgPSBub3coKTtcbiAgICBjb25zdCB0aW1pbmdzID0ge2ZvbnRMb2FkOiAwLCB0eXBlc2V0dGluZzogMH07XG5cbiAgICAvLyBFbnN1cmUgbmV3bGluZXMgYXJlIG5vcm1hbGl6ZWRcbiAgICBpZiAodGV4dC5pbmRleE9mKCdcXHInKSA+IC0xKSB7XG4gICAgICBjb25zb2xlLmluZm8oJ1R5cGVzZXR0ZXI6IGdvdCB0ZXh0IHdpdGggXFxcXHIgY2hhcnM7IG5vcm1hbGl6aW5nIHRvIFxcXFxuJyk7XG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxuJyk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHdlJ3ZlIGdvdCBudW1iZXJzIG5vdCBzdHJpbmdzXG4gICAgZm9udFNpemUgPSArZm9udFNpemU7XG4gICAgbGV0dGVyU3BhY2luZyA9ICtsZXR0ZXJTcGFjaW5nO1xuICAgIG1heFdpZHRoID0gK21heFdpZHRoO1xuICAgIGxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0IHx8ICdub3JtYWwnO1xuICAgIHRleHRJbmRlbnQgPSArdGV4dEluZGVudDtcblxuICAgIGNhbGN1bGF0ZUZvbnRSdW5zKHtcbiAgICAgIHRleHQsXG4gICAgICBsYW5nLFxuICAgICAgc3R5bGU6IGZvbnRTdHlsZSxcbiAgICAgIHdlaWdodDogZm9udFdlaWdodCxcbiAgICAgIGZvbnRzOiB0eXBlb2YgZm9udCA9PT0gJ3N0cmluZycgPyBbe3NyYzogZm9udH1dIDogZm9udCxcbiAgICAgIHVuaWNvZGVGb250c1VSTCxcbiAgICAgIHByZVJlc29sdmVkRm9udHNcbiAgICB9LCBydW5zID0+IHtcbiAgICAgIHRpbWluZ3MuZm9udExvYWQgPSBub3coKSAtIG1haW5TdGFydDtcbiAgICAgIGNvbnN0IGhhc01heFdpZHRoID0gaXNGaW5pdGUobWF4V2lkdGgpO1xuICAgICAgbGV0IGdseXBoSWRzID0gbnVsbDtcbiAgICAgIGxldCBnbHlwaEZvbnRJbmRpY2VzID0gbnVsbDtcbiAgICAgIGxldCBnbHlwaFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICBsZXQgZ2x5cGhEYXRhID0gbnVsbDtcbiAgICAgIGxldCBnbHlwaENvbG9ycyA9IG51bGw7XG4gICAgICBsZXQgY2FyZXRQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgbGV0IHZpc2libGVCb3VuZHMgPSBudWxsO1xuICAgICAgbGV0IGNodW5rZWRCb3VuZHMgPSBudWxsO1xuICAgICAgbGV0IG1heExpbmVXaWR0aCA9IDA7XG4gICAgICBsZXQgcmVuZGVyYWJsZUdseXBoQ291bnQgPSAwO1xuICAgICAgbGV0IGNhbldyYXAgPSB3aGl0ZVNwYWNlICE9PSAnbm93cmFwJztcbiAgICAgIGNvbnN0IG1ldHJpY3NCeUZvbnQgPSBuZXcgTWFwKCk7IC8vIGZvbnRPYmogLT4gbWV0cmljc1xuICAgICAgY29uc3QgdHlwZXNldFN0YXJ0ID0gbm93KCk7XG5cbiAgICAgIC8vIERpc3RyaWJ1dGUgZ2x5cGhzIGludG8gbGluZXMgYmFzZWQgb24gd3JhcHBpbmdcbiAgICAgIGxldCBsaW5lWE9mZnNldCA9IHRleHRJbmRlbnQ7XG4gICAgICBsZXQgcHJldlJ1bkVuZFggPSAwO1xuICAgICAgbGV0IGN1cnJlbnRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICBjb25zdCBsaW5lcyA9IFtjdXJyZW50TGluZV07XG4gICAgICBydW5zLmZvckVhY2gocnVuID0+IHtcbiAgICAgICAgY29uc3QgeyBmb250T2JqIH0gPSBydW47XG4gICAgICAgIGNvbnN0IHsgYXNjZW5kZXIsIGRlc2NlbmRlciwgdW5pdHNQZXJFbSwgbGluZUdhcCwgY2FwSGVpZ2h0LCB4SGVpZ2h0IH0gPSBmb250T2JqO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBtZXRyaWNzIGZvciBlYWNoIGZvbnQgdXNlZFxuICAgICAgICBsZXQgZm9udERhdGEgPSBtZXRyaWNzQnlGb250LmdldChmb250T2JqKTtcbiAgICAgICAgaWYgKCFmb250RGF0YSkge1xuICAgICAgICAgIC8vIEZpbmQgY29udmVyc2lvbiBiZXR3ZWVuIG5hdGl2ZSBmb250IHVuaXRzIGFuZCBmb250U2l6ZSB1bml0c1xuICAgICAgICAgIGNvbnN0IGZvbnRTaXplTXVsdCA9IGZvbnRTaXplIC8gdW5pdHNQZXJFbTtcblxuICAgICAgICAgIC8vIERldGVybWluZSBhcHByb3ByaWF0ZSB2YWx1ZSBmb3IgJ25vcm1hbCcgbGluZSBoZWlnaHQgYmFzZWQgb24gdGhlIGZvbnQncyBhY3R1YWwgbWV0cmljc1xuICAgICAgICAgIC8vIFRoaXMgZG9lcyBub3QgZ3VhcmFudGVlIGluZGl2aWR1YWwgZ2x5cGhzIHdvbid0IGV4Y2VlZCB0aGUgbGluZSBoZWlnaHQsIGUuZy4gUm9ib3RvOyBzaG91bGQgd2UgdXNlIHlNaW4vTWF4IGluc3RlYWQ/XG4gICAgICAgICAgY29uc3QgY2FsY0xpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0ID09PSAnbm9ybWFsJyA/XG4gICAgICAgICAgICAoYXNjZW5kZXIgLSBkZXNjZW5kZXIgKyBsaW5lR2FwKSAqIGZvbnRTaXplTXVsdCA6IGxpbmVIZWlnaHQgKiBmb250U2l6ZTtcblxuICAgICAgICAgIC8vIERldGVybWluZSBsaW5lIGhlaWdodCBhbmQgbGVhZGluZyBhZGp1c3RtZW50c1xuICAgICAgICAgIGNvbnN0IGhhbGZMZWFkaW5nID0gKGNhbGNMaW5lSGVpZ2h0IC0gKGFzY2VuZGVyIC0gZGVzY2VuZGVyKSAqIGZvbnRTaXplTXVsdCkgLyAyO1xuICAgICAgICAgIGNvbnN0IGNhcmV0SGVpZ2h0ID0gTWF0aC5taW4oY2FsY0xpbmVIZWlnaHQsIChhc2NlbmRlciAtIGRlc2NlbmRlcikgKiBmb250U2l6ZU11bHQpO1xuICAgICAgICAgIGNvbnN0IGNhcmV0VG9wID0gKGFzY2VuZGVyICsgZGVzY2VuZGVyKSAvIDIgKiBmb250U2l6ZU11bHQgKyBjYXJldEhlaWdodCAvIDI7XG4gICAgICAgICAgZm9udERhdGEgPSB7XG4gICAgICAgICAgICBpbmRleDogbWV0cmljc0J5Rm9udC5zaXplLFxuICAgICAgICAgICAgc3JjOiBmb250T2JqLnNyYyxcbiAgICAgICAgICAgIGZvbnRPYmosXG4gICAgICAgICAgICBmb250U2l6ZU11bHQsXG4gICAgICAgICAgICB1bml0c1BlckVtLFxuICAgICAgICAgICAgYXNjZW5kZXI6IGFzY2VuZGVyICogZm9udFNpemVNdWx0LFxuICAgICAgICAgICAgZGVzY2VuZGVyOiBkZXNjZW5kZXIgKiBmb250U2l6ZU11bHQsXG4gICAgICAgICAgICBjYXBIZWlnaHQ6IGNhcEhlaWdodCAqIGZvbnRTaXplTXVsdCxcbiAgICAgICAgICAgIHhIZWlnaHQ6IHhIZWlnaHQgKiBmb250U2l6ZU11bHQsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiBjYWxjTGluZUhlaWdodCxcbiAgICAgICAgICAgIGJhc2VsaW5lOiAtaGFsZkxlYWRpbmcgLSBhc2NlbmRlciAqIGZvbnRTaXplTXVsdCwgLy8gYmFzZWxpbmUgb2Zmc2V0IGZyb20gdG9wIG9mIGxpbmUgaGVpZ2h0XG4gICAgICAgICAgICAvLyBjYXA6IC1oYWxmTGVhZGluZyAtIGNhcEhlaWdodCAqIGZvbnRTaXplTXVsdCwgLy8gY2FwIGZyb20gdG9wIG9mIGxpbmUgaGVpZ2h0XG4gICAgICAgICAgICAvLyBleDogLWhhbGZMZWFkaW5nIC0geEhlaWdodCAqIGZvbnRTaXplTXVsdCwgLy8gZXggZnJvbSB0b3Agb2YgbGluZSBoZWlnaHRcbiAgICAgICAgICAgIGNhcmV0VG9wLFxuICAgICAgICAgICAgY2FyZXRCb3R0b206IGNhcmV0VG9wIC0gY2FyZXRIZWlnaHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1ldHJpY3NCeUZvbnQuc2V0KGZvbnRPYmosIGZvbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGZvbnRTaXplTXVsdCB9ID0gZm9udERhdGE7XG5cbiAgICAgICAgY29uc3QgcnVuVGV4dCA9IHRleHQuc2xpY2UocnVuLnN0YXJ0LCBydW4uZW5kICsgMSk7XG4gICAgICAgIGxldCBwcmV2R2x5cGhYLCBwcmV2R2x5cGhPYmo7XG4gICAgICAgIGZvbnRPYmouZm9yRWFjaEdseXBoKHJ1blRleHQsIGZvbnRTaXplLCBsZXR0ZXJTcGFjaW5nLCAoZ2x5cGhPYmosIGdseXBoWCwgZ2x5cGhZLCBjaGFySW5kZXgpID0+IHtcbiAgICAgICAgICBnbHlwaFggKz0gcHJldlJ1bkVuZFg7XG4gICAgICAgICAgY2hhckluZGV4ICs9IHJ1bi5zdGFydDtcbiAgICAgICAgICBwcmV2R2x5cGhYID0gZ2x5cGhYO1xuICAgICAgICAgIHByZXZHbHlwaE9iaiA9IGdseXBoT2JqO1xuICAgICAgICAgIGNvbnN0IGNoYXIgPSB0ZXh0LmNoYXJBdChjaGFySW5kZXgpO1xuICAgICAgICAgIGNvbnN0IGdseXBoV2lkdGggPSBnbHlwaE9iai5hZHZhbmNlV2lkdGggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgY29uc3QgY3VyTGluZUNvdW50ID0gY3VycmVudExpbmUuY291bnQ7XG4gICAgICAgICAgbGV0IG5leHRMaW5lO1xuXG4gICAgICAgICAgLy8gQ2FsYyBpc1doaXRlc3BhY2UgYW5kIGlzRW1wdHkgb25jZSBwZXIgZ2x5cGhPYmpcbiAgICAgICAgICBpZiAoISgnaXNFbXB0eScgaW4gZ2x5cGhPYmopKSB7XG4gICAgICAgICAgICBnbHlwaE9iai5pc1doaXRlc3BhY2UgPSAhIWNoYXIgJiYgbmV3IFJlZ0V4cChsaW5lQnJlYWtpbmdXaGl0ZVNwYWNlKS50ZXN0KGNoYXIpO1xuICAgICAgICAgICAgZ2x5cGhPYmouY2FuQnJlYWtBZnRlciA9ICEhY2hhciAmJiBCUkVBS19BRlRFUl9DSEFSUy50ZXN0KGNoYXIpO1xuICAgICAgICAgICAgZ2x5cGhPYmouaXNFbXB0eSA9IGdseXBoT2JqLnhNaW4gPT09IGdseXBoT2JqLnhNYXggfHwgZ2x5cGhPYmoueU1pbiA9PT0gZ2x5cGhPYmoueU1heCB8fCBERUZBVUxUX0lHTk9SQUJMRV9DSEFSUy50ZXN0KGNoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiAhZ2x5cGhPYmouaXNFbXB0eSkge1xuICAgICAgICAgICAgcmVuZGVyYWJsZUdseXBoQ291bnQrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBhIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBvdmVyZmxvd3MgdGhlIG1heCB3aWR0aCwgd2UgbmVlZCB0byBzb2Z0LXdyYXBcbiAgICAgICAgICBpZiAoY2FuV3JhcCAmJiBoYXNNYXhXaWR0aCAmJiAhZ2x5cGhPYmouaXNXaGl0ZXNwYWNlICYmIGdseXBoWCArIGdseXBoV2lkdGggKyBsaW5lWE9mZnNldCA+IG1heFdpZHRoICYmIGN1ckxpbmVDb3VudCkge1xuICAgICAgICAgICAgLy8gSWYgaXQncyB0aGUgZmlyc3QgY2hhciBhZnRlciBhIHdoaXRlc3BhY2UsIHN0YXJ0IGEgbmV3IGxpbmVcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGluZS5nbHlwaEF0KGN1ckxpbmVDb3VudCAtIDEpLmdseXBoT2JqLmNhbkJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgbmV4dExpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAtZ2x5cGhYO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQmFjayB1cCBsb29raW5nIGZvciBhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIHRvIHdyYXAgYXRcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGN1ckxpbmVDb3VudDsgaS0tOykge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdGhlcmUncyBubyBzb2Z0IGJyZWFrIHBvaW50OyBtYWtlIGhhcmQgYnJlYWsgaWYgb3ZlcmZsb3dXcmFwPSdicmVhay13b3JkJ1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmIG92ZXJmbG93V3JhcCA9PT0gJ2JyZWFrLXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAtZ2x5cGhYO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYSBzb2Z0IGJyZWFrIHBvaW50OyBtb3ZlIGFsbCBjaGFycyBzaW5jZSBpdCB0byBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudExpbmUuZ2x5cGhBdChpKS5nbHlwaE9iai5jYW5CcmVha0FmdGVyKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0TGluZSA9IGN1cnJlbnRMaW5lLnNwbGl0QXQoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWRqdXN0WCA9IG5leHRMaW5lLmdseXBoQXQoMCkueDtcbiAgICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0IC09IGFkanVzdFg7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gbmV4dExpbmUuY291bnQ7IGotLTspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUuZ2x5cGhBdChqKS54IC09IGFkanVzdFg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRMaW5lKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMaW5lLmlzU29mdFdyYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjdXJyZW50TGluZSA9IG5leHRMaW5lO1xuICAgICAgICAgICAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gbWF4V2lkdGg7IC8vYWZ0ZXIgc29mdCB3cmFwcGluZyB1c2UgbWF4V2lkdGggYXMgY2FsY3VsYXRlZCB3aWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBmbHkgPSBjdXJyZW50TGluZS5nbHlwaEF0KGN1cnJlbnRMaW5lLmNvdW50KTtcbiAgICAgICAgICBmbHkuZ2x5cGhPYmogPSBnbHlwaE9iajtcbiAgICAgICAgICBmbHkueCA9IGdseXBoWCArIGxpbmVYT2Zmc2V0O1xuICAgICAgICAgIGZseS55ID0gZ2x5cGhZO1xuICAgICAgICAgIGZseS53aWR0aCA9IGdseXBoV2lkdGg7XG4gICAgICAgICAgZmx5LmNoYXJJbmRleCA9IGNoYXJJbmRleDtcbiAgICAgICAgICBmbHkuZm9udERhdGEgPSBmb250RGF0YTtcblxuICAgICAgICAgIC8vIEhhbmRsZSBoYXJkIGxpbmUgYnJlYWtzXG4gICAgICAgICAgaWYgKGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjdXJyZW50TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICAgICAgICBsaW5lWE9mZnNldCA9IC0oZ2x5cGhYICsgZ2x5cGhXaWR0aCArIChsZXR0ZXJTcGFjaW5nICogZm9udFNpemUpKSArIHRleHRJbmRlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXQgdGhlIGVuZCBvZiBhIHJ1biB3ZSBtdXN0IGNhcHR1cmUgdGhlIHggcG9zaXRpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciB0aGUgbmV4dCBydW5cbiAgICAgICAgcHJldlJ1bkVuZFggPSBwcmV2R2x5cGhYICsgcHJldkdseXBoT2JqLmFkdmFuY2VXaWR0aCAqIGZvbnRTaXplTXVsdCArIGxldHRlclNwYWNpbmcgKiBmb250U2l6ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgd2lkdGgvaGVpZ2h0L2Jhc2VsaW5lIG9mIGVhY2ggbGluZSAoZXhjbHVkaW5nIHRyYWlsaW5nIHdoaXRlc3BhY2UpIGFuZCBtYXhpbXVtIGJsb2NrIHdpZHRoXG4gICAgICBsZXQgdG90YWxIZWlnaHQgPSAwO1xuICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgbGV0IGlzVHJhaWxpbmdXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxpbmUuY291bnQ7IGktLTspIHtcbiAgICAgICAgICBjb25zdCBnbHlwaEluZm8gPSBsaW5lLmdseXBoQXQoaSk7XG4gICAgICAgICAgLy8gb21pdCB0cmFpbGluZyB3aGl0ZXNwYWNlIGZyb20gd2lkdGggY2FsY3VsYXRpb25cbiAgICAgICAgICBpZiAoaXNUcmFpbGluZ1doaXRlc3BhY2UgJiYgIWdseXBoSW5mby5nbHlwaE9iai5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIGxpbmUud2lkdGggPSBnbHlwaEluZm8ueCArIGdseXBoSW5mby53aWR0aDtcbiAgICAgICAgICAgIGlmIChsaW5lLndpZHRoID4gbWF4TGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IGxpbmUud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc1RyYWlsaW5nV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB1c2UgdGhlIHRhbGxlc3QgbGluZSBoZWlnaHQsIGxvd2VzdCBiYXNlbGluZSwgYW5kIGhpZ2hlc3QgY2FwL2V4XG4gICAgICAgICAgbGV0IHtsaW5lSGVpZ2h0LCBjYXBIZWlnaHQsIHhIZWlnaHQsIGJhc2VsaW5lfSA9IGdseXBoSW5mby5mb250RGF0YTtcbiAgICAgICAgICBpZiAobGluZUhlaWdodCA+IGxpbmUubGluZUhlaWdodCkgbGluZS5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgICBjb25zdCBiYXNlbGluZURpZmYgPSBiYXNlbGluZSAtIGxpbmUuYmFzZWxpbmU7XG4gICAgICAgICAgaWYgKGJhc2VsaW5lRGlmZiA8IDApIHsgLy9zaGlmdCBhbGwgbWV0cmljcyBkb3duXG4gICAgICAgICAgICBsaW5lLmJhc2VsaW5lICs9IGJhc2VsaW5lRGlmZjtcbiAgICAgICAgICAgIGxpbmUuY2FwICs9IGJhc2VsaW5lRGlmZjtcbiAgICAgICAgICAgIGxpbmUuZXggKz0gYmFzZWxpbmVEaWZmO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb21wYXJlIGNhcC9leCBiYXNlZCBvbiBuZXcgbG93ZXN0IGJhc2VsaW5lXG4gICAgICAgICAgbGluZS5jYXAgPSBNYXRoLm1heChsaW5lLmNhcCwgbGluZS5iYXNlbGluZSArIGNhcEhlaWdodCk7XG4gICAgICAgICAgbGluZS5leCA9IE1hdGgubWF4KGxpbmUuZXgsIGxpbmUuYmFzZWxpbmUgKyB4SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lLmJhc2VsaW5lIC09IHRvdGFsSGVpZ2h0O1xuICAgICAgICBsaW5lLmNhcCAtPSB0b3RhbEhlaWdodDtcbiAgICAgICAgbGluZS5leCAtPSB0b3RhbEhlaWdodDtcbiAgICAgICAgdG90YWxIZWlnaHQgKz0gbGluZS5saW5lSGVpZ2h0O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZpbmQgb3ZlcmFsbCBwb3NpdGlvbiBhZGp1c3RtZW50cyBmb3IgYW5jaG9yaW5nXG4gICAgICBsZXQgYW5jaG9yWE9mZnNldCA9IDA7XG4gICAgICBsZXQgYW5jaG9yWU9mZnNldCA9IDA7XG4gICAgICBpZiAoYW5jaG9yWCkge1xuICAgICAgICBpZiAodHlwZW9mIGFuY2hvclggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYW5jaG9yWE9mZnNldCA9IC1hbmNob3JYO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhbmNob3JYID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGFuY2hvclhPZmZzZXQgPSAtbWF4TGluZVdpZHRoICogKFxuICAgICAgICAgICAgYW5jaG9yWCA9PT0gJ2xlZnQnID8gMCA6XG4gICAgICAgICAgICBhbmNob3JYID09PSAnY2VudGVyJyA/IDAuNSA6XG4gICAgICAgICAgICBhbmNob3JYID09PSAncmlnaHQnID8gMSA6XG4gICAgICAgICAgICBwYXJzZVBlcmNlbnQoYW5jaG9yWClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYW5jaG9yWSkge1xuICAgICAgICBpZiAodHlwZW9mIGFuY2hvclkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYW5jaG9yWU9mZnNldCA9IC1hbmNob3JZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhbmNob3JZID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGFuY2hvcllPZmZzZXQgPSBhbmNob3JZID09PSAndG9wJyA/IDAgOlxuICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ3RvcC1iYXNlbGluZScgPyAtbGluZXNbMF0uYmFzZWxpbmUgOlxuICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ3RvcC1jYXAnID8gLWxpbmVzWzBdLmNhcCA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAndG9wLWV4JyA/IC1saW5lc1swXS5leCA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAnbWlkZGxlJyA/IHRvdGFsSGVpZ2h0IC8gMiA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAnYm90dG9tJyA/IHRvdGFsSGVpZ2h0IDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICdib3R0b20tYmFzZWxpbmUnID8gLWxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmJhc2VsaW5lIDpcbiAgICAgICAgICAgIHBhcnNlUGVyY2VudChhbmNob3JZKSAqIHRvdGFsSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbWV0cmljc09ubHkpIHtcbiAgICAgICAgLy8gUmVzb2x2ZSBiaWRpIGxldmVsc1xuICAgICAgICBjb25zdCBiaWRpTGV2ZWxzUmVzdWx0ID0gYmlkaS5nZXRFbWJlZGRpbmdMZXZlbHModGV4dCwgZGlyZWN0aW9uKTtcblxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggbGluZSwgYXBwbHlpbmcgYWxpZ25tZW50IG9mZnNldHMsIGFkZGluZyBlYWNoIGdseXBoIHRvIHRoZSBhdGxhcywgYW5kXG4gICAgICAgIC8vIGNvbGxlY3RpbmcgYWxsIHJlbmRlcmFibGUgZ2x5cGhzIGludG8gYSBzaW5nbGUgY29sbGVjdGlvbi5cbiAgICAgICAgZ2x5cGhJZHMgPSBuZXcgVWludDE2QXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQpO1xuICAgICAgICBnbHlwaEZvbnRJbmRpY2VzID0gbmV3IFVpbnQ4QXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQpO1xuICAgICAgICBnbHlwaFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQgKiAyKTtcbiAgICAgICAgZ2x5cGhEYXRhID0ge307XG4gICAgICAgIHZpc2libGVCb3VuZHMgPSBbSU5GLCBJTkYsIC1JTkYsIC1JTkZdO1xuICAgICAgICBjaHVua2VkQm91bmRzID0gW107XG4gICAgICAgIGlmIChpbmNsdWRlQ2FyZXRQb3NpdGlvbnMpIHtcbiAgICAgICAgICBjYXJldFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkodGV4dC5sZW5ndGggKiA0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sb3JSYW5nZXMpIHtcbiAgICAgICAgICBnbHlwaENvbG9ycyA9IG5ldyBVaW50OEFycmF5KHJlbmRlcmFibGVHbHlwaENvdW50ICogMyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlbmRlcmFibGVHbHlwaEluZGV4ID0gMDtcbiAgICAgICAgbGV0IHByZXZDaGFySW5kZXggPSAtMTtcbiAgICAgICAgbGV0IGNvbG9yQ2hhckluZGV4ID0gLTE7XG4gICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgbGV0IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgbGluZXMuZm9yRWFjaCgobGluZSwgbGluZUluZGV4KSA9PiB7XG4gICAgICAgICAgbGV0IHtjb3VudDpsaW5lR2x5cGhDb3VudCwgd2lkdGg6bGluZVdpZHRofSA9IGxpbmU7XG5cbiAgICAgICAgICAvLyBJZ25vcmUgZW1wdHkgbGluZXNcbiAgICAgICAgICBpZiAobGluZUdseXBoQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAvLyBDb3VudCB0cmFpbGluZyB3aGl0ZXNwYWNlcywgd2Ugd2FudCB0byBpZ25vcmUgdGhlc2UgZm9yIGNlcnRhaW4gdGhpbmdzXG4gICAgICAgICAgICBsZXQgdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxpbmVHbHlwaENvdW50OyBpLS0gJiYgbGluZS5nbHlwaEF0KGkpLmdseXBoT2JqLmlzV2hpdGVzcGFjZTspIHtcbiAgICAgICAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwbHkgaG9yaXpvbnRhbCBhbGlnbm1lbnQgYWRqdXN0bWVudHNcbiAgICAgICAgICAgIGxldCBsaW5lWE9mZnNldCA9IDA7XG4gICAgICAgICAgICBsZXQganVzdGlmeUFkanVzdCA9IDA7XG4gICAgICAgICAgICBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICBsaW5lWE9mZnNldCA9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGgpIC8gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdqdXN0aWZ5JyAmJiBsaW5lLmlzU29mdFdyYXBwZWQpIHtcbiAgICAgICAgICAgICAgLy8gY291bnQgbm9uLXRyYWlsaW5nIHdoaXRlc3BhY2UgY2hhcmFjdGVycywgYW5kIHdlJ2xsIGFkanVzdCB0aGUgb2Zmc2V0cyBwZXIgY2hhcmFjdGVyIGluIHRoZSBuZXh0IGxvb3BcbiAgICAgICAgICAgICAgbGV0IHdoaXRlc3BhY2VDb3VudCA9IDA7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSBsaW5lR2x5cGhDb3VudCAtIHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50OyBpLS07KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuZ2x5cGhBdChpKS5nbHlwaE9iai5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2VDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBqdXN0aWZ5QWRqdXN0ID0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aCkgLyB3aGl0ZXNwYWNlQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanVzdGlmeUFkanVzdCB8fCBsaW5lWE9mZnNldCkge1xuICAgICAgICAgICAgICBsZXQganVzdGlmeU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUdseXBoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBnbHlwaEluZm8gPSBsaW5lLmdseXBoQXQoaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhPYmogPSBnbHlwaEluZm8uZ2x5cGhPYmo7XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmZvLnggKz0gbGluZVhPZmZzZXQgKyBqdXN0aWZ5T2Zmc2V0O1xuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBub24tdHJhaWxpbmcgd2hpdGVzcGFjZXMgZm9yIGp1c3RpZnkgYWxpZ25tZW50XG4gICAgICAgICAgICAgICAgaWYgKGp1c3RpZnlBZGp1c3QgIT09IDAgJiYgZ2x5cGhPYmouaXNXaGl0ZXNwYWNlICYmIGkgPCBsaW5lR2x5cGhDb3VudCAtIHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICBqdXN0aWZ5T2Zmc2V0ICs9IGp1c3RpZnlBZGp1c3Q7XG4gICAgICAgICAgICAgICAgICBnbHlwaEluZm8ud2lkdGggKz0ganVzdGlmeUFkanVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUGVyZm9ybSBiaWRpIHJhbmdlIGZsaXBwaW5nXG4gICAgICAgICAgICBjb25zdCBmbGlwcyA9IGJpZGkuZ2V0UmVvcmRlclNlZ21lbnRzKFxuICAgICAgICAgICAgICB0ZXh0LCBiaWRpTGV2ZWxzUmVzdWx0LCBsaW5lLmdseXBoQXQoMCkuY2hhckluZGV4LCBsaW5lLmdseXBoQXQobGluZS5jb3VudCAtIDEpLmNoYXJJbmRleFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZvciAobGV0IGZpID0gMDsgZmkgPCBmbGlwcy5sZW5ndGg7IGZpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gZmxpcHNbZmldO1xuICAgICAgICAgICAgICAvLyBNYXAgc3RhcnQvZW5kIHN0cmluZyBpbmRpY2VzIHRvIGluZGljZXMgaW4gdGhlIGxpbmVcbiAgICAgICAgICAgICAgbGV0IGxlZnQgPSBJbmZpbml0eSwgcmlnaHQgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUdseXBoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmdseXBoQXQoaSkuY2hhckluZGV4ID49IHN0YXJ0KSB7IC8vIGd0ZSB0byBoYW5kbGUgcmVtb3ZlZCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbkxpbmUgPSBpLCBlbmRJbkxpbmUgPSBpO1xuICAgICAgICAgICAgICAgICAgZm9yICg7IGVuZEluTGluZSA8IGxpbmVHbHlwaENvdW50OyBlbmRJbkxpbmUrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5mbyA9IGxpbmUuZ2x5cGhBdChlbmRJbkxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5jaGFySW5kZXggPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRJbkxpbmUgPCBsaW5lR2x5cGhDb3VudCAtIHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50KSB7IC8vZG9uJ3QgaW5jbHVkZSB0cmFpbGluZyB3cyBpbiBmbGlwIHdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWluKGxlZnQsIGluZm8ueCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChyaWdodCwgaW5mby54ICsgaW5mby53aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBzdGFydEluTGluZTsgaiA8IGVuZEluTGluZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoSW5mbyA9IGxpbmUuZ2x5cGhBdChqKTtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmZvLnggPSByaWdodCAtIChnbHlwaEluZm8ueCArIGdseXBoSW5mby53aWR0aCAtIGxlZnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXNzZW1ibGUgZmluYWwgZGF0YSBhcnJheXNcbiAgICAgICAgICAgIGxldCBnbHlwaE9iajtcbiAgICAgICAgICAgIGNvbnN0IHNldEdseXBoT2JqID0gZyA9PiBnbHlwaE9iaiA9IGc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVHbHlwaENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGkpO1xuICAgICAgICAgICAgICBnbHlwaE9iaiA9IGdseXBoSW5mby5nbHlwaE9iajtcbiAgICAgICAgICAgICAgY29uc3QgZ2x5cGhJZCA9IGdseXBoT2JqLmluZGV4O1xuXG4gICAgICAgICAgICAgIC8vIFJlcGxhY2UgbWlycm9yZWQgY2hhcmFjdGVycyBpbiBydGxcbiAgICAgICAgICAgICAgY29uc3QgcnRsID0gYmlkaUxldmVsc1Jlc3VsdC5sZXZlbHNbZ2x5cGhJbmZvLmNoYXJJbmRleF0gJiAxOyAvL29kZCBsZXZlbCBtZWFucyBydGxcbiAgICAgICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pcnJvcmVkID0gYmlkaS5nZXRNaXJyb3JlZENoYXJhY3Rlcih0ZXh0W2dseXBoSW5mby5jaGFySW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAobWlycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgIGdseXBoSW5mby5mb250RGF0YS5mb250T2JqLmZvckVhY2hHbHlwaChtaXJyb3JlZCwgMCwgMCwgc2V0R2x5cGhPYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEFkZCBjYXJldCBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgaWYgKGluY2x1ZGVDYXJldFBvc2l0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtjaGFySW5kZXgsIGZvbnREYXRhfSA9IGdseXBoSW5mbztcbiAgICAgICAgICAgICAgICBjb25zdCBjYXJldExlZnQgPSBnbHlwaEluZm8ueCArIGFuY2hvclhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FyZXRSaWdodCA9IGdseXBoSW5mby54ICsgZ2x5cGhJbmZvLndpZHRoICsgYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1tjaGFySW5kZXggKiA0XSA9IHJ0bCA/IGNhcmV0UmlnaHQgOiBjYXJldExlZnQ7IC8vc3RhcnQgZWRnZSB4XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogNCArIDFdID0gcnRsID8gY2FyZXRMZWZ0IDogY2FyZXRSaWdodDsgLy9lbmQgZWRnZSB4XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogNCArIDJdID0gbGluZS5iYXNlbGluZSArIGZvbnREYXRhLmNhcmV0Qm90dG9tICsgYW5jaG9yWU9mZnNldDsgLy9jb21tb24gYm90dG9tIHlcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1tjaGFySW5kZXggKiA0ICsgM10gPSBsaW5lLmJhc2VsaW5lICsgZm9udERhdGEuY2FyZXRUb3AgKyBhbmNob3JZT2Zmc2V0OyAvL2NvbW1vbiB0b3AgeVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2Ugc2tpcHBlZCBhbnkgY2hhcnMgZnJvbSB0aGUgcHJldmlvdXMgZ2x5cGggKGR1ZSB0byBsaWdhdHVyZSBzdWJzKSwgZmlsbCBpbiBjYXJldFxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9ucyBmb3IgdGhvc2UgbWlzc2luZyBjaGFyIGluZGljZXM7IGN1cnJlbnRseSB0aGlzIHVzZXMgYSBiZXN0LWd1ZXNzIGJ5IGRpdmlkaW5nXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxpZ2F0dXJlJ3Mgd2lkdGggZXZlbmx5LiBJbiB0aGUgZnV0dXJlIHdlIG1heSB0cnkgdG8gdXNlIHRoZSBmb250J3MgTGlnYXR1cmVDYXJldExpc3RcbiAgICAgICAgICAgICAgICAvLyB0YWJsZSB0byBnZXQgYmV0dGVyIGludGVyaW9yIGNhcmV0IHBvc2l0aW9ucy5cbiAgICAgICAgICAgICAgICBjb25zdCBsaWdDb3VudCA9IGNoYXJJbmRleCAtIHByZXZDaGFySW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGxpZ0NvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgZmlsbExpZ2F0dXJlQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbnMsIHByZXZDaGFySW5kZXgsIGxpZ0NvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldkNoYXJJbmRleCA9IGNoYXJJbmRleDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFRyYWNrIGN1cnJlbnQgY29sb3IgcmFuZ2VcbiAgICAgICAgICAgICAgaWYgKGNvbG9yUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qge2NoYXJJbmRleH0gPSBnbHlwaEluZm87XG4gICAgICAgICAgICAgICAgd2hpbGUoY2hhckluZGV4ID4gY29sb3JDaGFySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIGNvbG9yQ2hhckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICBpZiAoY29sb3JSYW5nZXMuaGFzT3duUHJvcGVydHkoY29sb3JDaGFySW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb2xvciA9IGNvbG9yUmFuZ2VzW2NvbG9yQ2hhckluZGV4XTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBHZXQgYXRsYXMgZGF0YSBmb3IgcmVuZGVyYWJsZSBnbHlwaHNcbiAgICAgICAgICAgICAgaWYgKCFnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgIWdseXBoT2JqLmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSByZW5kZXJhYmxlR2x5cGhJbmRleCsrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHtmb250U2l6ZU11bHQsIHNyYzogZm9udFNyYywgaW5kZXg6IGZvbnRJbmRleH0gPSBnbHlwaEluZm8uZm9udERhdGE7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBnbHlwaCdzIHBhdGggZGF0YVxuICAgICAgICAgICAgICAgIGNvbnN0IGZvbnRHbHlwaERhdGEgPSBnbHlwaERhdGFbZm9udFNyY10gfHwgKGdseXBoRGF0YVtmb250U3JjXSA9IHt9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvbnRHbHlwaERhdGFbZ2x5cGhJZF0pIHtcbiAgICAgICAgICAgICAgICAgIGZvbnRHbHlwaERhdGFbZ2x5cGhJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGdseXBoT2JqLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhdGhCb3VuZHM6IFtnbHlwaE9iai54TWluLCBnbHlwaE9iai55TWluLCBnbHlwaE9iai54TWF4LCBnbHlwaE9iai55TWF4XVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgZmluYWwgZ2x5cGggcG9zaXRpb24gYW5kIGFkZCB0byBnbHlwaFBvc2l0aW9ucyBhcnJheVxuICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoWCA9IGdseXBoSW5mby54ICsgYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBnbHlwaFkgPSBnbHlwaEluZm8ueSArIGxpbmUuYmFzZWxpbmUgKyBhbmNob3JZT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGdseXBoUG9zaXRpb25zW2lkeCAqIDJdID0gZ2x5cGhYO1xuICAgICAgICAgICAgICAgIGdseXBoUG9zaXRpb25zW2lkeCAqIDIgKyAxXSA9IGdseXBoWTtcblxuICAgICAgICAgICAgICAgIC8vIFRyYWNrIHRvdGFsIHZpc2libGUgYm91bmRzXG4gICAgICAgICAgICAgICAgY29uc3QgdmlzWDAgPSBnbHlwaFggKyBnbHlwaE9iai54TWluICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpc1kwID0gZ2x5cGhZICsgZ2x5cGhPYmoueU1pbiAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNYMSA9IGdseXBoWCArIGdseXBoT2JqLnhNYXggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlzWTEgPSBnbHlwaFkgKyBnbHlwaE9iai55TWF4ICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgIGlmICh2aXNYMCA8IHZpc2libGVCb3VuZHNbMF0pIHZpc2libGVCb3VuZHNbMF0gPSB2aXNYMDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWTAgPCB2aXNpYmxlQm91bmRzWzFdKSB2aXNpYmxlQm91bmRzWzFdID0gdmlzWTA7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1gxID4gdmlzaWJsZUJvdW5kc1syXSkgdmlzaWJsZUJvdW5kc1syXSA9IHZpc1gxO1xuICAgICAgICAgICAgICAgIGlmICh2aXNZMSA+IHZpc2libGVCb3VuZHNbM10pIHZpc2libGVCb3VuZHNbM10gPSB2aXNZMTtcblxuICAgICAgICAgICAgICAgIC8vIFRyYWNrIGJvdW5kaW5nIHJlY3RzIGZvciBlYWNoIGNodW5rIG9mIE4gZ2x5cGhzXG4gICAgICAgICAgICAgICAgaWYgKGlkeCAlIGNodW5rZWRCb3VuZHNTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjaHVuayA9IHtzdGFydDogaWR4LCBlbmQ6IGlkeCwgcmVjdDogW0lORiwgSU5GLCAtSU5GLCAtSU5GXX07XG4gICAgICAgICAgICAgICAgICBjaHVua2VkQm91bmRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaHVuay5lbmQrKztcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1JlY3QgPSBjaHVuay5yZWN0O1xuICAgICAgICAgICAgICAgIGlmICh2aXNYMCA8IGNodW5rUmVjdFswXSkgY2h1bmtSZWN0WzBdID0gdmlzWDA7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1kwIDwgY2h1bmtSZWN0WzFdKSBjaHVua1JlY3RbMV0gPSB2aXNZMDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWDEgPiBjaHVua1JlY3RbMl0pIGNodW5rUmVjdFsyXSA9IHZpc1gxO1xuICAgICAgICAgICAgICAgIGlmICh2aXNZMSA+IGNodW5rUmVjdFszXSkgY2h1bmtSZWN0WzNdID0gdmlzWTE7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gZ2x5cGggaWRzIGFuZCBmb250IGluZGljZXMgYXJyYXlzXG4gICAgICAgICAgICAgICAgZ2x5cGhJZHNbaWR4XSA9IGdseXBoSWQ7XG4gICAgICAgICAgICAgICAgZ2x5cGhGb250SW5kaWNlc1tpZHhdID0gZm9udEluZGV4O1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGNvbG9yc1xuICAgICAgICAgICAgICAgIGlmIChjb2xvclJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBpZHggKiAzO1xuICAgICAgICAgICAgICAgICAgZ2x5cGhDb2xvcnNbc3RhcnRdID0gY3VycmVudENvbG9yID4+IDE2ICYgMjU1O1xuICAgICAgICAgICAgICAgICAgZ2x5cGhDb2xvcnNbc3RhcnQgKyAxXSA9IGN1cnJlbnRDb2xvciA+PiA4ICYgMjU1O1xuICAgICAgICAgICAgICAgICAgZ2x5cGhDb2xvcnNbc3RhcnQgKyAyXSA9IGN1cnJlbnRDb2xvciAmIDI1NTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpbGwgaW4gcmVtYWluaW5nIGNhcmV0IHBvc2l0aW9ucyBpbiBjYXNlIHRoZSBmaW5hbCBjaGFyYWN0ZXIgd2FzIGEgbGlnYXR1cmVcbiAgICAgICAgaWYgKGNhcmV0UG9zaXRpb25zKSB7XG4gICAgICAgICAgY29uc3QgbGlnQ291bnQgPSB0ZXh0Lmxlbmd0aCAtIHByZXZDaGFySW5kZXg7XG4gICAgICAgICAgaWYgKGxpZ0NvdW50ID4gMSkge1xuICAgICAgICAgICAgZmlsbExpZ2F0dXJlQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbnMsIHByZXZDaGFySW5kZXgsIGxpZ0NvdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQXNzZW1ibGUgZmluYWwgZGF0YSBhYm91dCBlYWNoIGZvbnQgdXNlZFxuICAgICAgY29uc3QgZm9udERhdGEgPSBbXTtcbiAgICAgIG1ldHJpY3NCeUZvbnQuZm9yRWFjaCgoe2luZGV4LCBzcmMsIHVuaXRzUGVyRW0sIGFzY2VuZGVyLCBkZXNjZW5kZXIsIGxpbmVIZWlnaHQsIGNhcEhlaWdodCwgeEhlaWdodH0pID0+IHtcbiAgICAgICAgZm9udERhdGFbaW5kZXhdID0ge3NyYywgdW5pdHNQZXJFbSwgYXNjZW5kZXIsIGRlc2NlbmRlciwgbGluZUhlaWdodCwgY2FwSGVpZ2h0LCB4SGVpZ2h0fTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUaW1pbmcgc3RhdHNcbiAgICAgIHRpbWluZ3MudHlwZXNldHRpbmcgPSBub3coKSAtIHR5cGVzZXRTdGFydDtcblxuICAgICAgY2FsbGJhY2soe1xuICAgICAgICBnbHlwaElkcywgLy9pZCBmb3IgZWFjaCBnbHlwaCwgc3BlY2lmaWMgdG8gdGhhdCBnbHlwaCdzIGZvbnRcbiAgICAgICAgZ2x5cGhGb250SW5kaWNlcywgLy9pbmRleCBpbnRvIGZvbnREYXRhIGZvciBlYWNoIGdseXBoXG4gICAgICAgIGdseXBoUG9zaXRpb25zLCAvL3gseSBvZiBlYWNoIGdseXBoJ3Mgb3JpZ2luIGluIGxheW91dFxuICAgICAgICBnbHlwaERhdGEsIC8vZGljdCBob2xkaW5nIGRhdGEgYWJvdXQgZWFjaCBnbHlwaCBhcHBlYXJpbmcgaW4gdGhlIHRleHRcbiAgICAgICAgZm9udERhdGEsIC8vZGF0YSBhYm91dCBlYWNoIGZvbnQgdXNlZCBpbiB0aGUgdGV4dFxuICAgICAgICBjYXJldFBvc2l0aW9ucywgLy9zdGFydFgsZW5kWCxib3R0b21ZIGNhcmV0IHBvc2l0aW9ucyBmb3IgZWFjaCBjaGFyXG4gICAgICAgIC8vIGNhcmV0SGVpZ2h0LCAvL2hlaWdodCBvZiBjdXJzb3IgZnJvbSBib3R0b20gdG8gdG9wIC0gdG9kbyBwZXIgZ2x5cGg/XG4gICAgICAgIGdseXBoQ29sb3JzLCAvL2NvbG9yIGZvciBlYWNoIGdseXBoLCBpZiBjb2xvciByYW5nZXMgc3VwcGxpZWRcbiAgICAgICAgY2h1bmtlZEJvdW5kcywgLy90b3RhbCByZWN0cyBwZXIgKG49Y2h1bmtlZEJvdW5kc1NpemUpIGNvbnNlY3V0aXZlIGdseXBoc1xuICAgICAgICBmb250U2l6ZSwgLy9jYWxjdWxhdGVkIGVtIGhlaWdodFxuICAgICAgICB0b3BCYXNlbGluZTogYW5jaG9yWU9mZnNldCArIGxpbmVzWzBdLmJhc2VsaW5lLCAvL3kgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxpbmUncyBiYXNlbGluZVxuICAgICAgICBibG9ja0JvdW5kczogWyAvL2JvdW5kcyBmb3IgdGhlIHdob2xlIGJsb2NrIG9mIHRleHQsIGluY2x1ZGluZyB2ZXJ0aWNhbCBwYWRkaW5nIGZvciBsaW5lSGVpZ2h0XG4gICAgICAgICAgYW5jaG9yWE9mZnNldCxcbiAgICAgICAgICBhbmNob3JZT2Zmc2V0IC0gdG90YWxIZWlnaHQsXG4gICAgICAgICAgYW5jaG9yWE9mZnNldCArIG1heExpbmVXaWR0aCxcbiAgICAgICAgICBhbmNob3JZT2Zmc2V0XG4gICAgICAgIF0sXG4gICAgICAgIHZpc2libGVCb3VuZHMsIC8vdG90YWwgYm91bmRzIG9mIHZpc2libGUgdGV4dCBwYXRocywgbWF5IGJlIGxhcmdlciBvciBzbWFsbGVyIHRoYW4gYmxvY2tCb3VuZHNcbiAgICAgICAgdGltaW5nc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBGb3IgYSBnaXZlbiB0ZXh0IHN0cmluZyBhbmQgZm9udCBwYXJhbWV0ZXJzLCBkZXRlcm1pbmUgdGhlIHJlc3VsdGluZyBibG9jayBkaW1lbnNpb25zXG4gICAqIGFmdGVyIHdyYXBwaW5nIGZvciB0aGUgZ2l2ZW4gbWF4V2lkdGguXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gbWVhc3VyZShhcmdzLCBjYWxsYmFjaykge1xuICAgIHR5cGVzZXQoey4uLmFyZ3MsIG1ldHJpY3NPbmx5OiB0cnVlfSwgKHJlc3VsdCkgPT4ge1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IHJlc3VsdC5ibG9ja0JvdW5kcztcbiAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgd2lkdGg6IHgxIC0geDAsXG4gICAgICAgIGhlaWdodDogeTEgLSB5MFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVBlcmNlbnQoc3RyKSB7XG4gICAgbGV0IG1hdGNoID0gc3RyLm1hdGNoKC9eKFtcXGQuXSspJSQvKTtcbiAgICBsZXQgcGN0ID0gbWF0Y2ggPyBwYXJzZUZsb2F0KG1hdGNoWzFdKSA6IE5hTjtcbiAgICByZXR1cm4gaXNOYU4ocGN0KSA/IDAgOiBwY3QgLyAxMDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGxMaWdhdHVyZUNhcmV0UG9zaXRpb25zKGNhcmV0UG9zaXRpb25zLCBsaWdTdGFydEluZGV4LCBsaWdDb3VudCkge1xuICAgIGNvbnN0IGxpZ1N0YXJ0WCA9IGNhcmV0UG9zaXRpb25zW2xpZ1N0YXJ0SW5kZXggKiA0XTtcbiAgICBjb25zdCBsaWdFbmRYID0gY2FyZXRQb3NpdGlvbnNbbGlnU3RhcnRJbmRleCAqIDQgKyAxXTtcbiAgICBjb25zdCBsaWdCb3R0b20gPSBjYXJldFBvc2l0aW9uc1tsaWdTdGFydEluZGV4ICogNCArIDJdO1xuICAgIGNvbnN0IGxpZ1RvcCA9IGNhcmV0UG9zaXRpb25zW2xpZ1N0YXJ0SW5kZXggKiA0ICsgM107XG4gICAgY29uc3QgZ3Vlc3NlZEFkdmFuY2VYID0gKGxpZ0VuZFggLSBsaWdTdGFydFgpIC8gbGlnQ291bnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaWdDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFydEluZGV4ID0gKGxpZ1N0YXJ0SW5kZXggKyBpKSAqIDQ7XG4gICAgICBjYXJldFBvc2l0aW9uc1tzdGFydEluZGV4XSA9IGxpZ1N0YXJ0WCArIGd1ZXNzZWRBZHZhbmNlWCAqIGk7XG4gICAgICBjYXJldFBvc2l0aW9uc1tzdGFydEluZGV4ICsgMV0gPSBsaWdTdGFydFggKyBndWVzc2VkQWR2YW5jZVggKiAoaSArIDEpO1xuICAgICAgY2FyZXRQb3NpdGlvbnNbc3RhcnRJbmRleCArIDJdID0gbGlnQm90dG9tO1xuICAgICAgY2FyZXRQb3NpdGlvbnNbc3RhcnRJbmRleCArIDNdID0gbGlnVG9wO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gKHNlbGYucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KClcbiAgfVxuXG4gIC8vIEFycmF5LWJhY2tlZCBzdHJ1Y3R1cmUgZm9yIGEgc2luZ2xlIGxpbmUncyBnbHlwaHMgZGF0YVxuICBmdW5jdGlvbiBUZXh0TGluZSgpIHtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgfVxuICBjb25zdCB0ZXh0TGluZVByb3BzID0gWydnbHlwaE9iaicsICd4JywgJ3knLCAnd2lkdGgnLCAnY2hhckluZGV4JywgJ2ZvbnREYXRhJ107XG4gIFRleHRMaW5lLnByb3RvdHlwZSA9IHtcbiAgICB3aWR0aDogMCxcbiAgICBsaW5lSGVpZ2h0OiAwLFxuICAgIGJhc2VsaW5lOiAwLFxuICAgIGNhcDogMCxcbiAgICBleDogMCxcbiAgICBpc1NvZnRXcmFwcGVkOiBmYWxzZSxcbiAgICBnZXQgY291bnQoKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZGF0YS5sZW5ndGggLyB0ZXh0TGluZVByb3BzLmxlbmd0aClcbiAgICB9LFxuICAgIGdseXBoQXQoaSkge1xuICAgICAgbGV0IGZseSA9IFRleHRMaW5lLmZseXdlaWdodDtcbiAgICAgIGZseS5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgZmx5LmluZGV4ID0gaTtcbiAgICAgIHJldHVybiBmbHlcbiAgICB9LFxuICAgIHNwbGl0QXQoaSkge1xuICAgICAgbGV0IG5ld0xpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgIG5ld0xpbmUuZGF0YSA9IHRoaXMuZGF0YS5zcGxpY2UoaSAqIHRleHRMaW5lUHJvcHMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXdMaW5lXG4gICAgfVxuICB9O1xuICBUZXh0TGluZS5mbHl3ZWlnaHQgPSB0ZXh0TGluZVByb3BzLnJlZHVjZSgob2JqLCBwcm9wLCBpLCBhbGwpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5pbmRleCAqIHRleHRMaW5lUHJvcHMubGVuZ3RoICsgaV1cbiAgICAgIH0sXG4gICAgICBzZXQodmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLmluZGV4ICogdGV4dExpbmVQcm9wcy5sZW5ndGggKyBpXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqXG4gIH0sIHtkYXRhOiBudWxsLCBpbmRleDogMH0pO1xuXG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlc2V0LFxuICAgIG1lYXN1cmUsXG4gIH1cbn1cblxuY29uc3Qgbm93ID0gKCkgPT4gKHNlbGYucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KCk7XG5cbmNvbnN0IG1haW5UaHJlYWRHZW5lcmF0b3IgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNERkdlbmVyYXRvcigpO1xuXG5sZXQgd2FybmVkO1xuXG4vKipcbiAqIEdlbmVyYXRlIGFuIFNERiB0ZXh0dXJlIGltYWdlIGZvciBhIHNpbmdsZSBnbHlwaCBwYXRoLCBwbGFjaW5nIHRoZSByZXN1bHQgaW50byBhIHdlYmdsIGNhbnZhcyBhdCBhXG4gKiBnaXZlbiBsb2NhdGlvbiBhbmQgY2hhbm5lbC4gVXRpbGl6ZXMgdGhlIHdlYmdsLXNkZi1nZW5lcmF0b3IgZXh0ZXJuYWwgcGFja2FnZSBmb3IgR1BVLWFjY2VsZXJhdGVkIFNERlxuICogZ2VuZXJhdGlvbiB3aGVuIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVTREYod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwsIHVzZVdlYkdMID0gdHJ1ZSkge1xuICAvLyBBbGxvdyBvcHQtb3V0XG4gIGlmICghdXNlV2ViR0wpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVTREZfSlNfV29ya2VyKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKVxuICB9XG5cbiAgLy8gQXR0ZW1wdCBHUFUtYWNjZWxlcmF0ZWQgZ2VuZXJhdGlvbiBmaXJzdFxuICByZXR1cm4gZ2VuZXJhdGVTREZfR0wod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpLnRoZW4oXG4gICAgbnVsbCxcbiAgICBlcnIgPT4ge1xuICAgICAgLy8gV2ViR0wgZmFpbGVkIGVpdGhlciBkdWUgdG8gYSBoYXJkIGVycm9yIG9yIHVuZXhwZWN0ZWQgcmVzdWx0czsgZmFsbCBiYWNrIHRvIEpTIGluIHdvcmtlcnNcbiAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgV2ViR0wgU0RGIGdlbmVyYXRpb24gZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gSlNgLCBlcnIpO1xuICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdlbmVyYXRlU0RGX0pTX1dvcmtlcih3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbClcbiAgICB9XG4gIClcbn1cblxuY29uc3QgcXVldWUgPSBbXTtcbmNvbnN0IGNodW5rVGltZUJ1ZGdldCA9IDU7IC8vIG1zXG5sZXQgdGltZXIgPSAwO1xuXG5mdW5jdGlvbiBuZXh0Q2h1bmsoKSB7XG4gIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gIHdoaWxlIChxdWV1ZS5sZW5ndGggJiYgbm93KCkgLSBzdGFydCA8IGNodW5rVGltZUJ1ZGdldCkge1xuICAgIHF1ZXVlLnNoaWZ0KCkoKTtcbiAgfVxuICB0aW1lciA9IHF1ZXVlLmxlbmd0aCA/IHNldFRpbWVvdXQobmV4dENodW5rLCAwKSA6IDA7XG59XG5cbi8qKlxuICogV2ViR0wtYmFzZWQgaW1wbGVtZW50YXRpb24gZXhlY3V0ZWQgb24gdGhlIG1haW4gdGhyZWFkLiBSZXF1ZXN0cyBhcmUgZXhlY3V0ZWQgaW4gdGltZS1ib3VuZGVkXG4gKiBtYWNyb3Rhc2sgY2h1bmtzIHRvIGFsbG93IHJlbmRlciBmcmFtZXMgdG8gZXhlY3V0ZSBpbiBiZXR3ZWVuLlxuICovXG5jb25zdCBnZW5lcmF0ZVNERl9HTCA9ICguLi5hcmdzKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcXVldWUucHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9IG5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbC5nZW5lcmF0ZUludG9DYW52YXMoLi4uYXJncyk7XG4gICAgICAgIHJlc29sdmUoeyB0aW1pbmc6IG5vdygpIC0gc3RhcnQgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCF0aW1lcikge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KG5leHRDaHVuaywgMCk7XG4gICAgfVxuICB9KVxufTtcblxuY29uc3QgdGhyZWFkQ291bnQgPSA0OyAvLyBob3cgbWFueSB3b3JrZXJzIHRvIHNwYXduXG5jb25zdCBpZGxlVGltZW91dCA9IDIwMDA7IC8vIHdvcmtlcnMgd2lsbCBiZSB0ZXJtaW5hdGVkIGFmdGVyIGJlaW5nIGlkbGUgdGhpcyBtYW55IG1pbGxpc2Vjb25kc1xuY29uc3QgdGhyZWFkcyA9IHt9O1xubGV0IGNhbGxOdW0gPSAwO1xuXG4vKipcbiAqIEZhbGxiYWNrIEpTLWJhc2VkIGltcGxlbWVudGF0aW9uLCBmYW5uZWQgb3V0IHRvIGEgbnVtYmVyIG9mIHdvcmtlciB0aHJlYWRzIGZvciBwYXJhbGxlbGlzbVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNERl9KU19Xb3JrZXIod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpIHtcbiAgY29uc3Qgd29ya2VySWQgPSAnVHJvaWthVGV4dFNERkdlbmVyYXRvcl9KU18nICsgKChjYWxsTnVtKyspICUgdGhyZWFkQ291bnQpO1xuICBsZXQgdGhyZWFkID0gdGhyZWFkc1t3b3JrZXJJZF07XG4gIGlmICghdGhyZWFkKSB7XG4gICAgdGhyZWFkID0gdGhyZWFkc1t3b3JrZXJJZF0gPSB7XG4gICAgICB3b3JrZXJNb2R1bGU6IGRlZmluZVdvcmtlck1vZHVsZSh7XG4gICAgICAgIG5hbWU6IHdvcmtlcklkLFxuICAgICAgICB3b3JrZXJJZCxcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICAgICAgY3JlYXRlU0RGR2VuZXJhdG9yLFxuICAgICAgICAgIG5vd1xuICAgICAgICBdLFxuICAgICAgICBpbml0KF9jcmVhdGVTREZHZW5lcmF0b3IsIG5vdykge1xuICAgICAgICAgIGNvbnN0IGdlbmVyYXRlID0gX2NyZWF0ZVNERkdlbmVyYXRvcigpLmphdmFzY3JpcHQuZ2VuZXJhdGU7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG5vdygpO1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZURhdGEgPSBnZW5lcmF0ZSguLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRleHR1cmVEYXRhLFxuICAgICAgICAgICAgICB0aW1pbmc6IG5vdygpIC0gc3RhcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRyYW5zZmVyYWJsZXMocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIFtyZXN1bHQudGV4dHVyZURhdGEuYnVmZmVyXVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHJlcXVlc3RzOiAwLFxuICAgICAgaWRsZVRpbWVyOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHRocmVhZC5yZXF1ZXN0cysrO1xuICBjbGVhclRpbWVvdXQodGhyZWFkLmlkbGVUaW1lcik7XG4gIHJldHVybiB0aHJlYWQud29ya2VyTW9kdWxlKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudClcbiAgICAudGhlbigoeyB0ZXh0dXJlRGF0YSwgdGltaW5nIH0pID0+IHtcbiAgICAgIC8vIGNvcHkgcmVzdWx0IGRhdGEgaW50byB0aGUgY2FudmFzXG4gICAgICBjb25zdCBzdGFydCA9IG5vdygpO1xuICAgICAgLy8gZXhwYW5kIHNpbmdsZS1jaGFubmVsIGRhdGEgaW50byByZ2JhXG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlRGF0YS5sZW5ndGggKiA0KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dHVyZURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW1hZ2VEYXRhW2kgKiA0ICsgY2hhbm5lbF0gPSB0ZXh0dXJlRGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIG1haW5UaHJlYWRHZW5lcmF0b3Iud2ViZ2xVdGlscy5yZW5kZXJJbWFnZURhdGEoY2FudmFzLCBpbWFnZURhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEgPDwgKDMgLSBjaGFubmVsKSk7XG4gICAgICB0aW1pbmcgKz0gbm93KCkgLSBzdGFydDtcblxuICAgICAgLy8gY2xlYW4gdXAgd29ya2VycyBhZnRlciBhIHdoaWxlXG4gICAgICBpZiAoLS10aHJlYWQucmVxdWVzdHMgPT09IDApIHtcbiAgICAgICAgdGhyZWFkLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyB0ZXJtaW5hdGVXb3JrZXIod29ya2VySWQpOyB9LCBpZGxlVGltZW91dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0aW1pbmcgfVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIHdhcm1VcFNERkNhbnZhcyhjYW52YXMpIHtcbiAgaWYgKCFjYW52YXMuX3dhcm0pIHtcbiAgICBtYWluVGhyZWFkR2VuZXJhdG9yLndlYmdsLmlzU3VwcG9ydGVkKGNhbnZhcyk7XG4gICAgY2FudmFzLl93YXJtID0gdHJ1ZTtcbiAgfVxufVxuXG5jb25zdCByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZyA9IG1haW5UaHJlYWRHZW5lcmF0b3Iud2ViZ2xVdGlscy5yZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZztcblxuY29uc3QgQ09ORklHID0ge1xuICBkZWZhdWx0Rm9udFVSTDogbnVsbCxcbiAgdW5pY29kZUZvbnRzVVJMOiBudWxsLFxuICBzZGZHbHlwaFNpemU6IDY0LFxuICBzZGZNYXJnaW46IDEgLyAxNixcbiAgc2RmRXhwb25lbnQ6IDksXG4gIHRleHR1cmVXaWR0aDogMjA0OCxcbiAgdXNlV29ya2VyOiB0cnVlLFxufTtcbmNvbnN0IHRlbXBDb2xvciA9IC8qI19fUFVSRV9fKi9uZXcgQ29sb3IoKTtcbmxldCBoYXNSZXF1ZXN0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gbm93JDEoKSB7XG4gIHJldHVybiAoc2VsZi5wZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKVxufVxuXG4vKipcbiAqIEN1c3RvbWl6ZXMgdGhlIHRleHQgYnVpbGRlciBjb25maWd1cmF0aW9uLiBUaGlzIG11c3QgYmUgY2FsbGVkIHByaW9yIHRvIHRoZSBmaXJzdCBmb250IHByb2Nlc3NpbmdcbiAqIHJlcXVlc3QsIGFuZCBhcHBsaWVzIHRvIGFsbCBmb250cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRlZmF1bHRGb250VVJMIC0gVGhlIFVSTCBvZiB0aGUgZGVmYXVsdCBmb250IHRvIHVzZSBmb3IgdGV4dCBwcm9jZXNzaW5nXG4gKiAgICAgICAgICAgICAgICAgcmVxdWVzdHMsIGluIGNhc2Ugbm9uZSBpcyBzcGVjaWZpZWQgb3IgdGhlIHNwZWNpZmllZGUgZm9udCBmYWlscyB0byBsb2FkIG9yIHBhcnNlLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIFwiUm9ib3RvIFJlZ3VsYXJcIiBmcm9tIEdvb2dsZSBGb250cy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudW5pY29kZUZvbnRzVVJMIC0gQSBjdXN0b20gbG9jYXRpb24gZm9yIHRoZSBmYWxsYmFjayB1bmljb2RlLWZvbnQtcmVzb2x2ZXJcbiAqICAgICAgICAgICAgICAgICBkYXRhIGFuZCBmb250IGZpbGVzLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIGRlZmF1bHQgQ0ROLiBTZWVcbiAqICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vbG9qamljL3VuaWNvZGUtZm9udC1yZXNvbHZlciBmb3IgZGV0YWlscy4gSXQgY2FuIGFsc28gYmVcbiAqICAgICAgICAgICAgICAgICBjb25maWd1cmVkIHBlciB0ZXh0IGluc3RhbmNlLCBidXQgdGhpcyBsZXRzIHlvdSBkbyBpdCBvbmNlIGdsb2JhbGx5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5zZGZHbHlwaFNpemUgLSBUaGUgZGVmYXVsdCBzaXplIG9mIGVhY2ggZ2x5cGgncyBTREYgKHNpZ25lZCBkaXN0YW5jZSBmaWVsZClcbiAqICAgICAgICAgICAgICAgICB0ZXh0dXJlIHVzZWQgZm9yIHJlbmRlcmluZy4gTXVzdCBiZSBhIHBvd2VyLW9mLXR3byBudW1iZXIsIGFuZCBhcHBsaWVzIHRvIGFsbCBmb250cyxcbiAqICAgICAgICAgICAgICAgICBidXQgbm90ZSB0aGF0IHRoaXMgY2FuIGFsc28gYmUgb3ZlcnJpZGRlbiBwZXIgY2FsbCB0byBgZ2V0VGV4dFJlbmRlckluZm8oKWAuXG4gKiAgICAgICAgICAgICAgICAgTGFyZ2VyIHNpemVzIGNhbiBpbXByb3ZlIHRoZSBxdWFsaXR5IG9mIGdseXBoIHJlbmRlcmluZyBieSBpbmNyZWFzaW5nIHRoZSBzaGFycG5lc3NcbiAqICAgICAgICAgICAgICAgICBvZiBjb3JuZXJzIGFuZCBwcmV2ZW50aW5nIGxvc3Mgb2YgdmVyeSB0aGluIGxpbmVzLCBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkuIERlZmF1bHRzXG4gKiAgICAgICAgICAgICAgICAgdG8gNjQgd2hpY2ggaXMgZ2VuZXJhbGx5IGEgZ29vZCBiYWxhbmNlIG9mIHNpemUgYW5kIHF1YWxpdHkuXG4gKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZkV4cG9uZW50IC0gVGhlIGV4cG9uZW50IHVzZWQgd2hlbiBlbmNvZGluZyB0aGUgU0RGIHZhbHVlcy4gQSBoaWdoZXIgZXhwb25lbnRcbiAqICAgICAgICAgICAgICAgICBzaGlmdHMgdGhlIGVuY29kZWQgOC1iaXQgdmFsdWVzIHRvIGFjaGlldmUgaGlnaGVyIHByZWNpc2lvbi9hY2N1cmFjeSBhdCB0ZXhlbHMgbmVhcmVyXG4gKiAgICAgICAgICAgICAgICAgdGhlIGdseXBoJ3MgcGF0aCwgd2l0aCBsb3dlciBwcmVjaXNpb24gZnVydGhlciBhd2F5LiBEZWZhdWx0cyB0byA5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5zZGZNYXJnaW4gLSBIb3cgbXVjaCBzcGFjZSB0byByZXNlcnZlIGluIHRoZSBTREYgYXMgbWFyZ2luIG91dHNpZGUgdGhlIGdseXBoJ3NcbiAqICAgICAgICAgICAgICAgICBwYXRoLCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIFNERiB3aWR0aC4gQSBsYXJnZXIgbWFyZ2luIGluY3JlYXNlcyB0aGUgcXVhbGl0eSBvZlxuICogICAgICAgICAgICAgICAgIGV4dHJ1ZGVkIGdseXBoIG91dGxpbmVzLCBidXQgZGVjcmVhc2VzIHRoZSBwcmVjaXNpb24gYXZhaWxhYmxlIGZvciB0aGUgZ2x5cGggaXRzZWxmLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIDEvMTZ0aCBvZiB0aGUgZ2x5cGggc2l6ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcudGV4dHVyZVdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBTREYgdGV4dHVyZTsgbXVzdCBiZSBhIHBvd2VyIG9mIDIuIERlZmF1bHRzIHRvXG4gKiAgICAgICAgICAgICAgICAgMjA0OCB3aGljaCBpcyBhIHNhZmUgbWF4aW11bSB0ZXh0dXJlIGRpbWVuc2lvbiBhY2NvcmRpbmcgdG8gdGhlIHN0YXRzIGF0XG4gKiAgICAgICAgICAgICAgICAgaHR0cHM6Ly93ZWJnbHN0YXRzLmNvbS93ZWJnbC9wYXJhbWV0ZXIvTUFYX1RFWFRVUkVfU0laRSBhbmQgc2hvdWxkIGFsbG93IGZvciBhXG4gKiAgICAgICAgICAgICAgICAgcmVhc29uYWJseSBsYXJnZSBudW1iZXIgb2YgZ2x5cGhzIChkZWZhdWx0IGdseXBoIHNpemUgb2YgNjReMiBhbmQgc2FmZSB0ZXh0dXJlIHNpemUgb2ZcbiAqICAgICAgICAgICAgICAgICAyMDQ4XjIsIHRpbWVzIDQgY2hhbm5lbHMsIGFsbG93cyBmb3IgNDA5NiBnbHlwaHMuKSBUaGlzIGNhbiBiZSBpbmNyZWFzZWQgaWYgeW91IG5lZWQgdG9cbiAqICAgICAgICAgICAgICAgICBpbmNyZWFzZSB0aGUgZ2x5cGggc2l6ZSBhbmQvb3IgaGF2ZSBhbiBleHRyYW9yZGluYXJ5IG51bWJlciBvZiBnbHlwaHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbmZpZy51c2VXb3JrZXIgLSBXaGV0aGVyIHRvIHJ1biB0eXBlc2V0dGluZyBpbiBhIHdlYiB3b3JrZXIuIERlZmF1bHRzIHRvIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZVRleHRCdWlsZGVyKGNvbmZpZykge1xuICBpZiAoaGFzUmVxdWVzdGVkKSB7XG4gICAgY29uc29sZS53YXJuKCdjb25maWd1cmVUZXh0QnVpbGRlciBjYWxsZWQgYWZ0ZXIgZmlyc3QgZm9udCByZXF1ZXN0OyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gIH0gZWxzZSB7XG4gICAgYXNzaWduKENPTkZJRywgY29uZmlnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcG9zaXRvcnkgZm9yIGFsbCBmb250IFNERiBhdGxhcyB0ZXh0dXJlcyBhbmQgdGhlaXIgZ2x5cGggbWFwcGluZ3MuIFRoZXJlIGlzIGEgc2VwYXJhdGUgYXRsYXMgZm9yXG4gKiBlYWNoIHNkZkdseXBoU2l6ZS4gRWFjaCBhdGxhcyBoYXMgYSBzaW5nbGUgVGV4dHVyZSB0aGF0IGhvbGRzIGFsbCBnbHlwaHMgZm9yIGFsbCBmb250cy5cbiAqXG4gKiAgIHtcbiAqICAgICBbc2RmR2x5cGhTaXplXToge1xuICogICAgICAgZ2x5cGhDb3VudDogbnVtYmVyLFxuICogICAgICAgc2RmR2x5cGhTaXplOiBudW1iZXIsXG4gKiAgICAgICBzZGZUZXh0dXJlOiBUZXh0dXJlLFxuICogICAgICAgc2RmQ2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcbiAqICAgICAgIGNvbnRleHRMb3N0OiBib29sZWFuLFxuICogICAgICAgZ2x5cGhzQnlGb250OiBNYXA8Zm9udFVSTCwgTWFwPGdseXBoSUQsIHtwYXRoLCBhdGxhc0luZGV4LCBzZGZWaWV3Qm94fT4+XG4gKiAgICAgfVxuICogICB9XG4gKi9cbmNvbnN0IGF0bGFzZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRyb2lrYVRleHRSZW5kZXJJbmZvIC0gRm9ybWF0IG9mIHRoZSByZXN1bHQgZnJvbSBgZ2V0VGV4dFJlbmRlckluZm9gLlxuICogQHByb3BlcnR5IHtUeXBlc2V0UGFyYW1zfSBwYXJhbWV0ZXJzIC0gVGhlIG5vcm1hbGl6ZWQgaW5wdXQgYXJndW1lbnRzIHRvIHRoZSByZW5kZXIgY2FsbC5cbiAqIEBwcm9wZXJ0eSB7VGV4dHVyZX0gc2RmVGV4dHVyZSAtIFRoZSBTREYgYXRsYXMgdGV4dHVyZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZGZHbHlwaFNpemUgLSBUaGUgc2l6ZSBvZiBlYWNoIGdseXBoJ3MgU0RGOyBzZWUgYGNvbmZpZ3VyZVRleHRCdWlsZGVyYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZGZFeHBvbmVudCAtIFRoZSBleHBvbmVudCB1c2VkIGluIGVuY29kaW5nIHRoZSBTREYncyB2YWx1ZXM7IHNlZSBgY29uZmlndXJlVGV4dEJ1aWxkZXJgLlxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGdseXBoQm91bmRzIC0gTGlzdCBvZiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gcXVhZCBib3VuZHMgZm9yIGVhY2ggZ2x5cGguXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gZ2x5cGhBdGxhc0luZGljZXMgLSBMaXN0IGhvbGRpbmcgZWFjaCBnbHlwaCdzIGluZGV4IGluIHRoZSBTREYgYXRsYXMuXG4gKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IFtnbHlwaENvbG9yc10gLSBMaXN0IGhvbGRpbmcgZWFjaCBnbHlwaCdzIFtyLCBnLCBiXSBjb2xvciwgaWYgYGNvbG9yUmFuZ2VzYCB3YXMgc3VwcGxpZWQuXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gW2NhcmV0UG9zaXRpb25zXSAtIEEgbGlzdCBvZiBjYXJldCBwb3NpdGlvbnMgZm9yIGFsbCBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmc7IGVhY2ggaXNcbiAqICAgICAgICAgICBmb3VyIGVsZW1lbnRzOiB0aGUgc3RhcnRpbmcgWCwgdGhlIGVuZGluZyBYLCB0aGUgYm90dG9tIFksIGFuZCB0aGUgdG9wIFkgZm9yIHRoZSBjYXJldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FyZXRIZWlnaHRdIC0gQW4gYXBwcm9wcmlhdGUgaGVpZ2h0IGZvciBhbGwgc2VsZWN0aW9uIGNhcmV0cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhc2NlbmRlciAtIFRoZSBmb250J3MgYXNjZW5kZXIgbWV0cmljLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlc2NlbmRlciAtIFRoZSBmb250J3MgZGVzY2VuZGVyIG1ldHJpYy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYXBIZWlnaHQgLSBUaGUgZm9udCdzIGNhcCBoZWlnaHQgbWV0cmljLCBiYXNlZCBvbiB0aGUgaGVpZ2h0IG9mIExhdGluIGNhcGl0YWwgbGV0dGVycy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SGVpZ2h0IC0gVGhlIGZvbnQncyB4IGhlaWdodCBtZXRyaWMsIGJhc2VkIG9uIHRoZSBoZWlnaHQgb2YgTGF0aW4gbG93ZXJjYXNlIGxldHRlcnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZUhlaWdodCAtIFRoZSBmaW5hbCBjb21wdXRlZCBsaW5lSGVpZ2h0IG1lYXN1cmVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcEJhc2VsaW5lIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHRvcCBsaW5lJ3MgYmFzZWxpbmUuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGJsb2NrQm91bmRzIC0gVGhlIHRvdGFsIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSByZWN0IG9mIHRoZSB3aG9sZSB0ZXh0IGJsb2NrO1xuICogICAgICAgICAgIHRoaXMgY2FuIGluY2x1ZGUgZXh0cmEgdmVydGljYWwgc3BhY2UgYmV5b25kIHRoZSB2aXNpYmxlIGdseXBocyBkdWUgdG8gbGluZUhlaWdodCwgYW5kIGlzXG4gKiAgICAgICAgICAgZXF1aXZhbGVudCB0byB0aGUgZGltZW5zaW9ucyBvZiBhIGJsb2NrLWxldmVsIHRleHQgZWxlbWVudCBpbiBDU1MuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IHZpc2libGVCb3VuZHMgLSBUaGUgdG90YWwgW21pblgsIG1pblksIG1heFgsIG1heFldIHJlY3Qgb2YgdGhlIHdob2xlIHRleHQgYmxvY2s7XG4gKiAgICAgICAgICAgdW5saWtlIGBibG9ja0JvdW5kc2AgdGhpcyBpcyB0aWdodGx5IHdyYXBwZWQgdG8gdGhlIHZpc2libGUgZ2x5cGggcGF0aHMuXG4gKiBAcHJvcGVydHkge0FycmF5PG9iamVjdD59IGNodW5rZWRCb3VuZHMgLSBMaXN0IG9mIGJvdW5kaW5nIHJlY3RzIGZvciBlYWNoIGNvbnNlY3V0aXZlIHNldCBvZiBOIGdseXBocyxcbiAqICAgICAgICAgICBpbiB0aGUgZm9ybWF0IGB7c3RhcnQ6TiwgZW5kOk4sIHJlY3Q6W21pblgsIG1pblksIG1heFgsIG1heFldfWAuXG4gKiBAcHJvcGVydHkge29iamVjdH0gdGltaW5ncyAtIFRpbWluZyBpbmZvIGZvciB2YXJpb3VzIHBhcnRzIG9mIHRoZSByZW5kZXJpbmcgbG9naWMgaW5jbHVkaW5nIFNERlxuICogICAgICAgICAgIGdlbmVyYXRpb24sIHR5cGVzZXR0aW5nLCBldGMuXG4gKiBAZnJvemVuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZ2V0VGV4dFJlbmRlckluZm9+Y2FsbGJhY2tcbiAqIEBwYXJhbSB7VHJvaWthVGV4dFJlbmRlckluZm99IHRleHRSZW5kZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBNYWluIGVudHJ5IHBvaW50IGZvciByZXF1ZXN0aW5nIHRoZSBkYXRhIG5lZWRlZCB0byByZW5kZXIgYSB0ZXh0IHN0cmluZyB3aXRoIGdpdmVuIGZvbnQgcGFyYW1ldGVycy5cbiAqIFRoaXMgaXMgYW4gYXN5bmNocm9ub3VzIGNhbGwsIHBlcmZvcm1pbmcgbW9zdCBvZiB0aGUgbG9naWMgaW4gYSB3ZWIgd29ya2VyIHRocmVhZC5cbiAqIEBwYXJhbSB7VHlwZXNldFBhcmFtc30gYXJnc1xuICogQHBhcmFtIHtnZXRUZXh0UmVuZGVySW5mb35jYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dFJlbmRlckluZm8oYXJncywgY2FsbGJhY2spIHtcbiAgaGFzUmVxdWVzdGVkID0gdHJ1ZTtcbiAgYXJncyA9IGFzc2lnbih7fSwgYXJncyk7XG4gIGNvbnN0IHRvdGFsU3RhcnQgPSBub3ckMSgpO1xuXG4gIC8vIENvbnZlcnQgcmVsYXRpdmUgVVJMIHRvIGFic29sdXRlIHNvIGl0IGNhbiBiZSByZXNvbHZlZCBpbiB0aGUgd29ya2VyLCBhbmQgYWRkIGZhbGxiYWNrcy5cbiAgLy8gSW4gdGhlIGZ1dHVyZSB3ZSdsbCBhbGxvdyBhcmdzLmZvbnQgdG8gYmUgYSBsaXN0IHdpdGggdW5pY29kZSByYW5nZXMgdG9vLlxuICBjb25zdCB7IGRlZmF1bHRGb250VVJMIH0gPSBDT05GSUc7XG4gIGNvbnN0IGZvbnRzID0gW107XG4gIGlmIChkZWZhdWx0Rm9udFVSTCkge1xuICAgIGZvbnRzLnB1c2goe2xhYmVsOiAnZGVmYXVsdCcsIHNyYzogdG9BYnNvbHV0ZVVSTChkZWZhdWx0Rm9udFVSTCl9KTtcbiAgfVxuICBpZiAoYXJncy5mb250KSB7XG4gICAgZm9udHMucHVzaCh7bGFiZWw6ICd1c2VyJywgc3JjOiB0b0Fic29sdXRlVVJMKGFyZ3MuZm9udCl9KTtcbiAgfVxuICBhcmdzLmZvbnQgPSBmb250cztcblxuICAvLyBOb3JtYWxpemUgdGV4dCB0byBhIHN0cmluZ1xuICBhcmdzLnRleHQgPSAnJyArIGFyZ3MudGV4dDtcblxuICBhcmdzLnNkZkdseXBoU2l6ZSA9IGFyZ3Muc2RmR2x5cGhTaXplIHx8IENPTkZJRy5zZGZHbHlwaFNpemU7XG4gIGFyZ3MudW5pY29kZUZvbnRzVVJMID0gYXJncy51bmljb2RlRm9udHNVUkwgfHwgQ09ORklHLnVuaWNvZGVGb250c1VSTDtcblxuICAvLyBOb3JtYWxpemUgY29sb3JzXG4gIGlmIChhcmdzLmNvbG9yUmFuZ2VzICE9IG51bGwpIHtcbiAgICBsZXQgY29sb3JzID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGFyZ3MuY29sb3JSYW5nZXMpIHtcbiAgICAgIGlmIChhcmdzLmNvbG9yUmFuZ2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgbGV0IHZhbCA9IGFyZ3MuY29sb3JSYW5nZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdmFsID0gdGVtcENvbG9yLnNldCh2YWwpLmdldEhleCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbG9yc1trZXldID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICBhcmdzLmNvbG9yUmFuZ2VzID0gY29sb3JzO1xuICB9XG5cbiAgT2JqZWN0LmZyZWV6ZShhcmdzKTtcblxuICAvLyBJbml0IHRoZSBhdGxhcyBpZiBuZWVkZWRcbiAgY29uc3Qge3RleHR1cmVXaWR0aCwgc2RmRXhwb25lbnR9ID0gQ09ORklHO1xuICBjb25zdCB7c2RmR2x5cGhTaXplfSA9IGFyZ3M7XG4gIGNvbnN0IGdseXBoc1BlclJvdyA9ICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUgKiA0KTtcbiAgbGV0IGF0bGFzID0gYXRsYXNlc1tzZGZHbHlwaFNpemVdO1xuICBpZiAoIWF0bGFzKSB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gdGV4dHVyZVdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzZGZHbHlwaFNpemUgKiAyNTYgLyBnbHlwaHNQZXJSb3c7IC8vIHN0YXJ0IHRhbGwgZW5vdWdoIHRvIGZpdCAyNTYgZ2x5cGhzXG4gICAgYXRsYXMgPSBhdGxhc2VzW3NkZkdseXBoU2l6ZV0gPSB7XG4gICAgICBnbHlwaENvdW50OiAwLFxuICAgICAgc2RmR2x5cGhTaXplLFxuICAgICAgc2RmQ2FudmFzOiBjYW52YXMsXG4gICAgICBzZGZUZXh0dXJlOiBuZXcgVGV4dHVyZShcbiAgICAgICAgY2FudmFzLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBMaW5lYXJGaWx0ZXIsXG4gICAgICAgIExpbmVhckZpbHRlclxuICAgICAgKSxcbiAgICAgIGNvbnRleHRMb3N0OiBmYWxzZSxcbiAgICAgIGdseXBoc0J5Rm9udDogbmV3IE1hcCgpXG4gICAgfTtcbiAgICBhdGxhcy5zZGZUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgIGluaXRDb250ZXh0TG9zc0hhbmRsaW5nKGF0bGFzKTtcbiAgfVxuXG4gIGNvbnN0IHtzZGZUZXh0dXJlLCBzZGZDYW52YXN9ID0gYXRsYXM7XG5cbiAgLy8gSXNzdWUgcmVxdWVzdCB0byB0aGUgdHlwZXNldHRpbmcgZW5naW5lIGluIHRoZSB3b3JrZXJcbiAgY29uc3QgdHlwZXNldCA9IENPTkZJRy51c2VXb3JrZXIgPyB0eXBlc2V0SW5Xb3JrZXIgOiB0eXBlc2V0T25NYWluVGhyZWFkO1xuICB0eXBlc2V0KGFyZ3MpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICBjb25zdCB7Z2x5cGhJZHMsIGdseXBoRm9udEluZGljZXMsIGZvbnREYXRhLCBnbHlwaFBvc2l0aW9ucywgZm9udFNpemUsIHRpbWluZ3N9ID0gcmVzdWx0O1xuICAgIGNvbnN0IG5lZWRlZFNERnMgPSBbXTtcbiAgICBjb25zdCBnbHlwaEJvdW5kcyA9IG5ldyBGbG9hdDMyQXJyYXkoZ2x5cGhJZHMubGVuZ3RoICogNCk7XG4gICAgbGV0IGJvdW5kc0lkeCA9IDA7XG4gICAgbGV0IHBvc2l0aW9uc0lkeCA9IDA7XG4gICAgY29uc3QgcXVhZHNTdGFydCA9IG5vdyQxKCk7XG5cbiAgICBjb25zdCBmb250R2x5cGhNYXBzID0gZm9udERhdGEubWFwKGZvbnQgPT4ge1xuICAgICAgbGV0IG1hcCA9IGF0bGFzLmdseXBoc0J5Rm9udC5nZXQoZm9udC5zcmMpO1xuICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgYXRsYXMuZ2x5cGhzQnlGb250LnNldChmb250LnNyYywgbWFwID0gbmV3IE1hcCgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBcbiAgICB9KTtcblxuICAgIGdseXBoSWRzLmZvckVhY2goKGdseXBoSWQsIGkpID0+IHtcbiAgICAgIGNvbnN0IGZvbnRJbmRleCA9IGdseXBoRm9udEluZGljZXNbaV07XG4gICAgICBjb25zdCB7c3JjOiBmb250U3JjLCB1bml0c1BlckVtfSA9IGZvbnREYXRhW2ZvbnRJbmRleF07XG4gICAgICBsZXQgZ2x5cGhJbmZvID0gZm9udEdseXBoTWFwc1tmb250SW5kZXhdLmdldChnbHlwaElkKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIGdseXBoSWQgbm90IHNlZW4gYmVmb3JlLCBhZGQgaXQgdG8gdGhlIGF0bGFzXG4gICAgICBpZiAoIWdseXBoSW5mbykge1xuICAgICAgICBjb25zdCB7cGF0aCwgcGF0aEJvdW5kc30gPSByZXN1bHQuZ2x5cGhEYXRhW2ZvbnRTcmNdW2dseXBoSWRdO1xuXG4gICAgICAgIC8vIE1hcmdpbiBhcm91bmQgcGF0aCBlZGdlcyBpbiBTREYsIGJhc2VkIG9uIGEgcGVyY2VudGFnZSBvZiB0aGUgZ2x5cGgncyBtYXggZGltZW5zaW9uLlxuICAgICAgICAvLyBOb3RlIHdlIGFkZCBhbiBleHRyYSAwLjUgcHggb3ZlciB0aGUgY29uZmlndXJlZCB2YWx1ZSBiZWNhdXNlIHRoZSBvdXRlciAwLjUgZG9lc24ndCBjb250YWluXG4gICAgICAgIC8vIHVzZWZ1bCBpbnRlcnBvbGF0ZWQgdmFsdWVzIGFuZCB3aWxsIGJlIGlnbm9yZWQgYW55d2F5LlxuICAgICAgICBjb25zdCBmb250VW5pdHNNYXJnaW4gPSBNYXRoLm1heChwYXRoQm91bmRzWzJdIC0gcGF0aEJvdW5kc1swXSwgcGF0aEJvdW5kc1szXSAtIHBhdGhCb3VuZHNbMV0pXG4gICAgICAgICAgLyBzZGZHbHlwaFNpemUgKiAoQ09ORklHLnNkZk1hcmdpbiAqIHNkZkdseXBoU2l6ZSArIDAuNSk7XG5cbiAgICAgICAgY29uc3QgYXRsYXNJbmRleCA9IGF0bGFzLmdseXBoQ291bnQrKztcbiAgICAgICAgY29uc3Qgc2RmVmlld0JveCA9IFtcbiAgICAgICAgICBwYXRoQm91bmRzWzBdIC0gZm9udFVuaXRzTWFyZ2luLFxuICAgICAgICAgIHBhdGhCb3VuZHNbMV0gLSBmb250VW5pdHNNYXJnaW4sXG4gICAgICAgICAgcGF0aEJvdW5kc1syXSArIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgICBwYXRoQm91bmRzWzNdICsgZm9udFVuaXRzTWFyZ2luLFxuICAgICAgICBdO1xuICAgICAgICBmb250R2x5cGhNYXBzW2ZvbnRJbmRleF0uc2V0KGdseXBoSWQsIChnbHlwaEluZm8gPSB7IHBhdGgsIGF0bGFzSW5kZXgsIHNkZlZpZXdCb3ggfSkpO1xuXG4gICAgICAgIC8vIENvbGxlY3QgdGhvc2UgdGhhdCBuZWVkIFNERiBnZW5lcmF0aW9uXG4gICAgICAgIG5lZWRlZFNERnMucHVzaChnbHlwaEluZm8pO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgYm91bmRzIGZvciByZW5kZXJhYmxlIHF1YWRzXG4gICAgICAvLyBUT0RPIGNhbiB3ZSBnZXQgdGhpcyBiYWNrIG9mZiB0aGUgbWFpbiB0aHJlYWQ/XG4gICAgICBjb25zdCB7c2RmVmlld0JveH0gPSBnbHlwaEluZm87XG4gICAgICBjb25zdCBwb3NYID0gZ2x5cGhQb3NpdGlvbnNbcG9zaXRpb25zSWR4KytdO1xuICAgICAgY29uc3QgcG9zWSA9IGdseXBoUG9zaXRpb25zW3Bvc2l0aW9uc0lkeCsrXTtcbiAgICAgIGNvbnN0IGZvbnRTaXplTXVsdCA9IGZvbnRTaXplIC8gdW5pdHNQZXJFbTtcbiAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1ggKyBzZGZWaWV3Qm94WzBdICogZm9udFNpemVNdWx0O1xuICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWSArIHNkZlZpZXdCb3hbMV0gKiBmb250U2l6ZU11bHQ7XG4gICAgICBnbHlwaEJvdW5kc1tib3VuZHNJZHgrK10gPSBwb3NYICsgc2RmVmlld0JveFsyXSAqIGZvbnRTaXplTXVsdDtcbiAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1kgKyBzZGZWaWV3Qm94WzNdICogZm9udFNpemVNdWx0O1xuXG4gICAgICAvLyBDb252ZXJ0IGdseXBoSWQgdG8gU0RGIGluZGV4IGZvciB0aGUgc2hhZGVyXG4gICAgICBnbHlwaElkc1tpXSA9IGdseXBoSW5mby5hdGxhc0luZGV4O1xuICAgIH0pO1xuICAgIHRpbWluZ3MucXVhZHMgPSAodGltaW5ncy5xdWFkcyB8fCAwKSArIChub3ckMSgpIC0gcXVhZHNTdGFydCk7XG5cbiAgICBjb25zdCBzZGZTdGFydCA9IG5vdyQxKCk7XG4gICAgdGltaW5ncy5zZGYgPSB7fTtcblxuICAgIC8vIEdyb3cgdGhlIHRleHR1cmUgaGVpZ2h0IGJ5IHBvd2VyIG9mIDIgaWYgbmVlZGVkXG4gICAgY29uc3QgY3VycmVudEhlaWdodCA9IHNkZkNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3QgbmVlZGVkUm93cyA9IE1hdGguY2VpbChhdGxhcy5nbHlwaENvdW50IC8gZ2x5cGhzUGVyUm93KTtcbiAgICBjb25zdCBuZWVkZWRIZWlnaHQgPSBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKG5lZWRlZFJvd3MgKiBzZGZHbHlwaFNpemUpKSk7XG4gICAgaWYgKG5lZWRlZEhlaWdodCA+IGN1cnJlbnRIZWlnaHQpIHtcbiAgICAgIC8vIFNpbmNlIHJlc2l6aW5nIHRoZSBjYW52YXMgY2xlYXJzIGl0cyByZW5kZXIgYnVmZmVyLCBpdCBuZWVkcyBzcGVjaWFsIGhhbmRsaW5nIHRvIGNvcHkgdGhlIG9sZCBjb250ZW50cyBvdmVyXG4gICAgICBjb25zb2xlLmluZm8oYEluY3JlYXNpbmcgU0RGIHRleHR1cmUgc2l6ZSAke2N1cnJlbnRIZWlnaHR9LT4ke25lZWRlZEhlaWdodH1gKTtcbiAgICAgIHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nKHNkZkNhbnZhcywgdGV4dHVyZVdpZHRoLCBuZWVkZWRIZWlnaHQpO1xuICAgICAgLy8gQXMgb2YgVGhyZWUgcjEzNiB0ZXh0dXJlcyBjYW5ub3QgYmUgcmVzaXplZCBvbmNlIHRoZXkncmUgYWxsb2NhdGVkIG9uIHRoZSBHUFUsIHdlIG11c3QgZGlzcG9zZSB0byByZWFsbG9jYXRlIGl0XG4gICAgICBzZGZUZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICBQcm9taXNlLmFsbChuZWVkZWRTREZzLm1hcChnbHlwaEluZm8gPT5cbiAgICAgIGdlbmVyYXRlR2x5cGhTREYoZ2x5cGhJbmZvLCBhdGxhcywgYXJncy5ncHVBY2NlbGVyYXRlU0RGKS50aGVuKCh7dGltaW5nfSkgPT4ge1xuICAgICAgICB0aW1pbmdzLnNkZltnbHlwaEluZm8uYXRsYXNJbmRleF0gPSB0aW1pbmc7XG4gICAgICB9KVxuICAgICkpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKG5lZWRlZFNERnMubGVuZ3RoICYmICFhdGxhcy5jb250ZXh0TG9zdCkge1xuICAgICAgICBzYWZhcmlQcmUxNVdvcmthcm91bmQoYXRsYXMpO1xuICAgICAgICBzZGZUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRpbWluZ3Muc2RmVG90YWwgPSBub3ckMSgpIC0gc2RmU3RhcnQ7XG4gICAgICB0aW1pbmdzLnRvdGFsID0gbm93JDEoKSAtIHRvdGFsU3RhcnQ7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgU0RGIC0gJHt0aW1pbmdzLnNkZlRvdGFsfSwgVG90YWwgLSAke3RpbWluZ3MudG90YWwgLSB0aW1pbmdzLmZvbnRMb2FkfWApXG5cbiAgICAgIC8vIEludm9rZSBjYWxsYmFjayB3aXRoIHRoZSB0ZXh0IGxheW91dCBhcnJheXMgYW5kIHVwZGF0ZWQgdGV4dHVyZVxuICAgICAgY2FsbGJhY2soT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHBhcmFtZXRlcnM6IGFyZ3MsXG4gICAgICAgIHNkZlRleHR1cmUsXG4gICAgICAgIHNkZkdseXBoU2l6ZSxcbiAgICAgICAgc2RmRXhwb25lbnQsXG4gICAgICAgIGdseXBoQm91bmRzLFxuICAgICAgICBnbHlwaEF0bGFzSW5kaWNlczogZ2x5cGhJZHMsXG4gICAgICAgIGdseXBoQ29sb3JzOiByZXN1bHQuZ2x5cGhDb2xvcnMsXG4gICAgICAgIGNhcmV0UG9zaXRpb25zOiByZXN1bHQuY2FyZXRQb3NpdGlvbnMsXG4gICAgICAgIGNodW5rZWRCb3VuZHM6IHJlc3VsdC5jaHVua2VkQm91bmRzLFxuICAgICAgICBhc2NlbmRlcjogcmVzdWx0LmFzY2VuZGVyLFxuICAgICAgICBkZXNjZW5kZXI6IHJlc3VsdC5kZXNjZW5kZXIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IHJlc3VsdC5saW5lSGVpZ2h0LFxuICAgICAgICBjYXBIZWlnaHQ6IHJlc3VsdC5jYXBIZWlnaHQsXG4gICAgICAgIHhIZWlnaHQ6IHJlc3VsdC54SGVpZ2h0LFxuICAgICAgICB0b3BCYXNlbGluZTogcmVzdWx0LnRvcEJhc2VsaW5lLFxuICAgICAgICBibG9ja0JvdW5kczogcmVzdWx0LmJsb2NrQm91bmRzLFxuICAgICAgICB2aXNpYmxlQm91bmRzOiByZXN1bHQudmlzaWJsZUJvdW5kcyxcbiAgICAgICAgdGltaW5nczogcmVzdWx0LnRpbWluZ3MsXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFdoaWxlIHRoZSB0eXBlc2V0dGluZyByZXF1ZXN0IGlzIGJlaW5nIGhhbmRsZWQsIGdvIGFoZWFkIGFuZCBtYWtlIHN1cmUgdGhlIGF0bGFzIGNhbnZhcyBjb250ZXh0IGlzXG4gIC8vIFwid2FybWVkIHVwXCI7IHRoZSBmaXJzdCByZXF1ZXN0IHdpbGwgYmUgdGhlIGxvbmdlc3QgZHVlIHRvIHNoYWRlciBwcm9ncmFtIGNvbXBpbGF0aW9uIHNvIHRoaXMgZ2V0c1xuICAvLyBhIGhlYWQgc3RhcnQgb24gdGhhdCBwcm9jZXNzIGJlZm9yZSBTREZzIGFjdHVhbGx5IHN0YXJ0IGdldHRpbmcgcHJvY2Vzc2VkLlxuICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICBpZiAoIWF0bGFzLmNvbnRleHRMb3N0KSB7XG4gICAgICB3YXJtVXBTREZDYW52YXMoc2RmQ2FudmFzKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUdseXBoU0RGKHtwYXRoLCBhdGxhc0luZGV4LCBzZGZWaWV3Qm94fSwge3NkZkdseXBoU2l6ZSwgc2RmQ2FudmFzLCBjb250ZXh0TG9zdH0sIHVzZUdQVSkge1xuICBpZiAoY29udGV4dExvc3QpIHtcbiAgICAvLyBJZiB0aGUgY29udGV4dCBpcyBsb3N0IHRoZXJlJ3Mgbm90aGluZyB3ZSBjYW4gZG8sIGp1c3QgcXVpdCBzaWxlbnRseSBhbmQgbGV0IGl0XG4gICAgLy8gZ2V0IHJlZ2VuZXJhdGVkIHdoZW4gdGhlIGNvbnRleHQgaXMgcmVzdG9yZWRcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt0aW1pbmc6IC0xfSlcbiAgfVxuICBjb25zdCB7dGV4dHVyZVdpZHRoLCBzZGZFeHBvbmVudH0gPSBDT05GSUc7XG4gIGNvbnN0IG1heERpc3QgPSBNYXRoLm1heChzZGZWaWV3Qm94WzJdIC0gc2RmVmlld0JveFswXSwgc2RmVmlld0JveFszXSAtIHNkZlZpZXdCb3hbMV0pO1xuICBjb25zdCBzcXVhcmVJbmRleCA9IE1hdGguZmxvb3IoYXRsYXNJbmRleCAvIDQpO1xuICBjb25zdCB4ID0gc3F1YXJlSW5kZXggJSAodGV4dHVyZVdpZHRoIC8gc2RmR2x5cGhTaXplKSAqIHNkZkdseXBoU2l6ZTtcbiAgY29uc3QgeSA9IE1hdGguZmxvb3Ioc3F1YXJlSW5kZXggLyAodGV4dHVyZVdpZHRoIC8gc2RmR2x5cGhTaXplKSkgKiBzZGZHbHlwaFNpemU7XG4gIGNvbnN0IGNoYW5uZWwgPSBhdGxhc0luZGV4ICUgNDtcbiAgcmV0dXJuIGdlbmVyYXRlU0RGKHNkZkdseXBoU2l6ZSwgc2RmR2x5cGhTaXplLCBwYXRoLCBzZGZWaWV3Qm94LCBtYXhEaXN0LCBzZGZFeHBvbmVudCwgc2RmQ2FudmFzLCB4LCB5LCBjaGFubmVsLCB1c2VHUFUpXG59XG5cbmZ1bmN0aW9uIGluaXRDb250ZXh0TG9zc0hhbmRsaW5nKGF0bGFzKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGF0bGFzLnNkZkNhbnZhcztcblxuICAvKlxuICAvLyBCZWdpbiBjb250ZXh0IGxvc3Mgc2ltdWxhdGlvblxuICBpZiAoIXdpbmRvdy5XZWJHTERlYnVnVXRpbHMpIHtcbiAgICBsZXQgc2NyaXB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dlYkdMRGVidWdVdGlsc1NjcmlwdCcpXG4gICAgaWYgKCFzY3JpcHQpIHtcbiAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgICBzY3JpcHQuaWQgPSAnV2ViR0xEZWJ1Z1V0aWxzJ1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpXG4gICAgICBzY3JpcHQuc3JjID0gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9LaHJvbm9zR3JvdXAvV2ViR0xEZXZlbG9wZXJUb29sc0BiNDJlNzAyL3NyYy9kZWJ1Zy93ZWJnbC1kZWJ1Zy5qcydcbiAgICB9XG4gICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICBpbml0Q29udGV4dExvc3NIYW5kbGluZyhhdGxhcylcbiAgICB9KVxuICAgIHJldHVyblxuICB9XG4gIHdpbmRvdy5XZWJHTERlYnVnVXRpbHMubWFrZUxvc3RDb250ZXh0U2ltdWxhdGluZ0NhbnZhcyhjYW52YXMpXG4gIGNhbnZhcy5sb3NlQ29udGV4dEluTkNhbGxzKDUwMClcbiAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgKGV2ZW50KSA9PiB7XG4gICAgY2FudmFzLmxvc2VDb250ZXh0SW5OQ2FsbHMoNTAwMClcbiAgfSlcbiAgLy8gRW5kIGNvbnRleHQgbG9zcyBzaW11bGF0aW9uXG4gICovXG5cbiAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCAoZXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ29udGV4dCBMb3N0JywgZXZlbnQpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgYXRsYXMuY29udGV4dExvc3QgPSB0cnVlO1xuICB9KTtcbiAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgKGV2ZW50KSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0NvbnRleHQgUmVzdG9yZWQnLCBldmVudCk7XG4gICAgYXRsYXMuY29udGV4dExvc3QgPSBmYWxzZTtcbiAgICAvLyBSZWdlbmVyYXRlIGFsbCBnbHlwaHMgaW50byB0aGUgcmVzdG9yZWQgY2FudmFzOlxuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgYXRsYXMuZ2x5cGhzQnlGb250LmZvckVhY2goZ2x5cGhNYXAgPT4ge1xuICAgICAgZ2x5cGhNYXAuZm9yRWFjaChnbHlwaCA9PiB7XG4gICAgICAgIHByb21pc2VzLnB1c2goZ2VuZXJhdGVHbHlwaFNERihnbHlwaCwgYXRsYXMsIHRydWUpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgIHNhZmFyaVByZTE1V29ya2Fyb3VuZChhdGxhcyk7XG4gICAgICBhdGxhcy5zZGZUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogUHJlbG9hZCBhIGdpdmVuIGZvbnQgYW5kIG9wdGlvbmFsbHkgcHJlLWdlbmVyYXRlIGdseXBoIFNERnMgZm9yIG9uZSBvciBtb3JlIGNoYXJhY3RlciBzZXF1ZW5jZXMuXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gYXZvaWQgbG9uZyBwYXVzZXMgd2hlbiBmaXJzdCBzaG93aW5nIHRleHQgaW4gYSBzY2VuZSwgYnkgcHJlbG9hZGluZyB0aGVcbiAqIG5lZWRlZCBmb250cyBhbmQgZ2x5cGhzIHVwIGZyb250IGFsb25nIHdpdGggb3RoZXIgYXNzZXRzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5mb250IC0gVVJMIG9mIHRoZSBmb250IGZpbGUgdG8gcHJlbG9hZC4gSWYgbm90IGdpdmVuLCB0aGUgZGVmYXVsdCBmb250IHdpbGxcbiAqICAgICAgICBiZSBsb2FkZWQuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gb3B0aW9ucy5jaGFyYWN0ZXJzIC0gT25lIG9yIG1vcmUgY2hhcmFjdGVyIHNlcXVlbmNlcyBmb3Igd2hpY2ggdG8gcHJlLVxuICogICAgICAgIGdlbmVyYXRlIGdseXBoIFNERnMuIE5vdGUgdGhhdCB0aGlzIHdpbGwgaG9ub3IgbGlnYXR1cmUgc3Vic3RpdHV0aW9uLCBzbyB5b3UgbWF5IG5lZWRcbiAqICAgICAgICB0byBzcGVjaWZ5IGxpZ2F0dXJlIHNlcXVlbmNlcyBpbiBhZGRpdGlvbiB0byB0aGVpciBpbmRpdmlkdWFsIGNoYXJhY3RlcnMgdG8gZ2V0IGFsbFxuICogICAgICAgIHBvc3NpYmxlIGdseXBocywgZS5nLiBgW1widFwiLCBcImhcIiwgXCJ0aFwiXWAgdG8gZ2V0IHRoZSBcInRcIiBhbmQgXCJoXCIgZ2x5cGhzIHBsdXMgdGhlIFwidGhcIiBsaWdhdHVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnNkZkdseXBoU2l6ZSAtIFRoZSBzaXplIGF0IHdoaWNoIHRvIHByZXJlbmRlciB0aGUgU0RGIHRleHR1cmVzIGZvciB0aGVcbiAqICAgICAgICBzcGVjaWZpZWQgYGNoYXJhY3RlcnNgLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgcHJlbG9hZGluZyBpcyBjb21wbGV0ZS5cbiAqL1xuZnVuY3Rpb24gcHJlbG9hZEZvbnQoe2ZvbnQsIGNoYXJhY3RlcnMsIHNkZkdseXBoU2l6ZX0sIGNhbGxiYWNrKSB7XG4gIGxldCB0ZXh0ID0gQXJyYXkuaXNBcnJheShjaGFyYWN0ZXJzKSA/IGNoYXJhY3RlcnMuam9pbignXFxuJykgOiAnJyArIGNoYXJhY3RlcnM7XG4gIGdldFRleHRSZW5kZXJJbmZvKHsgZm9udCwgc2RmR2x5cGhTaXplLCB0ZXh0IH0sIGNhbGxiYWNrKTtcbn1cblxuXG4vLyBMb2NhbCBhc3NpZ24gaW1wbCBzbyB3ZSBkb24ndCBoYXZlIHRvIGltcG9ydCB0cm9pa2EtY29yZVxuZnVuY3Rpb24gYXNzaWduKHRvT2JqLCBmcm9tT2JqKSB7XG4gIGZvciAobGV0IGtleSBpbiBmcm9tT2JqKSB7XG4gICAgaWYgKGZyb21PYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdG9PYmpba2V5XSA9IGZyb21PYmpba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvT2JqXG59XG5cbi8vIFV0aWxpdHkgZm9yIG1ha2luZyBVUkxzIGFic29sdXRlXG5sZXQgbGlua0VsO1xuZnVuY3Rpb24gdG9BYnNvbHV0ZVVSTChwYXRoKSB7XG4gIGlmICghbGlua0VsKSB7XG4gICAgbGlua0VsID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IHt9IDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICB9XG4gIGxpbmtFbC5ocmVmID0gcGF0aDtcbiAgcmV0dXJuIGxpbmtFbC5ocmVmXG59XG5cbi8qKlxuICogU2FmYXJpIDwgdjE1IHNlZW1zIHVuYWJsZSB0byB1c2UgdGhlIFNERiB3ZWJnbCBjYW52YXMgYXMgYSB0ZXh0dXJlLiBUaGlzIGFwcGxpZXMgYSB3b3JrYXJvdW5kXG4gKiB3aGVyZSBpdCByZWFkcyB0aGUgcGl4ZWxzIG91dCBvZiB0aGF0IGNhbnZhcyBhbmQgdXBsb2FkcyB0aGVtIGFzIGEgZGF0YSB0ZXh0dXJlIGluc3RlYWQsIGF0XG4gKiBhIHNsaWdodCBwZXJmb3JtYW5jZSBjb3N0LlxuICovXG5mdW5jdGlvbiBzYWZhcmlQcmUxNVdvcmthcm91bmQoYXRsYXMpIHtcbiAgLy8gVXNlIGNyZWF0ZUltYWdlQml0bWFwIHN1cHBvcnQgYXMgYSBwcm94eSBmb3IgU2FmYXJpPDE1LCBhbGwgb3RoZXIgbWFpbnN0cmVhbSBicm93c2Vyc1xuICAvLyBoYXZlIHN1cHBvcnRlZCBpdCBmb3IgYSBsb25nIHdoaWxlIHNvIGFueSBmYWxzZSBwb3NpdGl2ZXMgc2hvdWxkIGJlIG1pbmltYWwuXG4gIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmluZm8oJ1NhZmFyaTwxNTogYXBwbHlpbmcgU0RGIGNhbnZhcyB3b3JrYXJvdW5kJyk7XG4gICAgY29uc3Qge3NkZkNhbnZhcywgc2RmVGV4dHVyZX0gPSBhdGxhcztcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzZGZDYW52YXM7XG4gICAgY29uc3QgZ2wgPSBhdGxhcy5zZGZDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKTtcbiAgICBsZXQgcGl4ZWxzID0gc2RmVGV4dHVyZS5pbWFnZS5kYXRhO1xuICAgIGlmICghcGl4ZWxzIHx8IHBpeGVscy5sZW5ndGggIT09IHdpZHRoICogaGVpZ2h0ICogNCkge1xuICAgICAgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgIHNkZlRleHR1cmUuaW1hZ2UgPSB7d2lkdGgsIGhlaWdodCwgZGF0YTogcGl4ZWxzfTtcbiAgICAgIHNkZlRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgIHNkZlRleHR1cmUuaXNEYXRhVGV4dHVyZSA9IHRydWU7XG4gICAgfVxuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcbiAgfVxufVxuXG5jb25zdCB0eXBlc2V0dGVyV29ya2VyTW9kdWxlID0gLyojX19QVVJFX18qL2RlZmluZVdvcmtlck1vZHVsZSh7XG4gIG5hbWU6ICdUeXBlc2V0dGVyJyxcbiAgZGVwZW5kZW5jaWVzOiBbXG4gICAgY3JlYXRlVHlwZXNldHRlcixcbiAgICBmb250UmVzb2x2ZXJXb3JrZXJNb2R1bGUsXG4gICAgYmlkaUZhY3RvcnksXG4gIF0sXG4gIGluaXQoY3JlYXRlVHlwZXNldHRlciwgZm9udFJlc29sdmVyLCBiaWRpRmFjdG9yeSkge1xuICAgIHJldHVybiBjcmVhdGVUeXBlc2V0dGVyKGZvbnRSZXNvbHZlciwgYmlkaUZhY3RvcnkoKSlcbiAgfVxufSk7XG5cbmNvbnN0IHR5cGVzZXRJbldvcmtlciA9IC8qI19fUFVSRV9fKi9kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICBuYW1lOiAnVHlwZXNldHRlcicsXG4gIGRlcGVuZGVuY2llczogW1xuICAgIHR5cGVzZXR0ZXJXb3JrZXJNb2R1bGUsXG4gIF0sXG4gIGluaXQodHlwZXNldHRlcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHR5cGVzZXR0ZXIudHlwZXNldChhcmdzLCByZXNvbHZlKTtcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICBnZXRUcmFuc2ZlcmFibGVzKHJlc3VsdCkge1xuICAgIC8vIE1hcmsgYXJyYXkgYnVmZmVycyBhcyB0cmFuc2ZlcmFibGUgdG8gYXZvaWQgY2xvbmluZyBkdXJpbmcgcG9zdE1lc3NhZ2VcbiAgICBjb25zdCB0cmFuc2ZlcmFibGVzID0gW107XG4gICAgZm9yIChsZXQgcCBpbiByZXN1bHQpIHtcbiAgICAgIGlmIChyZXN1bHRbcF0gJiYgcmVzdWx0W3BdLmJ1ZmZlcikge1xuICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2gocmVzdWx0W3BdLmJ1ZmZlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2ZlcmFibGVzXG4gIH1cbn0pO1xuXG5jb25zdCB0eXBlc2V0T25NYWluVGhyZWFkID0gdHlwZXNldEluV29ya2VyLm9uTWFpblRocmVhZDtcblxuZnVuY3Rpb24gZHVtcFNERlRleHR1cmVzKCkge1xuICBPYmplY3Qua2V5cyhhdGxhc2VzKS5mb3JFYWNoKHNpemUgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGF0bGFzZXNbc2l6ZV0uc2RmQ2FudmFzO1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IGNhbnZhcztcbiAgICBjb25zb2xlLmxvZyhcIiVjLlwiLCBgXG4gICAgICBiYWNrZ3JvdW5kOiB1cmwoJHtjYW52YXMudG9EYXRhVVJMKCl9KTtcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogJHt3aWR0aH1weCAke2hlaWdodH1weDtcbiAgICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgIGZvbnQtc2l6ZTogMDtcbiAgICAgIGxpbmUtaGVpZ2h0OiAke2hlaWdodH1weDtcbiAgICAgIHBhZGRpbmctbGVmdDogJHt3aWR0aH1weDtcbiAgICBgKTtcbiAgfSk7XG59XG5cbmNvbnN0IHRlbXBsYXRlR2VvbWV0cmllcyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRUZW1wbGF0ZUdlb21ldHJ5KGRldGFpbCkge1xuICBsZXQgZ2VvbSA9IHRlbXBsYXRlR2VvbWV0cmllc1tkZXRhaWxdO1xuICBpZiAoIWdlb20pIHtcbiAgICBnZW9tID0gdGVtcGxhdGVHZW9tZXRyaWVzW2RldGFpbF0gPSBuZXcgUGxhbmVHZW9tZXRyeSgxLCAxLCBkZXRhaWwsIGRldGFpbCkudHJhbnNsYXRlKDAuNSwgMC41LCAwKTtcbiAgfVxuICByZXR1cm4gZ2VvbVxufVxuXG5jb25zdCBnbHlwaEJvdW5kc0F0dHJOYW1lID0gJ2FUcm9pa2FHbHlwaEJvdW5kcyc7XG5jb25zdCBnbHlwaEluZGV4QXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoSW5kZXgnO1xuY29uc3QgZ2x5cGhDb2xvckF0dHJOYW1lID0gJ2FUcm9pa2FHbHlwaENvbG9yJztcblxuLyoqXG5AY2xhc3MgR2x5cGhzR2VvbWV0cnlcblxuQSBzcGVjaWFsaXplZCBHZW9tZXRyeSBmb3IgcmVuZGVyaW5nIGEgc2V0IG9mIHRleHQgZ2x5cGhzLiBVc2VzIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IHRvXG5yZW5kZXIgdGhlIGdseXBocyB1c2luZyBHUFUgaW5zdGFuY2luZyBvZiBhIHNpbmdsZSBxdWFkLCByYXRoZXIgdGhhbiBjb25zdHJ1Y3RpbmcgYSB3aG9sZVxuZ2VvbWV0cnkgd2l0aCB2ZXJ0aWNlcywgZm9yIG11Y2ggc21hbGxlciBhdHRyaWJ1dGUgYXJyYXlidWZmZXJzIGFjY29yZGluZyB0byB0aGlzIG1hdGg6XG5cbiAgV2hlcmUgTiA9IG51bWJlciBvZiBnbHlwaHMuLi5cblxuICBJbnN0YW5jZWQ6XG4gIC0gcG9zaXRpb246IDQgKiAzXG4gIC0gaW5kZXg6IDIgKiAzXG4gIC0gbm9ybWFsOiA0ICogM1xuICAtIHV2OiA0ICogMlxuICAtIGdseXBoIHgveSBib3VuZHM6IE4gKiA0XG4gIC0gZ2x5cGggaW5kaWNlczogTiAqIDFcbiAgPSA1TiArIDM4XG5cbiAgTm9uLWluc3RhbmNlZDpcbiAgLSBwb3NpdGlvbjogTiAqIDQgKiAzXG4gIC0gaW5kZXg6IE4gKiAyICogM1xuICAtIG5vcm1hbDogTiAqIDQgKiAzXG4gIC0gdXY6IE4gKiA0ICogMlxuICAtIGdseXBoIGluZGljZXM6IE4gKiAxXG4gID0gMzlOXG5cbkEgZG93bnNpZGUgb2YgdGhpcyBpcyB0aGUgcmFyZS1idXQtcG9zc2libGUgbGFjayBvZiB0aGUgaW5zdGFuY2VkIGFycmF5cyBleHRlbnNpb24sXG53aGljaCB3ZSBjb3VsZCBwb3RlbnRpYWxseSB3b3JrIGFyb3VuZCB3aXRoIGEgZmFsbGJhY2sgbm9uLWluc3RhbmNlZCBpbXBsZW1lbnRhdGlvbi5cblxuKi9cbmNsYXNzIEdseXBoc0dlb21ldHJ5IGV4dGVuZHMgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5kZXRhaWwgPSAxO1xuICAgIHRoaXMuY3VydmVSYWRpdXMgPSAwO1xuXG4gICAgLy8gRGVmaW5lIGdyb3VwcyBmb3IgcmVuZGVyaW5nIHRleHQgb3V0bGluZSBhcyBhIHNlcGFyYXRlIHBhc3M7IHRoZXNlIHdpbGwgb25seVxuICAgIC8vIGJlIHVzZWQgd2hlbiB0aGUgYG1hdGVyaWFsYCBnZXR0ZXIgcmV0dXJucyBhbiBhcnJheSwgaS5lLiBvdXRsaW5lV2lkdGggPiAwLlxuICAgIHRoaXMuZ3JvdXBzID0gW1xuICAgICAge3N0YXJ0OiAwLCBjb3VudDogSW5maW5pdHksIG1hdGVyaWFsSW5kZXg6IDB9LFxuICAgICAge3N0YXJ0OiAwLCBjb3VudDogSW5maW5pdHksIG1hdGVyaWFsSW5kZXg6IDF9XG4gICAgXTtcblxuICAgIC8vIFByZWFsbG9jYXRlIGVtcHR5IGJvdW5kaW5nIG9iamVjdHNcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuICB9XG5cbiAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlICgpIHtcbiAgICAvLyBOby1vcDsgd2UnbGwgc3luYyB0aGUgYm91bmRpbmdTcGhlcmUgcHJvYWN0aXZlbHkgd2hlbiBuZWVkZWQuXG4gIH1cblxuICBjb21wdXRlQm91bmRpbmdCb3goKSB7XG4gICAgLy8gTm8tb3A7IHdlJ2xsIHN5bmMgdGhlIGJvdW5kaW5nQm94IHByb2FjdGl2ZWx5IHdoZW4gbmVlZGVkLlxuICB9XG5cbiAgc2V0IGRldGFpbChkZXRhaWwpIHtcbiAgICBpZiAoZGV0YWlsICE9PSB0aGlzLl9kZXRhaWwpIHtcbiAgICAgIHRoaXMuX2RldGFpbCA9IGRldGFpbDtcbiAgICAgIGlmICh0eXBlb2YgZGV0YWlsICE9PSAnbnVtYmVyJyB8fCBkZXRhaWwgPCAxKSB7XG4gICAgICAgIGRldGFpbCA9IDE7XG4gICAgICB9XG4gICAgICBsZXQgdHBsID0gZ2V0VGVtcGxhdGVHZW9tZXRyeShkZXRhaWwpXG4gICAgICA7Wydwb3NpdGlvbicsICdub3JtYWwnLCAndXYnXS5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0gPSB0cGwuYXR0cmlidXRlc1thdHRyXS5jbG9uZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldEluZGV4KHRwbC5nZXRJbmRleCgpLmNsb25lKCkpO1xuICAgIH1cbiAgfVxuICBnZXQgZGV0YWlsKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXRhaWxcbiAgfVxuXG4gIHNldCBjdXJ2ZVJhZGl1cyhyKSB7XG4gICAgaWYgKHIgIT09IHRoaXMuX2N1cnZlUmFkaXVzKSB7XG4gICAgICB0aGlzLl9jdXJ2ZVJhZGl1cyA9IHI7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnZlUmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJ2ZVJhZGl1c1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZ2VvbWV0cnkgZm9yIGEgbmV3IHNldCBvZiBnbHlwaHMuXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBnbHlwaEJvdW5kcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIHBsYW5hciBib3VuZHMgZm9yIGFsbCBnbHlwaHNcbiAgICogICAgICAgIHRvIGJlIHJlbmRlcmVkLCA0IGVudHJpZXMgZm9yIGVhY2ggZ2x5cGg6IHgxLHgyLHkxLHkxXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBnbHlwaEF0bGFzSW5kaWNlcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIGluZGV4IG9mIGVhY2ggZ2x5cGggd2l0aGluXG4gICAqICAgICAgICB0aGUgU0RGIGF0bGFzIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJsb2NrQm91bmRzIC0gQW4gYXJyYXkgaG9sZGluZyB0aGUgW21pblgsIG1pblksIG1heFgsIG1heFldIGFjcm9zcyBhbGwgZ2x5cGhzXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtjaHVua2VkQm91bmRzXSAtIEFuIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyBib3VuZHMgZm9yIGVhY2ggY2h1bmsgb2YgTlxuICAgKiAgICAgICAgY29uc2VjdXRpdmUgZ2x5cGhzOiBge3N0YXJ0Ok4sIGVuZDpOLCByZWN0OlttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXX1gLiBUaGlzIGNhbiBiZVxuICAgKiAgICAgICAgdXNlZCB3aXRoIGBhcHBseUNsaXBSZWN0YCB0byBjaG9vc2UgYW4gb3B0aW1pemVkIGBpbnN0YW5jZUNvdW50YC5cbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBbZ2x5cGhDb2xvcnNdIC0gQW4gYXJyYXkgaG9sZGluZyByLGcsYiB2YWx1ZXMgZm9yIGVhY2ggZ2x5cGguXG4gICAqL1xuICB1cGRhdGVHbHlwaHMoZ2x5cGhCb3VuZHMsIGdseXBoQXRsYXNJbmRpY2VzLCBibG9ja0JvdW5kcywgY2h1bmtlZEJvdW5kcywgZ2x5cGhDb2xvcnMpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGluc3RhbmNlIGF0dHJpYnV0ZXNcbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZURhdGEoZ2x5cGhCb3VuZHNBdHRyTmFtZSwgZ2x5cGhCb3VuZHMsIDQpO1xuICAgIHRoaXMudXBkYXRlQXR0cmlidXRlRGF0YShnbHlwaEluZGV4QXR0ck5hbWUsIGdseXBoQXRsYXNJbmRpY2VzLCAxKTtcbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZURhdGEoZ2x5cGhDb2xvckF0dHJOYW1lLCBnbHlwaENvbG9ycywgMyk7XG4gICAgdGhpcy5fYmxvY2tCb3VuZHMgPSBibG9ja0JvdW5kcztcbiAgICB0aGlzLl9jaHVua2VkQm91bmRzID0gY2h1bmtlZEJvdW5kcztcbiAgICB0aGlzLmluc3RhbmNlQ291bnQgPSBnbHlwaEF0bGFzSW5kaWNlcy5sZW5ndGg7XG4gICAgdGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRzKCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX2Jsb2NrQm91bmRzO1xuICAgIGlmIChib3VuZHMpIHtcbiAgICAgIGNvbnN0IHsgY3VydmVSYWRpdXMsIGJvdW5kaW5nQm94OiBiYm94IH0gPSB0aGlzO1xuICAgICAgaWYgKGN1cnZlUmFkaXVzKSB7XG4gICAgICAgIGNvbnN0IHsgUEksIGZsb29yLCBtaW4sIG1heCwgc2luLCBjb3MgfSA9IE1hdGg7XG4gICAgICAgIGNvbnN0IGhhbGZQaSA9IFBJIC8gMjtcbiAgICAgICAgY29uc3QgdHdvUGkgPSBQSSAqIDI7XG4gICAgICAgIGNvbnN0IGFic1IgPSBNYXRoLmFicyhjdXJ2ZVJhZGl1cyk7XG4gICAgICAgIGNvbnN0IGxlZnRBbmdsZSA9IGJvdW5kc1swXSAvIGFic1I7XG4gICAgICAgIGNvbnN0IHJpZ2h0QW5nbGUgPSBib3VuZHNbMl0gLyBhYnNSO1xuICAgICAgICBjb25zdCBtaW5YID0gZmxvb3IoKGxlZnRBbmdsZSArIGhhbGZQaSkgLyB0d29QaSkgIT09IGZsb29yKChyaWdodEFuZ2xlICsgaGFsZlBpKSAvIHR3b1BpKVxuICAgICAgICAgID8gLWFic1IgOiBtaW4oc2luKGxlZnRBbmdsZSkgKiBhYnNSLCBzaW4ocmlnaHRBbmdsZSkgKiBhYnNSKTtcbiAgICAgICAgY29uc3QgbWF4WCA9IGZsb29yKChsZWZ0QW5nbGUgLSBoYWxmUGkpIC8gdHdvUGkpICE9PSBmbG9vcigocmlnaHRBbmdsZSAtIGhhbGZQaSkgLyB0d29QaSlcbiAgICAgICAgICA/IGFic1IgOiBtYXgoc2luKGxlZnRBbmdsZSkgKiBhYnNSLCBzaW4ocmlnaHRBbmdsZSkgKiBhYnNSKTtcbiAgICAgICAgY29uc3QgbWF4WiA9IGZsb29yKChsZWZ0QW5nbGUgKyBQSSkgLyB0d29QaSkgIT09IGZsb29yKChyaWdodEFuZ2xlICsgUEkpIC8gdHdvUGkpXG4gICAgICAgICAgPyBhYnNSICogMiA6IG1heChhYnNSIC0gY29zKGxlZnRBbmdsZSkgKiBhYnNSLCBhYnNSIC0gY29zKHJpZ2h0QW5nbGUpICogYWJzUik7XG4gICAgICAgIGJib3gubWluLnNldChtaW5YLCBib3VuZHNbMV0sIGN1cnZlUmFkaXVzIDwgMCA/IC1tYXhaIDogMCk7XG4gICAgICAgIGJib3gubWF4LnNldChtYXhYLCBib3VuZHNbM10sIGN1cnZlUmFkaXVzIDwgMCA/IDAgOiBtYXhaKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJib3gubWluLnNldChib3VuZHNbMF0sIGJvdW5kc1sxXSwgMCk7XG4gICAgICAgIGJib3gubWF4LnNldChib3VuZHNbMl0sIGJvdW5kc1szXSwgMCk7XG4gICAgICB9XG4gICAgICBiYm94LmdldEJvdW5kaW5nU3BoZXJlKHRoaXMuYm91bmRpbmdTcGhlcmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIGNsaXBwaW5nIHJlY3QsIGFuZCB0aGUgY2h1bmtlZEJvdW5kcyBmcm9tIHRoZSBsYXN0IHVwZGF0ZUdseXBocyBjYWxsLCBjaG9vc2UgdGhlIGxvd2VzdFxuICAgKiBgaW5zdGFuY2VDb3VudGAgdGhhdCB3aWxsIHNob3cgYWxsIGdseXBocyB3aXRoaW4gdGhlIGNsaXBwZWQgdmlldy4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb25cbiAgICogZm9yIGxvbmcgYmxvY2tzIG9mIHRleHQgdGhhdCBhcmUgY2xpcHBlZCwgdG8gc2tpcCB2ZXJ0ZXggc2hhZGVyIGV2YWx1YXRpb24gZm9yIGdseXBocyB0aGF0IHdvdWxkXG4gICAqIGJlIGNsaXBwZWQgYW55d2F5LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgc2luY2UgYGRyYXdFbGVtZW50c0luc3RhbmNlZFtBTkdMRV1gIG9ubHkgYWNjZXB0cyBhbiBpbnN0YW5jZSBjb3VudCBhbmQgbm90IGEgc3RhcnRpbmdcbiAgICogb2Zmc2V0LCB0aGlzIG9wdGltaXphdGlvbiBiZWNvbWVzIGxlc3MgZWZmZWN0aXZlIGFzIHRoZSBjbGlwUmVjdCBtb3ZlcyBjbG9zZXIgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICogdGV4dCBibG9jay4gV2UgY291bGQgZml4IHRoYXQgYnkgc3dpdGNoaW5nIGZyb20gaW5zdGFuY2luZyB0byBhIGZ1bGwgZ2VvbWV0cnkgd2l0aCBhIGRyYXdSYW5nZSxcbiAgICogYnV0IGF0IHRoZSBleHBlbnNlIG9mIG11Y2ggbGFyZ2VyIGF0dHJpYnV0ZSBidWZmZXJzIChzZWUgY2xhc3Nkb2MgYWJvdmUuKVxuICAgKlxuICAgKiBAcGFyYW0ge1ZlY3RvcjR9IGNsaXBSZWN0XG4gICAqL1xuICBhcHBseUNsaXBSZWN0KGNsaXBSZWN0KSB7XG4gICAgbGV0IGNvdW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoZ2x5cGhJbmRleEF0dHJOYW1lKS5jb3VudDtcbiAgICBsZXQgY2h1bmtzID0gdGhpcy5fY2h1bmtlZEJvdW5kcztcbiAgICBpZiAoY2h1bmtzKSB7XG4gICAgICBmb3IgKGxldCBpID0gY2h1bmtzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBjb3VudCA9IGNodW5rc1tpXS5lbmQ7XG4gICAgICAgIGxldCByZWN0ID0gY2h1bmtzW2ldLnJlY3Q7XG4gICAgICAgIC8vIG5vdGU6IGJvdGggcmVjdHMgYXJlIGwtYi1yLXRcbiAgICAgICAgaWYgKHJlY3RbMV0gPCBjbGlwUmVjdC53ICYmIHJlY3RbM10gPiBjbGlwUmVjdC55ICYmIHJlY3RbMF0gPCBjbGlwUmVjdC56ICYmIHJlY3RbMl0gPiBjbGlwUmVjdC54KSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmluc3RhbmNlQ291bnQgPSBjb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IGZvciB1cGRhdGluZyBpbnN0YW5jZSBhdHRyaWJ1dGVzIHdpdGggYXV0b21hdGljIHJlc2l6aW5nXG4gICAqL1xuICB1cGRhdGVBdHRyaWJ1dGVEYXRhKGF0dHJOYW1lLCBuZXdBcnJheSwgaXRlbVNpemUpIHtcbiAgICBjb25zdCBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgIGlmIChuZXdBcnJheSkge1xuICAgICAgLy8gSWYgbGVuZ3RoIGlzbid0IGNoYW5naW5nLCBqdXN0IHVwZGF0ZSB0aGUgYXR0cmlidXRlJ3MgYXJyYXkgZGF0YVxuICAgICAgaWYgKGF0dHIgJiYgYXR0ci5hcnJheS5sZW5ndGggPT09IG5ld0FycmF5Lmxlbmd0aCkge1xuICAgICAgICBhdHRyLmFycmF5LnNldChuZXdBcnJheSk7XG4gICAgICAgIGF0dHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIG5ldyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUobmV3QXJyYXksIGl0ZW1TaXplKSk7XG4gICAgICAgIC8vIElmIHRoZSBuZXcgYXR0cmlidXRlIGhhcyBhIGRpZmZlcmVudCBzaXplLCB3ZSBhbHNvIGhhdmUgdG8gKGFzIG9mIHIxMTcpIG1hbnVhbGx5IGNsZWFyIHRoZVxuICAgICAgICAvLyBpbnRlcm5hbCBjYWNoZWQgbWF4IGluc3RhbmNlIGNvdW50LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTk3MDZcbiAgICAgICAgLy8gSXQncyB1bmNsZWFyIGlmIHRoaXMgaXMgYSB0aHJlZWpzIGJ1ZyBvciBhIHRydWx5IHVuc3VwcG9ydGVkIHNjZW5hcmlvOyBkaXNjdXNzaW9uIGluXG4gICAgICAgIC8vIHRoYXQgdGlja2V0IGlzIGFtYmlndW91cyBhcyB0byB3aGV0aGVyIHJlcGxhY2luZyBhIEJ1ZmZlckF0dHJpYnV0ZSB3aXRoIG9uZSBvZiBhXG4gICAgICAgIC8vIGRpZmZlcmVudCBzaXplIGlzIHN1cHBvcnRlZCwgYnV0IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8xNzQxOCBzdHJvbmdseVxuICAgICAgICAvLyBpbXBsaWVzIGl0IHNob3VsZCBiZSBzdXBwb3J0ZWQuIEl0J3MgcG9zc2libGUgd2UgbmVlZCB0b1xuICAgICAgICBkZWxldGUgdGhpcy5fbWF4SW5zdGFuY2VDb3VudDsgLy9mb3IgcjExNyssIGNvdWxkIGJlIGZyYWdpbGVcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7IC8vZm9yIHIxMTgrLCBtb3JlIHJvYnVzdCBmZWVsaW5nLCBidXQgbW9yZSBoZWF2eS1oYW5kZWQgdGhhbiBJJ2QgbGlrZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXR0cikge1xuICAgICAgdGhpcy5kZWxldGVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBsYW5ndWFnZT1HTFNMXG5jb25zdCBWRVJURVhfREVGUyA9IGBcbnVuaWZvcm0gdmVjMiB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZHbHlwaFNpemU7XG51bmlmb3JtIHZlYzQgdVRyb2lrYVRvdGFsQm91bmRzO1xudW5pZm9ybSB2ZWM0IHVUcm9pa2FDbGlwUmVjdDtcbnVuaWZvcm0gbWF0MyB1VHJvaWthT3JpZW50O1xudW5pZm9ybSBib29sIHVUcm9pa2FVc2VHbHlwaENvbG9ycztcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUVkZ2VPZmZzZXQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FCbHVyUmFkaXVzO1xudW5pZm9ybSB2ZWMyIHVUcm9pa2FQb3NpdGlvbk9mZnNldDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUN1cnZlUmFkaXVzO1xuYXR0cmlidXRlIHZlYzQgYVRyb2lrYUdseXBoQm91bmRzO1xuYXR0cmlidXRlIGZsb2F0IGFUcm9pa2FHbHlwaEluZGV4O1xuYXR0cmlidXRlIHZlYzMgYVRyb2lrYUdseXBoQ29sb3I7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoVVY7XG52YXJ5aW5nIHZlYzQgdlRyb2lrYVRleHR1cmVVVkJvdW5kcztcbnZhcnlpbmcgZmxvYXQgdlRyb2lrYVRleHR1cmVDaGFubmVsO1xudmFyeWluZyB2ZWMzIHZUcm9pa2FHbHlwaENvbG9yO1xudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaERpbWVuc2lvbnM7XG5gO1xuXG4vLyBsYW5ndWFnZT1HTFNMIHByZWZpeD1cInZvaWQgbWFpbigpIHtcIiBzdWZmaXg9XCJ9XCJcbmNvbnN0IFZFUlRFWF9UUkFOU0ZPUk0gPSBgXG52ZWM0IGJvdW5kcyA9IGFUcm9pa2FHbHlwaEJvdW5kcztcbmJvdW5kcy54eiArPSB1VHJvaWthUG9zaXRpb25PZmZzZXQueDtcbmJvdW5kcy55dyAtPSB1VHJvaWthUG9zaXRpb25PZmZzZXQueTtcblxudmVjNCBvdXRsaW5lQm91bmRzID0gdmVjNChcbiAgYm91bmRzLnh5IC0gdVRyb2lrYUVkZ2VPZmZzZXQgLSB1VHJvaWthQmx1clJhZGl1cyxcbiAgYm91bmRzLnp3ICsgdVRyb2lrYUVkZ2VPZmZzZXQgKyB1VHJvaWthQmx1clJhZGl1c1xuKTtcbnZlYzQgY2xpcHBlZEJvdW5kcyA9IHZlYzQoXG4gIGNsYW1wKG91dGxpbmVCb3VuZHMueHksIHVUcm9pa2FDbGlwUmVjdC54eSwgdVRyb2lrYUNsaXBSZWN0Lnp3KSxcbiAgY2xhbXAob3V0bGluZUJvdW5kcy56dywgdVRyb2lrYUNsaXBSZWN0Lnh5LCB1VHJvaWthQ2xpcFJlY3QuencpXG4pO1xuXG52ZWMyIGNsaXBwZWRYWSA9IChtaXgoY2xpcHBlZEJvdW5kcy54eSwgY2xpcHBlZEJvdW5kcy56dywgcG9zaXRpb24ueHkpIC0gYm91bmRzLnh5KSAvIChib3VuZHMuencgLSBib3VuZHMueHkpO1xuXG5wb3NpdGlvbi54eSA9IG1peChib3VuZHMueHksIGJvdW5kcy56dywgY2xpcHBlZFhZKTtcblxudXYgPSAocG9zaXRpb24ueHkgLSB1VHJvaWthVG90YWxCb3VuZHMueHkpIC8gKHVUcm9pa2FUb3RhbEJvdW5kcy56dyAtIHVUcm9pa2FUb3RhbEJvdW5kcy54eSk7XG5cbmZsb2F0IHJhZCA9IHVUcm9pa2FDdXJ2ZVJhZGl1cztcbmlmIChyYWQgIT0gMC4wKSB7XG4gIGZsb2F0IGFuZ2xlID0gcG9zaXRpb24ueCAvIHJhZDtcbiAgcG9zaXRpb24ueHogPSB2ZWMyKHNpbihhbmdsZSkgKiByYWQsIHJhZCAtIGNvcyhhbmdsZSkgKiByYWQpO1xuICBub3JtYWwueHogPSB2ZWMyKHNpbihhbmdsZSksIGNvcyhhbmdsZSkpO1xufVxuICBcbnBvc2l0aW9uID0gdVRyb2lrYU9yaWVudCAqIHBvc2l0aW9uO1xubm9ybWFsID0gdVRyb2lrYU9yaWVudCAqIG5vcm1hbDtcblxudlRyb2lrYUdseXBoVVYgPSBjbGlwcGVkWFkueHk7XG52VHJvaWthR2x5cGhEaW1lbnNpb25zID0gdmVjMihib3VuZHNbMl0gLSBib3VuZHNbMF0sIGJvdW5kc1szXSAtIGJvdW5kc1sxXSk7XG5cbiR7JycvKiBOT1RFOiBpdCBzZWVtcyBpbXBvcnRhbnQgdG8gY2FsY3VsYXRlIHRoZSBnbHlwaCdzIGJvdW5kaW5nIHRleHR1cmUgVVZzIGhlcmUgaW4gdGhlXG4gIHZlcnRleCBzaGFkZXIsIHJhdGhlciB0aGFuIGluIHRoZSBmcmFnbWVudCBzaGFkZXIsIGFzIHRoZSBsYXR0ZXIgZ2l2ZXMgc3RyYW5nZSBhcnRpZmFjdHNcbiAgb24gc29tZSBnbHlwaHMgKHRob3NlIGluIHRoZSBsZWZ0bW9zdCB0ZXh0dXJlIGNvbHVtbikgb24gc29tZSBzeXN0ZW1zLiBUaGUgZXhhY3QgcmVhc29uXG4gIGlzbid0IHVuZGVyc3Rvb2QgYnV0IGRvaW5nIHRoaXMgaGVyZSwgdGhlbiBtaXgoKS1pbmcgaW4gdGhlIGZyYWdtZW50IHNoYWRlciwgc2VlbXMgdG8gd29yay4gKi99XG5mbG9hdCB0eENvbHMgPSB1VHJvaWthU0RGVGV4dHVyZVNpemUueCAvIHVUcm9pa2FTREZHbHlwaFNpemU7XG52ZWMyIHR4VXZQZXJTcXVhcmUgPSB1VHJvaWthU0RGR2x5cGhTaXplIC8gdVRyb2lrYVNERlRleHR1cmVTaXplO1xudmVjMiB0eFN0YXJ0VVYgPSB0eFV2UGVyU3F1YXJlICogdmVjMihcbiAgbW9kKGZsb29yKGFUcm9pa2FHbHlwaEluZGV4IC8gNC4wKSwgdHhDb2xzKSxcbiAgZmxvb3IoZmxvb3IoYVRyb2lrYUdseXBoSW5kZXggLyA0LjApIC8gdHhDb2xzKVxuKTtcbnZUcm9pa2FUZXh0dXJlVVZCb3VuZHMgPSB2ZWM0KHR4U3RhcnRVViwgdmVjMih0eFN0YXJ0VVYpICsgdHhVdlBlclNxdWFyZSk7XG52VHJvaWthVGV4dHVyZUNoYW5uZWwgPSBtb2QoYVRyb2lrYUdseXBoSW5kZXgsIDQuMCk7XG5gO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG5jb25zdCBGUkFHTUVOVF9ERUZTID0gYFxudW5pZm9ybSBzYW1wbGVyMkQgdVRyb2lrYVNERlRleHR1cmU7XG51bmlmb3JtIHZlYzIgdVRyb2lrYVNERlRleHR1cmVTaXplO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU0RGR2x5cGhTaXplO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU0RGRXhwb25lbnQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FFZGdlT2Zmc2V0O1xudW5pZm9ybSBmbG9hdCB1VHJvaWthRmlsbE9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FCbHVyUmFkaXVzO1xudW5pZm9ybSB2ZWMzIHVUcm9pa2FTdHJva2VDb2xvcjtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYVN0cm9rZVdpZHRoO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU3Ryb2tlT3BhY2l0eTtcbnVuaWZvcm0gYm9vbCB1VHJvaWthU0RGRGVidWc7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoVVY7XG52YXJ5aW5nIHZlYzQgdlRyb2lrYVRleHR1cmVVVkJvdW5kcztcbnZhcnlpbmcgZmxvYXQgdlRyb2lrYVRleHR1cmVDaGFubmVsO1xudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaERpbWVuc2lvbnM7XG5cbmZsb2F0IHRyb2lrYVNkZlZhbHVlVG9TaWduZWREaXN0YW5jZShmbG9hdCBhbHBoYSkge1xuICAvLyBJbnZlcnNlIG9mIGV4cG9uZW50aWFsIGVuY29kaW5nIGluIHdlYmdsLXNkZi1nZW5lcmF0b3JcbiAgJHsnJy8qIFRPRE8gLSB0aGVyZSdzIHNvbWUgc2xpZ2h0IGluYWNjdXJhY3kgaGVyZSB3aGVuIGRlYWxpbmcgd2l0aCBpbnRlcnBvbGF0ZWQgYWxwaGEgdmFsdWVzOyB0aG9zZVxuICAgIGFyZSBsaW5lYXJseSBpbnRlcnBvbGF0ZWQgd2hlcmUgdGhlIGVuY29kaW5nIGlzIGV4cG9uZW50aWFsLiBMb29rIGludG8gaW1wcm92aW5nIHRoaXMgYnkgcm91bmRpbmdcbiAgICB0byBuZWFyZXN0IDIgd2hvbGUgdGV4ZWxzLCBkZWNvZGluZyB0aG9zZSBleHBvbmVudGlhbCB2YWx1ZXMsIGFuZCBsaW5lYXJseSBpbnRlcnBvbGF0aW5nIHRoZSByZXN1bHQuXG4gICovfVxuICBmbG9hdCBtYXhEaW1lbnNpb24gPSBtYXgodlRyb2lrYUdseXBoRGltZW5zaW9ucy54LCB2VHJvaWthR2x5cGhEaW1lbnNpb25zLnkpO1xuICBmbG9hdCBhYnNEaXN0ID0gKDEuMCAtIHBvdygyLjAgKiAoYWxwaGEgPiAwLjUgPyAxLjAgLSBhbHBoYSA6IGFscGhhKSwgMS4wIC8gdVRyb2lrYVNERkV4cG9uZW50KSkgKiBtYXhEaW1lbnNpb247XG4gIGZsb2F0IHNpZ25lZERpc3QgPSBhYnNEaXN0ICogKGFscGhhID4gMC41ID8gLTEuMCA6IDEuMCk7XG4gIHJldHVybiBzaWduZWREaXN0O1xufVxuXG5mbG9hdCB0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh2ZWMyIGdseXBoVVYpIHtcbiAgdmVjMiB0ZXh0dXJlVVYgPSBtaXgodlRyb2lrYVRleHR1cmVVVkJvdW5kcy54eSwgdlRyb2lrYVRleHR1cmVVVkJvdW5kcy56dywgZ2x5cGhVVik7XG4gIHZlYzQgcmdiYSA9IHRleHR1cmUyRCh1VHJvaWthU0RGVGV4dHVyZSwgdGV4dHVyZVVWKTtcbiAgZmxvYXQgY2ggPSBmbG9vcih2VHJvaWthVGV4dHVyZUNoYW5uZWwgKyAwLjUpOyAvL05PVEU6IGNhbid0IHVzZSByb3VuZCgpIGluIFdlYkdMMVxuICByZXR1cm4gY2ggPT0gMC4wID8gcmdiYS5yIDogY2ggPT0gMS4wID8gcmdiYS5nIDogY2ggPT0gMi4wID8gcmdiYS5iIDogcmdiYS5hO1xufVxuXG5mbG9hdCB0cm9pa2FHbHlwaFV2VG9EaXN0YW5jZSh2ZWMyIHV2KSB7XG4gIHJldHVybiB0cm9pa2FTZGZWYWx1ZVRvU2lnbmVkRGlzdGFuY2UodHJvaWthR2x5cGhVdlRvU2RmVmFsdWUodXYpKTtcbn1cblxuZmxvYXQgdHJvaWthR2V0QUFEaXN0KCkge1xuICAkeycnLypcbiAgICBXaGVuIHRoZSBzdGFuZGFyZCBkZXJpdmF0aXZlcyBleHRlbnNpb24gaXMgYXZhaWxhYmxlLCB3ZSBjaG9vc2UgYW4gYW50aWFsaWFzaW5nIGFscGhhIHRocmVzaG9sZCBiYXNlZFxuICAgIG9uIHRoZSBwb3RlbnRpYWwgY2hhbmdlIGluIHRoZSBTREYncyBhbHBoYSBmcm9tIHRoaXMgZnJhZ21lbnQgdG8gaXRzIG5laWdoYm9yLiBUaGlzIHN0cmF0ZWd5IG1heGltaXplcyBcbiAgICByZWFkYWJpbGl0eSBhbmQgZWRnZSBjcmlzcG5lc3MgYXQgYWxsIHNpemVzIGFuZCBzY3JlZW4gcmVzb2x1dGlvbnMuXG4gICovfVxuICAjaWYgZGVmaW5lZChHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMpIHx8IF9fVkVSU0lPTl9fID49IDMwMFxuICByZXR1cm4gbGVuZ3RoKGZ3aWR0aCh2VHJvaWthR2x5cGhVViAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpKSAqIDAuNTtcbiAgI2Vsc2VcbiAgcmV0dXJuIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMueCAvIDY0LjA7XG4gICNlbmRpZlxufVxuXG5mbG9hdCB0cm9pa2FHZXRGcmFnRGlzdFZhbHVlKCkge1xuICB2ZWMyIGNsYW1wZWRHbHlwaFVWID0gY2xhbXAodlRyb2lrYUdseXBoVVYsIDAuNSAvIHVUcm9pa2FTREZHbHlwaFNpemUsIDEuMCAtIDAuNSAvIHVUcm9pa2FTREZHbHlwaFNpemUpO1xuICBmbG9hdCBkaXN0YW5jZSA9IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKGNsYW1wZWRHbHlwaFVWKTtcbiBcbiAgLy8gRXh0cmFwb2xhdGUgZGlzdGFuY2Ugd2hlbiBvdXRzaWRlIGJvdW5kczpcbiAgZGlzdGFuY2UgKz0gY2xhbXBlZEdseXBoVVYgPT0gdlRyb2lrYUdseXBoVVYgPyAwLjAgOiBcbiAgICBsZW5ndGgoKHZUcm9pa2FHbHlwaFVWIC0gY2xhbXBlZEdseXBoVVYpICogdlRyb2lrYUdseXBoRGltZW5zaW9ucyk7XG5cbiAgJHsnJy8qIFxuICAvLyBUT0RPIG1vcmUgcmVmaW5lZCBleHRyYXBvbGF0ZWQgZGlzdGFuY2UgYnkgYWRqdXN0aW5nIGZvciBhbmdsZSBvZiBncmFkaWVudCBhdCBlZGdlLi4uXG4gIC8vIFRoaXMgaGFzIHBvdGVudGlhbCBidXQgY3VycmVudGx5IGdpdmVzIHZlcnkgamFnZ2VkIGV4dGVuc2lvbnMsIG1heWJlIGR1ZSB0byBwcmVjaXNpb24gaXNzdWVzP1xuICBmbG9hdCB1dlN0ZXAgPSAxLjAgLyB1VHJvaWthU0RGR2x5cGhTaXplO1xuICB2ZWMyIG5laWdoYm9yMVVWID0gY2xhbXBlZEdseXBoVVYgKyAoXG4gICAgdlRyb2lrYUdseXBoVVYueCAhPSBjbGFtcGVkR2x5cGhVVi54ID8gdmVjMigwLjAsIHV2U3RlcCAqIHNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueSkpIDpcbiAgICB2VHJvaWthR2x5cGhVVi55ICE9IGNsYW1wZWRHbHlwaFVWLnkgPyB2ZWMyKHV2U3RlcCAqIHNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueCksIDAuMCkgOlxuICAgIHZlYzIoMC4wKVxuICApO1xuICB2ZWMyIG5laWdoYm9yMlVWID0gY2xhbXBlZEdseXBoVVYgKyAoXG4gICAgdlRyb2lrYUdseXBoVVYueCAhPSBjbGFtcGVkR2x5cGhVVi54ID8gdmVjMigwLjAsIHV2U3RlcCAqIC1zaWduKDAuNSAtIHZUcm9pa2FHbHlwaFVWLnkpKSA6XG4gICAgdlRyb2lrYUdseXBoVVYueSAhPSBjbGFtcGVkR2x5cGhVVi55ID8gdmVjMih1dlN0ZXAgKiAtc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi54KSwgMC4wKSA6XG4gICAgdmVjMigwLjApXG4gICk7XG4gIGZsb2F0IG5laWdoYm9yMURpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UobmVpZ2hib3IxVVYpO1xuICBmbG9hdCBuZWlnaGJvcjJEaXN0YW5jZSA9IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKG5laWdoYm9yMlVWKTtcbiAgZmxvYXQgZGlzdFRvVW5jbGFtcGVkID0gbGVuZ3RoKCh2VHJvaWthR2x5cGhVViAtIGNsYW1wZWRHbHlwaFVWKSAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpO1xuICBmbG9hdCBkaXN0VG9OZWlnaGJvciA9IGxlbmd0aCgoY2xhbXBlZEdseXBoVVYgLSBuZWlnaGJvcjFVVikgKiB2VHJvaWthR2x5cGhEaW1lbnNpb25zKTtcbiAgZmxvYXQgZ3JhZGllbnRBbmdsZTEgPSBtaW4oYXNpbihhYnMobmVpZ2hib3IxRGlzdGFuY2UgLSBkaXN0YW5jZSkgLyBkaXN0VG9OZWlnaGJvciksIFBJIC8gMi4wKTtcbiAgZmxvYXQgZ3JhZGllbnRBbmdsZTIgPSBtaW4oYXNpbihhYnMobmVpZ2hib3IyRGlzdGFuY2UgLSBkaXN0YW5jZSkgLyBkaXN0VG9OZWlnaGJvciksIFBJIC8gMi4wKTtcbiAgZGlzdGFuY2UgKz0gKGNvcyhncmFkaWVudEFuZ2xlMSkgKyBjb3MoZ3JhZGllbnRBbmdsZTIpKSAvIDIuMCAqIGRpc3RUb1VuY2xhbXBlZDtcbiAgKi99XG5cbiAgcmV0dXJuIGRpc3RhbmNlO1xufVxuXG5mbG9hdCB0cm9pa2FHZXRFZGdlQWxwaGEoZmxvYXQgZGlzdGFuY2UsIGZsb2F0IGRpc3RhbmNlT2Zmc2V0LCBmbG9hdCBhYURpc3QpIHtcbiAgI2lmIGRlZmluZWQoSVNfREVQVEhfTUFURVJJQUwpIHx8IGRlZmluZWQoSVNfRElTVEFOQ0VfTUFURVJJQUwpXG4gIGZsb2F0IGFscGhhID0gc3RlcCgtZGlzdGFuY2VPZmZzZXQsIC1kaXN0YW5jZSk7XG4gICNlbHNlXG5cbiAgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKFxuICAgIGRpc3RhbmNlT2Zmc2V0ICsgYWFEaXN0LFxuICAgIGRpc3RhbmNlT2Zmc2V0IC0gYWFEaXN0LFxuICAgIGRpc3RhbmNlXG4gICk7XG4gICNlbmRpZlxuXG4gIHJldHVybiBhbHBoYTtcbn1cbmA7XG5cbi8vIGxhbmd1YWdlPUdMU0wgcHJlZml4PVwidm9pZCBtYWluKCkge1wiIHN1ZmZpeD1cIn1cIlxuY29uc3QgRlJBR01FTlRfVFJBTlNGT1JNID0gYFxuZmxvYXQgYWFEaXN0ID0gdHJvaWthR2V0QUFEaXN0KCk7XG5mbG9hdCBmcmFnRGlzdGFuY2UgPSB0cm9pa2FHZXRGcmFnRGlzdFZhbHVlKCk7XG5mbG9hdCBlZGdlQWxwaGEgPSB1VHJvaWthU0RGRGVidWcgP1xuICB0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh2VHJvaWthR2x5cGhVVikgOlxuICB0cm9pa2FHZXRFZGdlQWxwaGEoZnJhZ0Rpc3RhbmNlLCB1VHJvaWthRWRnZU9mZnNldCwgbWF4KGFhRGlzdCwgdVRyb2lrYUJsdXJSYWRpdXMpKTtcblxuI2lmICFkZWZpbmVkKElTX0RFUFRIX01BVEVSSUFMKSAmJiAhZGVmaW5lZChJU19ESVNUQU5DRV9NQVRFUklBTClcbnZlYzQgZmlsbFJHQkEgPSBnbF9GcmFnQ29sb3I7XG5maWxsUkdCQS5hICo9IHVUcm9pa2FGaWxsT3BhY2l0eTtcbnZlYzQgc3Ryb2tlUkdCQSA9IHVUcm9pa2FTdHJva2VXaWR0aCA9PSAwLjAgPyBmaWxsUkdCQSA6IHZlYzQodVRyb2lrYVN0cm9rZUNvbG9yLCB1VHJvaWthU3Ryb2tlT3BhY2l0eSk7XG5pZiAoZmlsbFJHQkEuYSA9PSAwLjApIGZpbGxSR0JBLnJnYiA9IHN0cm9rZVJHQkEucmdiO1xuZ2xfRnJhZ0NvbG9yID0gbWl4KGZpbGxSR0JBLCBzdHJva2VSR0JBLCBzbW9vdGhzdGVwKFxuICAtdVRyb2lrYVN0cm9rZVdpZHRoIC0gYWFEaXN0LFxuICAtdVRyb2lrYVN0cm9rZVdpZHRoICsgYWFEaXN0LFxuICBmcmFnRGlzdGFuY2VcbikpO1xuZ2xfRnJhZ0NvbG9yLmEgKj0gZWRnZUFscGhhO1xuI2VuZGlmXG5cbmlmIChlZGdlQWxwaGEgPT0gMC4wKSB7XG4gIGRpc2NhcmQ7XG59XG5gO1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbWF0ZXJpYWwgZm9yIHJlbmRlcmluZyB0ZXh0LCBkZXJpdmVkIGZyb20gYSBiYXNlTWF0ZXJpYWxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgY29uc3QgdGV4dE1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCwge1xuICAgIGNoYWluZWQ6IHRydWUsXG4gICAgZXh0ZW5zaW9uczoge1xuICAgICAgZGVyaXZhdGl2ZXM6IHRydWVcbiAgICB9LFxuICAgIHVuaWZvcm1zOiB7XG4gICAgICB1VHJvaWthU0RGVGV4dHVyZToge3ZhbHVlOiBudWxsfSxcbiAgICAgIHVUcm9pa2FTREZUZXh0dXJlU2l6ZToge3ZhbHVlOiBuZXcgVmVjdG9yMigpfSxcbiAgICAgIHVUcm9pa2FTREZHbHlwaFNpemU6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthU0RGRXhwb25lbnQ6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthVG90YWxCb3VuZHM6IHt2YWx1ZTogbmV3IFZlY3RvcjQoMCwwLDAsMCl9LFxuICAgICAgdVRyb2lrYUNsaXBSZWN0OiB7dmFsdWU6IG5ldyBWZWN0b3I0KDAsMCwwLDApfSxcbiAgICAgIHVUcm9pa2FFZGdlT2Zmc2V0OiB7dmFsdWU6IDB9LFxuICAgICAgdVRyb2lrYUZpbGxPcGFjaXR5OiB7dmFsdWU6IDF9LFxuICAgICAgdVRyb2lrYVBvc2l0aW9uT2Zmc2V0OiB7dmFsdWU6IG5ldyBWZWN0b3IyKCl9LFxuICAgICAgdVRyb2lrYUN1cnZlUmFkaXVzOiB7dmFsdWU6IDB9LFxuICAgICAgdVRyb2lrYUJsdXJSYWRpdXM6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthU3Ryb2tlV2lkdGg6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthU3Ryb2tlQ29sb3I6IHt2YWx1ZTogbmV3IENvbG9yKCl9LFxuICAgICAgdVRyb2lrYVN0cm9rZU9wYWNpdHk6IHt2YWx1ZTogMX0sXG4gICAgICB1VHJvaWthT3JpZW50OiB7dmFsdWU6IG5ldyBNYXRyaXgzKCl9LFxuICAgICAgdVRyb2lrYVVzZUdseXBoQ29sb3JzOiB7dmFsdWU6IHRydWV9LFxuICAgICAgdVRyb2lrYVNERkRlYnVnOiB7dmFsdWU6IGZhbHNlfVxuICAgIH0sXG4gICAgdmVydGV4RGVmczogVkVSVEVYX0RFRlMsXG4gICAgdmVydGV4VHJhbnNmb3JtOiBWRVJURVhfVFJBTlNGT1JNLFxuICAgIGZyYWdtZW50RGVmczogRlJBR01FTlRfREVGUyxcbiAgICBmcmFnbWVudENvbG9yVHJhbnNmb3JtOiBGUkFHTUVOVF9UUkFOU0ZPUk0sXG4gICAgY3VzdG9tUmV3cml0ZXIoe3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJ9KSB7XG4gICAgICBsZXQgdURpZmZ1c2VSRSA9IC9cXGJ1bmlmb3JtXFxzK3ZlYzNcXHMrZGlmZnVzZVxcYi87XG4gICAgICBpZiAodURpZmZ1c2VSRS50ZXN0KGZyYWdtZW50U2hhZGVyKSkge1xuICAgICAgICAvLyBSZXBsYWNlIGFsbCBpbnN0YW5jZXMgb2YgYGRpZmZ1c2VgIHdpdGggb3VyIHZhcnlpbmdcbiAgICAgICAgZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlclxuICAgICAgICAgIC5yZXBsYWNlKHVEaWZmdXNlUkUsICd2YXJ5aW5nIHZlYzMgdlRyb2lrYUdseXBoQ29sb3InKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXGJkaWZmdXNlXFxiL2csICd2VHJvaWthR2x5cGhDb2xvcicpO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZlcnRleCBzaGFkZXIgZGVjbGFyZXMgdGhlIHVuaWZvcm0gc28gd2UgY2FuIGdyYWIgaXQgYXMgYSBmYWxsYmFja1xuICAgICAgICBpZiAoIXVEaWZmdXNlUkUudGVzdCh2ZXJ0ZXhTaGFkZXIpKSB7XG4gICAgICAgICAgdmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyLnJlcGxhY2UoXG4gICAgICAgICAgICB2b2lkTWFpblJlZ0V4cCxcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG4kJlxcbnZUcm9pa2FHbHlwaENvbG9yID0gdVRyb2lrYVVzZUdseXBoQ29sb3JzID8gYVRyb2lrYUdseXBoQ29sb3IgLyAyNTUuMCA6IGRpZmZ1c2U7XFxuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gRm9yY2UgdHJhbnNwYXJlbmN5IC0gVE9ETyBpcyB0aGlzIHJlYXNvbmFibGU/XG4gIHRleHRNYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cbiAgLy8gRm9yY2Ugc2luZ2xlIGRyYXcgY2FsbCB3aGVuIGRvdWJsZS1zaWRlZFxuICB0ZXh0TWF0ZXJpYWwuZm9yY2VTaW5nbGVQYXNzID0gdHJ1ZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0ZXh0TWF0ZXJpYWwsIHtcbiAgICBpc1Ryb2lrYVRleHRNYXRlcmlhbDoge3ZhbHVlOiB0cnVlfSxcblxuICAgIC8vIFdlYkdMU2hhZG93TWFwIHJldmVyc2VzIHRoZSBzaWRlIG9mIHRoZSBzaGFkb3cgbWF0ZXJpYWwgYnkgZGVmYXVsdCwgd2hpY2ggZmFpbHNcbiAgICAvLyBmb3IgcGxhbmVzLCBzbyBoZXJlIHdlIGZvcmNlIHRoZSBgc2hhZG93U2lkZWAgdG8gYWx3YXlzIG1hdGNoIHRoZSBtYWluIHNpZGUuXG4gICAgc2hhZG93U2lkZToge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWRlXG4gICAgICB9LFxuICAgICAgc2V0KCkge1xuICAgICAgICAvL25vLW9wXG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGV4dE1hdGVyaWFsXG59XG5cbmNvbnN0IGRlZmF1bHRNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi8gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHtcbiAgY29sb3I6IDB4ZmZmZmZmLFxuICBzaWRlOiBEb3VibGVTaWRlLFxuICB0cmFuc3BhcmVudDogdHJ1ZVxufSk7XG5jb25zdCBkZWZhdWx0U3Ryb2tlQ29sb3IgPSAweDgwODA4MDtcblxuY29uc3QgdGVtcE1hdDQgPSAvKiNfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCB0ZW1wVmVjM2EgPSAvKiNfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCB0ZW1wVmVjM2IgPSAvKiNfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCB0ZW1wQXJyYXkgPSBbXTtcbmNvbnN0IG9yaWdpbiA9IC8qI19fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IGRlZmF1bHRPcmllbnQgPSAnK3greSc7XG5cbmZ1bmN0aW9uIGZpcnN0KG8pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobykgPyBvWzBdIDogb1xufVxuXG5sZXQgZ2V0RmxhdFJheWNhc3RNZXNoID0gKCkgPT4ge1xuICBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gICAgbmV3IFBsYW5lR2VvbWV0cnkoMSwgMSksXG4gICAgZGVmYXVsdE1hdGVyaWFsXG4gICk7XG4gIGdldEZsYXRSYXljYXN0TWVzaCA9ICgpID0+IG1lc2g7XG4gIHJldHVybiBtZXNoXG59O1xubGV0IGdldEN1cnZlZFJheWNhc3RNZXNoID0gKCkgPT4ge1xuICBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gICAgbmV3IFBsYW5lR2VvbWV0cnkoMSwgMSwgMzIsIDEpLFxuICAgIGRlZmF1bHRNYXRlcmlhbFxuICApO1xuICBnZXRDdXJ2ZWRSYXljYXN0TWVzaCA9ICgpID0+IG1lc2g7XG4gIHJldHVybiBtZXNoXG59O1xuXG5jb25zdCBzeW5jU3RhcnRFdmVudCA9IHsgdHlwZTogJ3N5bmNzdGFydCcgfTtcbmNvbnN0IHN5bmNDb21wbGV0ZUV2ZW50ID0geyB0eXBlOiAnc3luY2NvbXBsZXRlJyB9O1xuXG5jb25zdCBTWU5DQUJMRV9QUk9QUyA9IFtcbiAgJ2ZvbnQnLFxuICAnZm9udFNpemUnLFxuICAnZm9udFN0eWxlJyxcbiAgJ2ZvbnRXZWlnaHQnLFxuICAnbGFuZycsXG4gICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xpbmVIZWlnaHQnLFxuICAnbWF4V2lkdGgnLFxuICAnb3ZlcmZsb3dXcmFwJyxcbiAgJ3RleHQnLFxuICAnZGlyZWN0aW9uJyxcbiAgJ3RleHRBbGlnbicsXG4gICd0ZXh0SW5kZW50JyxcbiAgJ3doaXRlU3BhY2UnLFxuICAnYW5jaG9yWCcsXG4gICdhbmNob3JZJyxcbiAgJ2NvbG9yUmFuZ2VzJyxcbiAgJ3NkZkdseXBoU2l6ZSdcbl07XG5cbmNvbnN0IENPUFlBQkxFX1BST1BTID0gU1lOQ0FCTEVfUFJPUFMuY29uY2F0KFxuICAnbWF0ZXJpYWwnLFxuICAnY29sb3InLFxuICAnZGVwdGhPZmZzZXQnLFxuICAnY2xpcFJlY3QnLFxuICAnY3VydmVSYWRpdXMnLFxuICAnb3JpZW50YXRpb24nLFxuICAnZ2x5cGhHZW9tZXRyeURldGFpbCdcbik7XG5cbi8qKlxuICogQGNsYXNzIFRleHRcbiAqXG4gKiBBIFRocmVlSlMgTWVzaCB0aGF0IHJlbmRlcnMgYSBzdHJpbmcgb2YgdGV4dCBvbiBhIHBsYW5lIGluIDNEIHNwYWNlIHVzaW5nIHNpZ25lZCBkaXN0YW5jZVxuICogZmllbGRzIChTREYpLlxuICovXG5jbGFzcyBUZXh0IGV4dGVuZHMgTWVzaCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdseXBoc0dlb21ldHJ5KCk7XG4gICAgc3VwZXIoZ2VvbWV0cnksIG51bGwpO1xuXG4gICAgLy8gPT09IFRleHQgbGF5b3V0IHByb3BlcnRpZXM6ID09PSAvL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXh0XG4gICAgICogVGhlIHN0cmluZyBvZiB0ZXh0IHRvIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHRoaXMudGV4dCA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gYW5jaG9yWFxuICAgICAqIERlZmluZXMgdGhlIGhvcml6b250YWwgcG9zaXRpb24gaW4gdGhlIHRleHQgYmxvY2sgdGhhdCBzaG91bGQgbGluZSB1cCB3aXRoIHRoZSBsb2NhbCBvcmlnaW4uXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBhIG51bWVyaWMgeCBwb3NpdGlvbiBpbiBsb2NhbCB1bml0cywgYSBzdHJpbmcgcGVyY2VudGFnZSBvZiB0aGUgdG90YWxcbiAgICAgKiB0ZXh0IGJsb2NrIHdpZHRoIGUuZy4gYCcyNSUnYCwgb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5d29yZCBzdHJpbmdzOiAnbGVmdCcsICdjZW50ZXInLFxuICAgICAqIG9yICdyaWdodCcuXG4gICAgICovXG4gICAgdGhpcy5hbmNob3JYID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IGFuY2hvcllcbiAgICAgKiBEZWZpbmVzIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBpbiB0aGUgdGV4dCBibG9jayB0aGF0IHNob3VsZCBsaW5lIHVwIHdpdGggdGhlIGxvY2FsIG9yaWdpbi5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGEgbnVtZXJpYyB5IHBvc2l0aW9uIGluIGxvY2FsIHVuaXRzIChub3RlOiBkb3duIGlzIG5lZ2F0aXZlIHkpLCBhIHN0cmluZ1xuICAgICAqIHBlcmNlbnRhZ2Ugb2YgdGhlIHRvdGFsIHRleHQgYmxvY2sgaGVpZ2h0IGUuZy4gYCcyNSUnYCwgb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5d29yZCBzdHJpbmdzOlxuICAgICAqICd0b3AnLCAndG9wLWJhc2VsaW5lJywgJ3RvcC1jYXAnLCAndG9wLWV4JywgJ21pZGRsZScsICdib3R0b20tYmFzZWxpbmUnLCBvciAnYm90dG9tJy5cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvclkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBjdXJ2ZVJhZGl1c1xuICAgICAqIERlZmluZXMgYSBjeWxpbmRyaWNhbCByYWRpdXMgYWxvbmcgd2hpY2ggdGhlIHRleHQncyBwbGFuZSB3aWxsIGJlIGN1cnZlZC4gUG9zaXRpdmUgbnVtYmVycyBwdXRcbiAgICAgKiB0aGUgY3lsaW5kZXIncyBjZW50ZXJsaW5lIChvcmllbnRlZCB2ZXJ0aWNhbGx5KSB0aGF0IGRpc3RhbmNlIGluIGZyb250IG9mIHRoZSB0ZXh0LCBmb3IgYSBjb25jYXZlXG4gICAgICogY3VydmF0dXJlLCB3aGlsZSBuZWdhdGl2ZSBudW1iZXJzIHB1dCBpdCBiZWhpbmQgdGhlIHRleHQgZm9yIGEgY29udmV4IGN1cnZhdHVyZS4gVGhlIGNlbnRlcmxpbmVcbiAgICAgKiB3aWxsIGJlIGFsaWduZWQgd2l0aCB0aGUgdGV4dCdzIGxvY2FsIG9yaWdpbjsgeW91IGNhbiB1c2UgYGFuY2hvclhgIHRvIG9mZnNldCBpdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIGVhY2ggZ2x5cGggaXMgYnkgZGVmYXVsdCByZW5kZXJlZCB3aXRoIGEgc2ltcGxlIHF1YWQsIGVhY2ggZ2x5cGggcmVtYWlucyBhIGZsYXQgcGxhbmVcbiAgICAgKiBpbnRlcm5hbGx5LiBZb3UgY2FuIHVzZSBgZ2x5cGhHZW9tZXRyeURldGFpbGAgdG8gYWRkIG1vcmUgdmVydGljZXMgZm9yIGN1cnZhdHVyZSBpbnNpZGUgZ2x5cGhzLlxuICAgICAqL1xuICAgIHRoaXMuY3VydmVSYWRpdXMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkaXJlY3Rpb25cbiAgICAgKiBTZXRzIHRoZSBiYXNlIGRpcmVjdGlvbiBmb3IgdGhlIHRleHQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIFwiYXV0b1wiIHdpbGwgY2hvb3NlIGEgZGlyZWN0aW9uIGJhc2VkXG4gICAgICogb24gdGhlIHRleHQncyBjb250ZW50IGFjY29yZGluZyB0byB0aGUgYmlkaSBzcGVjLiBBIHZhbHVlIG9mIFwibHRyXCIgb3IgXCJydGxcIiB3aWxsIGZvcmNlIHRoZSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgdGhpcy5kaXJlY3Rpb24gPSAnYXV0byc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVsbH0gZm9udFxuICAgICAqIFVSTCBvZiBhIGN1c3RvbSBmb250IHRvIGJlIHVzZWQuIEZvbnQgZmlsZXMgY2FuIGJlIGluIC50dGYsIC5vdGYsIG9yIC53b2ZmIChub3QgLndvZmYyKSBmb3JtYXRzLlxuICAgICAqIERlZmF1bHRzIHRvIE5vdG8gU2Fucy5cbiAgICAgKi9cbiAgICB0aGlzLmZvbnQgPSBudWxsOyAvL3dpbGwgdXNlIGRlZmF1bHQgZnJvbSBUZXh0QnVpbGRlclxuXG4gICAgdGhpcy51bmljb2RlRm9udHNVUkwgPSBudWxsOyAvL2RlZmF1bHRzIHRvIENETlxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBmb250U2l6ZVxuICAgICAqIFRoZSBzaXplIGF0IHdoaWNoIHRvIHJlbmRlciB0aGUgZm9udCBpbiBsb2NhbCB1bml0czsgY29ycmVzcG9uZHMgdG8gdGhlIGVtLWJveCBoZWlnaHRcbiAgICAgKiBvZiB0aGUgY2hvc2VuIGBmb250YC5cbiAgICAgKi9cbiAgICB0aGlzLmZvbnRTaXplID0gMC4xO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfCdub3JtYWwnfCdib2xkJ31cbiAgICAgKiBUaGUgd2VpZ2h0IG9mIHRoZSBmb250LiBDdXJyZW50bHkgb25seSB1c2VkIGZvciBmYWxsYmFjayBOb3RvIGZvbnRzLlxuICAgICAqL1xuICAgIHRoaXMuZm9udFdlaWdodCA9ICdub3JtYWwnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7J25vcm1hbCd8J2l0YWxpYyd9XG4gICAgICogVGhlIHN0eWxlIG9mIHRoZSBmb250LiBDdXJyZW50bHkgb25seSB1c2VkIGZvciBmYWxsYmFjayBOb3RvIGZvbnRzLlxuICAgICAqL1xuICAgIHRoaXMuZm9udFN0eWxlID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVsbH0gbGFuZ1xuICAgICAqIFRoZSBsYW5ndWFnZSBjb2RlIG9mIHRoaXMgdGV4dDsgY2FuIGJlIHVzZWQgZm9yIGV4cGxpY2l0bHkgc2VsZWN0aW5nIGNlcnRhaW4gQ0pLIGZvbnRzLlxuICAgICAqL1xuICAgIHRoaXMubGFuZyA9IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbGV0dGVyU3BhY2luZ1xuICAgICAqIFNldHMgYSB1bmlmb3JtIGFkanVzdG1lbnQgdG8gc3BhY2luZyBiZXR3ZWVuIGxldHRlcnMgYWZ0ZXIga2VybmluZyBpcyBhcHBsaWVkLiBQb3NpdGl2ZVxuICAgICAqIG51bWJlcnMgaW5jcmVhc2Ugc3BhY2luZyBhbmQgbmVnYXRpdmUgbnVtYmVycyBkZWNyZWFzZSBpdC5cbiAgICAgKi9cbiAgICB0aGlzLmxldHRlclNwYWNpbmcgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gbGluZUhlaWdodFxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiBlYWNoIGxpbmUgb2YgdGV4dCwgYXMgYSBtdWx0aXBsZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gJ25vcm1hbCdcbiAgICAgKiB3aGljaCBjaG9vc2VzIGEgcmVhc29uYWJsZSBoZWlnaHQgYmFzZWQgb24gdGhlIGNob3NlbiBmb250J3MgYXNjZW5kZXIvZGVzY2VuZGVyIG1ldHJpY3MuXG4gICAgICovXG4gICAgdGhpcy5saW5lSGVpZ2h0ID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IG1heFdpZHRoXG4gICAgICogVGhlIG1heGltdW0gd2lkdGggb2YgdGhlIHRleHQgYmxvY2ssIGFib3ZlIHdoaWNoIHRleHQgbWF5IHN0YXJ0IHdyYXBwaW5nIGFjY29yZGluZyB0byB0aGVcbiAgICAgKiBgd2hpdGVTcGFjZWAgYW5kIGBvdmVyZmxvd1dyYXBgIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgdGhpcy5tYXhXaWR0aCA9IEluZmluaXR5O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBvdmVyZmxvd1dyYXBcbiAgICAgKiBEZWZpbmVzIGhvdyB0ZXh0IHdyYXBzIGlmIHRoZSBgd2hpdGVTcGFjZWAgcHJvcGVydHkgaXMgYG5vcm1hbGAuIENhbiBiZSBlaXRoZXIgYCdub3JtYWwnYFxuICAgICAqIHRvIGJyZWFrIGF0IHdoaXRlc3BhY2UgY2hhcmFjdGVycywgb3IgYCdicmVhay13b3JkJ2AgdG8gYWxsb3cgYnJlYWtpbmcgd2l0aGluIHdvcmRzLlxuICAgICAqIERlZmF1bHRzIHRvIGAnbm9ybWFsJ2AuXG4gICAgICovXG4gICAgdGhpcy5vdmVyZmxvd1dyYXAgPSAnbm9ybWFsJztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gdGV4dEFsaWduXG4gICAgICogVGhlIGhvcml6b250YWwgYWxpZ25tZW50IG9mIGVhY2ggbGluZSBvZiB0ZXh0IHdpdGhpbiB0aGUgb3ZlcmFsbCB0ZXh0IGJvdW5kaW5nIGJveC5cbiAgICAgKi9cbiAgICB0aGlzLnRleHRBbGlnbiA9ICdsZWZ0JztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdGV4dEluZGVudFxuICAgICAqIEluZGVudGF0aW9uIGZvciB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgbGluZTsgc2VlIENTUyBgdGV4dC1pbmRlbnRgLlxuICAgICAqL1xuICAgIHRoaXMudGV4dEluZGVudCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHdoaXRlU3BhY2VcbiAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGV4dCBzaG91bGQgd3JhcCB3aGVuIGEgbGluZSByZWFjaGVzIHRoZSBgbWF4V2lkdGhgLiBDYW5cbiAgICAgKiBiZSBlaXRoZXIgYCdub3JtYWwnYCAodGhlIGRlZmF1bHQpLCB0byBhbGxvdyB3cmFwcGluZyBhY2NvcmRpbmcgdG8gdGhlIGBvdmVyZmxvd1dyYXBgIHByb3BlcnR5LFxuICAgICAqIG9yIGAnbm93cmFwJ2AgdG8gcHJldmVudCB3cmFwcGluZy4gTm90ZSB0aGF0IGAnbm9ybWFsJ2AgaGVyZSBob25vcnMgbmV3bGluZSBjaGFyYWN0ZXJzIHRvXG4gICAgICogbWFudWFsbHkgYnJlYWsgbGluZXMsIG1ha2luZyBpdCBiZWhhdmUgbW9yZSBsaWtlIGAncHJlLXdyYXAnYCBkb2VzIGluIENTUy5cbiAgICAgKi9cbiAgICB0aGlzLndoaXRlU3BhY2UgPSAnbm9ybWFsJztcblxuXG4gICAgLy8gPT09IFByZXNlbnRhdGlvbiBwcm9wZXJ0aWVzOiA9PT0gLy9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1RIUkVFLk1hdGVyaWFsfSBtYXRlcmlhbFxuICAgICAqIERlZmluZXMgYSBfYmFzZV8gbWF0ZXJpYWwgdG8gYmUgdXNlZCB3aGVuIHJlbmRlcmluZyB0aGUgdGV4dC4gVGhpcyBtYXRlcmlhbCB3aWxsIGJlXG4gICAgICogYXV0b21hdGljYWxseSByZXBsYWNlZCB3aXRoIGEgbWF0ZXJpYWwgZGVyaXZlZCBmcm9tIGl0LCB0aGF0IGFkZHMgc2hhZGVyIGNvZGUgdG9cbiAgICAgKiBkZWNyZWFzZSB0aGUgYWxwaGEgZm9yIGVhY2ggZnJhZ21lbnQgKHBpeGVsKSBvdXRzaWRlIHRoZSB0ZXh0IGdseXBocywgd2l0aCBhbnRpYWxpYXNpbmcuXG4gICAgICogQnkgZGVmYXVsdCBpdCB3aWxsIGRlcml2ZSBmcm9tIGEgc2ltcGxlIHdoaXRlIE1lc2hCYXNpY01hdGVyaWFsLCBidXQgeW91IGNhbiB1c2UgYW55XG4gICAgICogb2YgdGhlIG90aGVyIG1lc2ggbWF0ZXJpYWxzIHRvIGdhaW4gb3RoZXIgZmVhdHVyZXMgbGlrZSBsaWdodGluZywgdGV4dHVyZSBtYXBzLCBldGMuXG4gICAgICpcbiAgICAgKiBBbHNvIHNlZSB0aGUgYGNvbG9yYCBzaG9ydGN1dCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xudW1iZXJ8VEhSRUUuQ29sb3J9IGNvbG9yXG4gICAgICogVGhpcyBpcyBhIHNob3J0Y3V0IGZvciBzZXR0aW5nIHRoZSBgY29sb3JgIG9mIHRoZSB0ZXh0J3MgbWF0ZXJpYWwuIFlvdSBjYW4gdXNlIHRoaXNcbiAgICAgKiBpZiB5b3UgZG9uJ3Qgd2FudCB0byBzcGVjaWZ5IGEgd2hvbGUgY3VzdG9tIGBtYXRlcmlhbGAuIEFsc28sIGlmIHlvdSBkbyB1c2UgYSBjdXN0b21cbiAgICAgKiBgbWF0ZXJpYWxgLCB0aGlzIGNvbG9yIHdpbGwgb25seSBiZSB1c2VkIGZvciB0aGlzIHBhcnRpY3VhciBUZXh0IGluc3RhbmNlLCBldmVuIGlmXG4gICAgICogdGhhdCBzYW1lIG1hdGVyaWFsIGluc3RhbmNlIGlzIHNoYXJlZCBhY3Jvc3MgbXVsdGlwbGUgVGV4dCBvYmplY3RzLlxuICAgICAqL1xuICAgIHRoaXMuY29sb3IgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7b2JqZWN0fG51bGx9IGNvbG9yUmFuZ2VzXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoaXMgYWxsb3dzIG1vcmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb2YgY29sb3JzIGZvciBpbmRpdmlkdWFsIG9yIHJhbmdlcyBvZiBjaGFyYWN0ZXJzLFxuICAgICAqIHRha2luZyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hdGVyaWFsJ3MgYGNvbG9yYC4gSXRzIGZvcm1hdCBpcyBhbiBPYmplY3Qgd2hvc2Uga2V5cyBlYWNoXG4gICAgICogZGVmaW5lIGEgc3RhcnRpbmcgY2hhcmFjdGVyIGluZGV4IGZvciBhIHJhbmdlLCBhbmQgd2hvc2UgdmFsdWVzIGFyZSB0aGUgY29sb3IgZm9yIGVhY2hcbiAgICAgKiByYW5nZS4gVGhlIGNvbG9yIHZhbHVlIGNhbiBiZSBhIG51bWVyaWMgaGV4IGNvbG9yIHZhbHVlLCBhIGBUSFJFRS5Db2xvcmAgb2JqZWN0LCBvclxuICAgICAqIGFueSBvZiB0aGUgc3RyaW5ncyBhY2NlcHRlZCBieSBgVEhSRUUuQ29sb3JgLlxuICAgICAqL1xuICAgIHRoaXMuY29sb3JSYW5nZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZVdpZHRoXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSB3aWR0aCBvZiBhbiBvdXRsaW5lL2hhbG8gdG8gYmUgZHJhd24gYXJvdW5kIGVhY2ggdGV4dCBnbHlwaCB1c2luZyB0aGUgYG91dGxpbmVDb2xvcmAgYW5kIGBvdXRsaW5lT3BhY2l0eWAuXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy5cbiAgICAgKiBgXCIxMiVcImAgd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYCwgd2hpY2ggbWVhbnNcbiAgICAgKiBubyBvdXRsaW5lIHdpbGwgYmUgZHJhd24gdW5sZXNzIGFuIGBvdXRsaW5lT2Zmc2V0WC9ZYCBvciBgb3V0bGluZUJsdXJgIGlzIHNldC5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfFRIUkVFLkNvbG9yfSBvdXRsaW5lQ29sb3JcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IG91dGxpbmUsIGlmIGBvdXRsaW5lV2lkdGhgL2BvdXRsaW5lQmx1cmAvYG91dGxpbmVPZmZzZXRYL1lgIGFyZSBzZXQuXG4gICAgICogRGVmYXVsdHMgdG8gYmxhY2suXG4gICAgICovXG4gICAgdGhpcy5vdXRsaW5lQ29sb3IgPSAweDAwMDAwMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gb3V0bGluZU9wYWNpdHlcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIG91dGxpbmUsIGlmIGBvdXRsaW5lV2lkdGhgL2BvdXRsaW5lQmx1cmAvYG91dGxpbmVPZmZzZXRYL1lgIGFyZSBzZXQuXG4gICAgICogRGVmYXVsdHMgdG8gYDFgLlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZU9wYWNpdHkgPSAxO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZUJsdXJcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogQSBibHVyIHJhZGl1cyBhcHBsaWVkIHRvIHRoZSBvdXRlciBlZGdlIG9mIHRoZSB0ZXh0J3Mgb3V0bGluZS4gSWYgdGhlIGBvdXRsaW5lV2lkdGhgIGlzXG4gICAgICogemVybywgdGhlIGJsdXIgd2lsbCBiZSBhcHBsaWVkIGF0IHRoZSBnbHlwaCBlZGdlLCBsaWtlIENTUydzIGB0ZXh0LXNoYWRvd2AgYmx1ciByYWRpdXMuXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy5cbiAgICAgKiBgXCIxMiVcImAgd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVCbHVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IG91dGxpbmVPZmZzZXRYXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIEEgaG9yaXpvbnRhbCBvZmZzZXQgZm9yIHRoZSB0ZXh0IG91dGxpbmUuXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy4gYFwiMTIlXCJgXG4gICAgICogd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVPZmZzZXRYID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IG91dGxpbmVPZmZzZXRZXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIEEgdmVydGljYWwgb2Zmc2V0IGZvciB0aGUgdGV4dCBvdXRsaW5lLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuIGBcIjEyJVwiYFxuICAgICAqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICovXG4gICAgdGhpcy5vdXRsaW5lT2Zmc2V0WSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBzdHJva2VXaWR0aFxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgd2lkdGggb2YgYW4gaW5uZXIgc3Ryb2tlIGRyYXduIGluc2lkZSBlYWNoIHRleHQgZ2x5cGggdXNpbmcgdGhlIGBzdHJva2VDb2xvcmAgYW5kIGBzdHJva2VPcGFjaXR5YC5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLiBgXCIxMiVcImBcbiAgICAgKiB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcnxUSFJFRS5Db2xvcn0gc3Ryb2tlQ29sb3JcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IHN0cm9rZSwgaWYgYHN0cm9rZVdpZHRoYCBpcyBncmVhdGVyIHRoYW4gemVyby4gRGVmYXVsdHMgdG8gZ3JheS5cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZUNvbG9yID0gZGVmYXVsdFN0cm9rZUNvbG9yO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBzdHJva2VPcGFjaXR5XG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBzdHJva2UsIGlmIGBzdHJva2VXaWR0aGAgaXMgZ3JlYXRlciB0aGFuIHplcm8uIERlZmF1bHRzIHRvIGAxYC5cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBmaWxsT3BhY2l0eVxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgZ2x5cGgncyBmaWxsIGZyb20gMCB0byAxLiBUaGlzIGJlaGF2ZXMgbGlrZSB0aGUgbWF0ZXJpYWwncyBgb3BhY2l0eWAgYnV0IGFsbG93c1xuICAgICAqIGdpdmluZyB0aGUgZmlsbCBhIGRpZmZlcmVudCBvcGFjaXR5IHRoYW4gdGhlIGBzdHJva2VPcGFjaXR5YC4gQSBmaWxsT3BhY2l0eSBvZiBgMGAgbWFrZXMgdGhlXG4gICAgICogaW50ZXJpb3Igb2YgdGhlIGdseXBoIGludmlzaWJsZSwgbGVhdmluZyBqdXN0IHRoZSBgc3Ryb2tlV2lkdGhgLiBEZWZhdWx0cyB0byBgMWAuXG4gICAgICovXG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGRlcHRoT2Zmc2V0XG4gICAgICogVGhpcyBpcyBhIHNob3J0Y3V0IGZvciBzZXR0aW5nIHRoZSBtYXRlcmlhbCdzIGBwb2x5Z29uT2Zmc2V0YCBhbmQgcmVsYXRlZCBwcm9wZXJ0aWVzLFxuICAgICAqIHdoaWNoIGNhbiBiZSB1c2VmdWwgaW4gcHJldmVudGluZyB6LWZpZ2h0aW5nIHdoZW4gdGhpcyB0ZXh0IGlzIGxhaWQgb24gdG9wIG9mIGFub3RoZXJcbiAgICAgKiBwbGFuZSBpbiB0aGUgc2NlbmUuIFBvc2l0aXZlIG51bWJlcnMgYXJlIGZ1cnRoZXIgZnJvbSB0aGUgY2FtZXJhLCBuZWdhdGl2ZXMgY2xvc2VyLlxuICAgICAqL1xuICAgIHRoaXMuZGVwdGhPZmZzZXQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7QXJyYXk8bnVtYmVyPn0gY2xpcFJlY3RcbiAgICAgKiBJZiBzcGVjaWZpZWQsIGRlZmluZXMgYSBgW21pblgsIG1pblksIG1heFgsIG1heFldYCBvZiBhIHJlY3RhbmdsZSBvdXRzaWRlIG9mIHdoaWNoIGFsbFxuICAgICAqIHBpeGVscyB3aWxsIGJlIGRpc2NhcmRlZC4gVGhpcyBjYW4gYmUgdXNlZCBmb3IgZXhhbXBsZSB0byBjbGlwIG92ZXJmbG93aW5nIHRleHQgd2hlblxuICAgICAqIGB3aGl0ZVNwYWNlPSdub3dyYXAnYC5cbiAgICAgKi9cbiAgICB0aGlzLmNsaXBSZWN0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gb3JpZW50YXRpb25cbiAgICAgKiBEZWZpbmVzIHRoZSBheGlzIHBsYW5lIG9uIHdoaWNoIHRoZSB0ZXh0IHNob3VsZCBiZSBsYWlkIG91dCB3aGVuIHRoZSBtZXNoIGhhcyBubyBleHRyYVxuICAgICAqIHJvdGF0aW9uIHRyYW5zZm9ybS4gSXQgaXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIHdpdGggdHdvIGF4ZXM6IHRoZSBob3Jpem9udGFsIGF4aXMgd2l0aFxuICAgICAqIHBvc2l0aXZlIHBvaW50aW5nIHJpZ2h0LCBhbmQgdGhlIHZlcnRpY2FsIGF4aXMgd2l0aCBwb3NpdGl2ZSBwb2ludGluZyB1cC4gQnkgZGVmYXVsdCB0aGlzXG4gICAgICogaXMgJyt4K3knLCBtZWFuaW5nIHRoZSB0ZXh0IHNpdHMgb24gdGhlIHh5IHBsYW5lIHdpdGggdGhlIHRleHQncyB0b3AgdG93YXJkIHBvc2l0aXZlIHlcbiAgICAgKiBhbmQgZmFjaW5nIHBvc2l0aXZlIHouIEEgdmFsdWUgb2YgJyt4LXonIHdvdWxkIHBsYWNlIGl0IG9uIHRoZSB4eiBwbGFuZSB3aXRoIHRoZSB0ZXh0J3NcbiAgICAgKiB0b3AgdG93YXJkIG5lZ2F0aXZlIHogYW5kIGZhY2luZyBwb3NpdGl2ZSB5LlxuICAgICAqL1xuICAgIHRoaXMub3JpZW50YXRpb24gPSBkZWZhdWx0T3JpZW50O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBnbHlwaEdlb21ldHJ5RGV0YWlsXG4gICAgICogQ29udHJvbHMgbnVtYmVyIG9mIHZlcnRpY2FsL2hvcml6b250YWwgc2VnbWVudHMgdGhhdCBtYWtlIHVwIGVhY2ggZ2x5cGgncyByZWN0YW5ndWxhclxuICAgICAqIHBsYW5lLiBEZWZhdWx0cyB0byAxLiBUaGlzIGNhbiBiZSBpbmNyZWFzZWQgdG8gcHJvdmlkZSBtb3JlIGdlb21ldHJpY2FsIGRldGFpbCBmb3IgY3VzdG9tXG4gICAgICogdmVydGV4IHNoYWRlciBlZmZlY3RzLCBmb3IgZXhhbXBsZS5cbiAgICAgKi9cbiAgICB0aGlzLmdseXBoR2VvbWV0cnlEZXRhaWwgPSAxO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfG51bGx9IHNkZkdseXBoU2l6ZVxuICAgICAqIFRoZSBzaXplIG9mIGVhY2ggZ2x5cGgncyBTREYgKHNpZ25lZCBkaXN0YW5jZSBmaWVsZCkgdXNlZCBmb3IgcmVuZGVyaW5nLiBUaGlzIG11c3QgYmUgYVxuICAgICAqIHBvd2VyLW9mLXR3byBudW1iZXIuIERlZmF1bHRzIHRvIDY0IHdoaWNoIGlzIGdlbmVyYWxseSBhIGdvb2QgYmFsYW5jZSBvZiBzaXplIGFuZCBxdWFsaXR5XG4gICAgICogZm9yIG1vc3QgZm9udHMuIExhcmdlciBzaXplcyBjYW4gaW1wcm92ZSB0aGUgcXVhbGl0eSBvZiBnbHlwaCByZW5kZXJpbmcgYnkgaW5jcmVhc2luZ1xuICAgICAqIHRoZSBzaGFycG5lc3Mgb2YgY29ybmVycyBhbmQgcHJldmVudGluZyBsb3NzIG9mIHZlcnkgdGhpbiBsaW5lcywgYXQgdGhlIGV4cGVuc2Ugb2ZcbiAgICAgKiBpbmNyZWFzZWQgbWVtb3J5IGZvb3RwcmludCBhbmQgbG9uZ2VyIFNERiBnZW5lcmF0aW9uIHRpbWUuXG4gICAgICovXG4gICAgdGhpcy5zZGZHbHlwaFNpemUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gZ3B1QWNjZWxlcmF0ZVNERlxuICAgICAqIFdoZW4gYHRydWVgLCB0aGUgU0RGIGdlbmVyYXRpb24gcHJvY2VzcyB3aWxsIGJlIEdQVS1hY2NlbGVyYXRlZCB3aXRoIFdlYkdMIHdoZW4gcG9zc2libGUsXG4gICAgICogbWFraW5nIGl0IG11Y2ggZmFzdGVyIGVzcGVjaWFsbHkgZm9yIGNvbXBsZXggZ2x5cGhzLCBhbmQgZmFsbGluZyBiYWNrIHRvIGEgSmF2YVNjcmlwdCB2ZXJzaW9uXG4gICAgICogZXhlY3V0ZWQgaW4gd2ViIHdvcmtlcnMgd2hlbiBzdXBwb3J0IGlzbid0IGF2YWlsYWJsZS4gSXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHN1cHBvcnQsXG4gICAgICogYnV0IGl0J3Mgc3RpbGwgc29tZXdoYXQgZXhwZXJpbWVudGFsLCBzbyB5b3UgY2FuIHNldCBpdCB0byBgZmFsc2VgIHRvIGZvcmNlIGl0IHRvIHVzZSB0aGUgSlNcbiAgICAgKiB2ZXJzaW9uIGlmIHlvdSBlbmNvdW50ZXIgaXNzdWVzIHdpdGggaXQuXG4gICAgICovXG4gICAgdGhpcy5ncHVBY2NlbGVyYXRlU0RGID0gdHJ1ZTtcblxuICAgIHRoaXMuZGVidWdTREYgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0ZXh0IHJlbmRlcmluZyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdGV4dC1yZWxhdGVkIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcy5cbiAgICogVGhpcyBpcyBhbiBhc3luYyBwcm9jZXNzLCBzbyB5b3UgY2FuIHBhc3MgaW4gYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIGl0XG4gICAqIGZpbmlzaGVzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqL1xuICBzeW5jKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX25lZWRzU3luYykge1xuICAgICAgdGhpcy5fbmVlZHNTeW5jID0gZmFsc2U7XG5cbiAgICAgIC8vIElmIHRoZXJlJ3MgYW5vdGhlciBzeW5jIHN0aWxsIGluIHByb2dyZXNzLCBxdWV1ZVxuICAgICAgaWYgKHRoaXMuX2lzU3luY2luZykge1xuICAgICAgICAodGhpcy5fcXVldWVkU3luY3MgfHwgKHRoaXMuX3F1ZXVlZFN5bmNzID0gW10pKS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lzU3luY2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChzeW5jU3RhcnRFdmVudCk7XG5cbiAgICAgICAgZ2V0VGV4dFJlbmRlckluZm8oe1xuICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCxcbiAgICAgICAgICBmb250OiB0aGlzLmZvbnQsXG4gICAgICAgICAgbGFuZzogdGhpcy5sYW5nLFxuICAgICAgICAgIGZvbnRTaXplOiB0aGlzLmZvbnRTaXplIHx8IDAuMSxcbiAgICAgICAgICBmb250V2VpZ2h0OiB0aGlzLmZvbnRXZWlnaHQgfHwgJ25vcm1hbCcsXG4gICAgICAgICAgZm9udFN0eWxlOiB0aGlzLmZvbnRTdHlsZSB8fCAnbm9ybWFsJyxcbiAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiB0aGlzLmxldHRlclNwYWNpbmcgfHwgMCxcbiAgICAgICAgICBsaW5lSGVpZ2h0OiB0aGlzLmxpbmVIZWlnaHQgfHwgJ25vcm1hbCcsXG4gICAgICAgICAgbWF4V2lkdGg6IHRoaXMubWF4V2lkdGgsXG4gICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbiB8fCAnYXV0bycsXG4gICAgICAgICAgdGV4dEFsaWduOiB0aGlzLnRleHRBbGlnbixcbiAgICAgICAgICB0ZXh0SW5kZW50OiB0aGlzLnRleHRJbmRlbnQsXG4gICAgICAgICAgd2hpdGVTcGFjZTogdGhpcy53aGl0ZVNwYWNlLFxuICAgICAgICAgIG92ZXJmbG93V3JhcDogdGhpcy5vdmVyZmxvd1dyYXAsXG4gICAgICAgICAgYW5jaG9yWDogdGhpcy5hbmNob3JYLFxuICAgICAgICAgIGFuY2hvclk6IHRoaXMuYW5jaG9yWSxcbiAgICAgICAgICBjb2xvclJhbmdlczogdGhpcy5jb2xvclJhbmdlcyxcbiAgICAgICAgICBpbmNsdWRlQ2FyZXRQb3NpdGlvbnM6IHRydWUsIC8vVE9ETyBwYXJhbWV0ZXJpemVcbiAgICAgICAgICBzZGZHbHlwaFNpemU6IHRoaXMuc2RmR2x5cGhTaXplLFxuICAgICAgICAgIGdwdUFjY2VsZXJhdGVTREY6IHRoaXMuZ3B1QWNjZWxlcmF0ZVNERixcbiAgICAgICAgICB1bmljb2RlRm9udHNVUkw6IHRoaXMudW5pY29kZUZvbnRzVVJMLFxuICAgICAgICB9LCB0ZXh0UmVuZGVySW5mbyA9PiB7XG4gICAgICAgICAgdGhpcy5faXNTeW5jaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBTYXZlIHJlc3VsdCBmb3IgbGF0ZXIgdXNlIGluIG9uQmVmb3JlUmVuZGVyXG4gICAgICAgICAgdGhpcy5fdGV4dFJlbmRlckluZm8gPSB0ZXh0UmVuZGVySW5mbztcblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZ2VvbWV0cnkgYXR0cmlidXRlc1xuICAgICAgICAgIHRoaXMuZ2VvbWV0cnkudXBkYXRlR2x5cGhzKFxuICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uZ2x5cGhCb3VuZHMsXG4gICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5nbHlwaEF0bGFzSW5kaWNlcyxcbiAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmJsb2NrQm91bmRzLFxuICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uY2h1bmtlZEJvdW5kcyxcbiAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmdseXBoQ29sb3JzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIElmIHdlIGhhZCBleHRyYSBzeW5jIHJlcXVlc3RzIHF1ZXVlZCB1cCwga2ljayBpdCBvZmZcbiAgICAgICAgICBjb25zdCBxdWV1ZWQgPSB0aGlzLl9xdWV1ZWRTeW5jcztcbiAgICAgICAgICBpZiAocXVldWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZWRTeW5jcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgcXVldWVkLmZvckVhY2goZm4gPT4gZm4gJiYgZm4oKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc3luY0NvbXBsZXRlRXZlbnQpO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZSBhIHN5bmMgaWYgbmVlZGVkIC0gbm90ZSBpdCB3b24ndCBjb21wbGV0ZSB1bnRpbCBuZXh0IGZyYW1lIGF0IHRoZVxuICAgKiBlYXJsaWVzdCBzbyBpZiBwb3NzaWJsZSBpdCdzIGEgZ29vZCBpZGVhIHRvIGNhbGwgc3luYygpIG1hbnVhbGx5IGFzIHNvb24gYXNcbiAgICogYWxsIHRoZSBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBzZXQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgb25CZWZvcmVSZW5kZXIocmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXApIHtcbiAgICB0aGlzLnN5bmMoKTtcblxuICAgIC8vIFRoaXMgbWF5IG5vdCBhbHdheXMgYmUgYSB0ZXh0IG1hdGVyaWFsLCBlLmcuIGlmIHRoZXJlJ3MgYSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsIHByZXNlbnRcbiAgICBpZiAobWF0ZXJpYWwuaXNUcm9pa2FUZXh0TWF0ZXJpYWwpIHtcbiAgICAgIHRoaXMuX3ByZXBhcmVGb3JSZW5kZXIobWF0ZXJpYWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG9ydGN1dCB0byBkaXNwb3NlIHRoZSBnZW9tZXRyeSBzcGVjaWZpYyB0byB0aGlzIGluc3RhbmNlLlxuICAgKiBOb3RlOiB3ZSBkb24ndCBhbHNvIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgaGVyZSBiZWNhdXNlIGlmIGFueXRoaW5nIGVsc2UgaXNcbiAgICogc2hhcmluZyB0aGUgc2FtZSBiYXNlIG1hdGVyaWFsIGl0IHdpbGwgcmVzdWx0IGluIGEgcGF1c2UgbmV4dCBmcmFtZSBhcyB0aGUgcHJvZ3JhbVxuICAgKiBpcyByZWNvbXBpbGVkLiBJbnN0ZWFkIHVzZXJzIGNhbiBkaXNwb3NlIHRoZSBiYXNlIG1hdGVyaWFsIG1hbnVhbGx5LCBsaWtlIG5vcm1hbCxcbiAgICogYW5kIHdlJ2xsIGFsc28gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBhdCB0aGF0IHRpbWUuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7VHJvaWthVGV4dFJlbmRlckluZm98bnVsbH0gdGV4dFJlbmRlckluZm9cbiAgICogQHJlYWRvbmx5XG4gICAqIFRoZSBjdXJyZW50IHByb2Nlc3NlZCByZW5kZXJpbmcgZGF0YSBmb3IgdGhpcyBUZXh0TWVzaCwgcmV0dXJuZWQgYnkgdGhlIFRleHRCdWlsZGVyIGFmdGVyXG4gICAqIGEgYHN5bmMoKWAgY2FsbC4gVGhpcyB3aWxsIGJlIGBudWxsYCBpbml0aWFsbHksIGFuZCBtYXkgYmUgc3RhbGUgZm9yIGEgc2hvcnQgcGVyaW9kIHVudGlsXG4gICAqIHRoZSBhc3luY2hyb3VzIGBzeW5jKClgIHByb2Nlc3MgY29tcGxldGVzLlxuICAgKi9cbiAgZ2V0IHRleHRSZW5kZXJJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0UmVuZGVySW5mbyB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSB0ZXh0IGRlcml2ZWQgbWF0ZXJpYWwgZnJvbSB0aGUgYmFzZSBtYXRlcmlhbC4gQ2FuIGJlIG92ZXJyaWRkZW4gdG8gdXNlIGEgY3VzdG9tXG4gICAqIGRlcml2ZWQgbWF0ZXJpYWwuXG4gICAqL1xuICBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKVxuICB9XG5cbiAgLy8gSGFuZGxlciBmb3IgYXV0b21hdGljYWxseSB3cmFwcGluZyB0aGUgYmFzZSBtYXRlcmlhbCB3aXRoIG91ciB1cGdyYWRlcy4gV2UgZG8gdGhlIHdyYXBwaW5nXG4gIC8vIGxhemlseSBvbiBfcmVhZF8gcmF0aGVyIHRoYW4gd3JpdGUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd3JhcHBpbmcgb24gdHJhbnNpZW50IHZhbHVlcy5cbiAgZ2V0IG1hdGVyaWFsKCkge1xuICAgIGxldCBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWw7XG4gICAgY29uc3QgYmFzZU1hdGVyaWFsID0gdGhpcy5fYmFzZU1hdGVyaWFsIHx8IHRoaXMuX2RlZmF1bHRNYXRlcmlhbCB8fCAodGhpcy5fZGVmYXVsdE1hdGVyaWFsID0gZGVmYXVsdE1hdGVyaWFsLmNsb25lKCkpO1xuICAgIGlmICghZGVyaXZlZE1hdGVyaWFsIHx8ICFkZXJpdmVkTWF0ZXJpYWwuaXNEZXJpdmVkRnJvbShiYXNlTWF0ZXJpYWwpKSB7XG4gICAgICBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLmNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpO1xuICAgICAgLy8gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCB3aGVuIGl0cyBiYXNlIG1hdGVyaWFsIGlzIGRpc3Bvc2VkOlxuICAgICAgYmFzZU1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgIGJhc2VNYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25EaXNwb3NlKTtcbiAgICAgICAgZGVyaXZlZE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBJZiB0ZXh0IG91dGxpbmUgaXMgY29uZmlndXJlZCwgcmVuZGVyIGl0IGFzIGEgcHJlbGltaW5hcnkgZHJhdyB1c2luZyBUaHJlZSdzIG11bHRpLW1hdGVyaWFsXG4gICAgLy8gZmVhdHVyZSAoc2VlIEdseXBoc0dlb21ldHJ5IHdoaWNoIHNldHMgdXAgYGdyb3Vwc2AgZm9yIHRoaXMgcHVycG9zZSkgRG9pbmcgaXQgd2l0aCBtdWx0aVxuICAgIC8vIG1hdGVyaWFscyBlbnN1cmVzIHRoZSBsYXllcnMgYXJlIGFsd2F5cyByZW5kZXJlZCBjb25zZWN1dGl2ZWx5IGluIGEgY29uc2lzdGVudCBvcmRlci5cbiAgICAvLyBFYWNoIGxheWVyIHdpbGwgdHJpZ2dlciBvbkJlZm9yZVJlbmRlciB3aXRoIHRoZSBhcHByb3ByaWF0ZSBtYXRlcmlhbC5cbiAgICBpZiAodGhpcy5oYXNPdXRsaW5lKCkpIHtcbiAgICAgIGxldCBvdXRsaW5lTWF0ZXJpYWwgPSBkZXJpdmVkTWF0ZXJpYWwuX291dGxpbmVNdGw7XG4gICAgICBpZiAoIW91dGxpbmVNYXRlcmlhbCkge1xuICAgICAgICBvdXRsaW5lTWF0ZXJpYWwgPSBkZXJpdmVkTWF0ZXJpYWwuX291dGxpbmVNdGwgPSBPYmplY3QuY3JlYXRlKGRlcml2ZWRNYXRlcmlhbCwge1xuICAgICAgICAgIGlkOiB7dmFsdWU6IGRlcml2ZWRNYXRlcmlhbC5pZCArIDAuMX1cbiAgICAgICAgfSk7XG4gICAgICAgIG91dGxpbmVNYXRlcmlhbC5pc1RleHRPdXRsaW5lTWF0ZXJpYWwgPSB0cnVlO1xuICAgICAgICBvdXRsaW5lTWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICAgICAgICBvdXRsaW5lTWF0ZXJpYWwubWFwID0gbnVsbDsgLy8/Pz9cbiAgICAgICAgZGVyaXZlZE1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgICAgZGVyaXZlZE1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UpO1xuICAgICAgICAgIG91dGxpbmVNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgb3V0bGluZU1hdGVyaWFsLFxuICAgICAgICBkZXJpdmVkTWF0ZXJpYWxcbiAgICAgIF1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlcml2ZWRNYXRlcmlhbFxuICAgIH1cbiAgfVxuICBzZXQgbWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gICAgaWYgKGJhc2VNYXRlcmlhbCAmJiBiYXNlTWF0ZXJpYWwuaXNUcm9pa2FUZXh0TWF0ZXJpYWwpIHsgLy9wcmV2ZW50IGRvdWJsZS1kZXJpdmF0aW9uXG4gICAgICB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWwuYmFzZU1hdGVyaWFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgfVxuICB9XG5cbiAgaGFzT3V0bGluZSgpIHtcbiAgICByZXR1cm4gISEodGhpcy5vdXRsaW5lV2lkdGggfHwgdGhpcy5vdXRsaW5lQmx1ciB8fCB0aGlzLm91dGxpbmVPZmZzZXRYIHx8IHRoaXMub3V0bGluZU9mZnNldFkpXG4gIH1cblxuICBnZXQgZ2x5cGhHZW9tZXRyeURldGFpbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5kZXRhaWxcbiAgfVxuICBzZXQgZ2x5cGhHZW9tZXRyeURldGFpbChkZXRhaWwpIHtcbiAgICB0aGlzLmdlb21ldHJ5LmRldGFpbCA9IGRldGFpbDtcbiAgfVxuXG4gIGdldCBjdXJ2ZVJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5jdXJ2ZVJhZGl1c1xuICB9XG4gIHNldCBjdXJ2ZVJhZGl1cyhyKSB7XG4gICAgdGhpcy5nZW9tZXRyeS5jdXJ2ZVJhZGl1cyA9IHI7XG4gIH1cblxuICAvLyBDcmVhdGUgYW5kIHVwZGF0ZSBtYXRlcmlhbCBmb3Igc2hhZG93cyB1cG9uIHJlcXVlc3Q6XG4gIGdldCBjdXN0b21EZXB0aE1hdGVyaWFsKCkge1xuICAgIHJldHVybiBmaXJzdCh0aGlzLm1hdGVyaWFsKS5nZXREZXB0aE1hdGVyaWFsKClcbiAgfVxuICBzZXQgY3VzdG9tRGVwdGhNYXRlcmlhbChtKSB7XG4gICAgLy8gZnV0dXJlOiBsZXQgdGhlIHVzZXIgb3ZlcnJpZGUgd2l0aCB0aGVpciBvd24/XG4gIH1cbiAgZ2V0IGN1c3RvbURpc3RhbmNlTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIGZpcnN0KHRoaXMubWF0ZXJpYWwpLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICB9XG4gIHNldCBjdXN0b21EaXN0YW5jZU1hdGVyaWFsKG0pIHtcbiAgICAvLyBmdXR1cmU6IGxldCB0aGUgdXNlciBvdmVycmlkZSB3aXRoIHRoZWlyIG93bj9cbiAgfVxuXG4gIF9wcmVwYXJlRm9yUmVuZGVyKG1hdGVyaWFsKSB7XG4gICAgY29uc3QgaXNPdXRsaW5lID0gbWF0ZXJpYWwuaXNUZXh0T3V0bGluZU1hdGVyaWFsO1xuICAgIGNvbnN0IHVuaWZvcm1zID0gbWF0ZXJpYWwudW5pZm9ybXM7XG4gICAgY29uc3QgdGV4dEluZm8gPSB0aGlzLnRleHRSZW5kZXJJbmZvO1xuICAgIGlmICh0ZXh0SW5mbykge1xuICAgICAgY29uc3Qge3NkZlRleHR1cmUsIGJsb2NrQm91bmRzfSA9IHRleHRJbmZvO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERlRleHR1cmUudmFsdWUgPSBzZGZUZXh0dXJlO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERlRleHR1cmVTaXplLnZhbHVlLnNldChzZGZUZXh0dXJlLmltYWdlLndpZHRoLCBzZGZUZXh0dXJlLmltYWdlLmhlaWdodCk7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU0RGR2x5cGhTaXplLnZhbHVlID0gdGV4dEluZm8uc2RmR2x5cGhTaXplO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERkV4cG9uZW50LnZhbHVlID0gdGV4dEluZm8uc2RmRXhwb25lbnQ7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthVG90YWxCb3VuZHMudmFsdWUuZnJvbUFycmF5KGJsb2NrQm91bmRzKTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FVc2VHbHlwaENvbG9ycy52YWx1ZSA9ICFpc091dGxpbmUgJiYgISF0ZXh0SW5mby5nbHlwaENvbG9ycztcblxuICAgICAgbGV0IGRpc3RhbmNlT2Zmc2V0ID0gMDtcbiAgICAgIGxldCBibHVyUmFkaXVzID0gMDtcbiAgICAgIGxldCBzdHJva2VXaWR0aCA9IDA7XG4gICAgICBsZXQgZmlsbE9wYWNpdHk7XG4gICAgICBsZXQgc3Ryb2tlT3BhY2l0eTtcbiAgICAgIGxldCBzdHJva2VDb2xvcjtcbiAgICAgIGxldCBvZmZzZXRYID0gMDtcbiAgICAgIGxldCBvZmZzZXRZID0gMDtcblxuICAgICAgaWYgKGlzT3V0bGluZSkge1xuICAgICAgICBsZXQge291dGxpbmVXaWR0aCwgb3V0bGluZU9mZnNldFgsIG91dGxpbmVPZmZzZXRZLCBvdXRsaW5lQmx1ciwgb3V0bGluZU9wYWNpdHl9ID0gdGhpcztcbiAgICAgICAgZGlzdGFuY2VPZmZzZXQgPSB0aGlzLl9wYXJzZVBlcmNlbnQob3V0bGluZVdpZHRoKSB8fCAwO1xuICAgICAgICBibHVyUmFkaXVzID0gTWF0aC5tYXgoMCwgdGhpcy5fcGFyc2VQZXJjZW50KG91dGxpbmVCbHVyKSB8fCAwKTtcbiAgICAgICAgZmlsbE9wYWNpdHkgPSBvdXRsaW5lT3BhY2l0eTtcbiAgICAgICAgb2Zmc2V0WCA9IHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lT2Zmc2V0WCkgfHwgMDtcbiAgICAgICAgb2Zmc2V0WSA9IHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lT2Zmc2V0WSkgfHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gTWF0aC5tYXgoMCwgdGhpcy5fcGFyc2VQZXJjZW50KHRoaXMuc3Ryb2tlV2lkdGgpIHx8IDApO1xuICAgICAgICBpZiAoc3Ryb2tlV2lkdGgpIHtcbiAgICAgICAgICBzdHJva2VDb2xvciA9IHRoaXMuc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgdW5pZm9ybXMudVRyb2lrYVN0cm9rZUNvbG9yLnZhbHVlLnNldChzdHJva2VDb2xvciA9PSBudWxsID8gZGVmYXVsdFN0cm9rZUNvbG9yIDogc3Ryb2tlQ29sb3IpO1xuICAgICAgICAgIHN0cm9rZU9wYWNpdHkgPSB0aGlzLnN0cm9rZU9wYWNpdHk7XG4gICAgICAgICAgaWYgKHN0cm9rZU9wYWNpdHkgPT0gbnVsbCkgc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZmlsbE9wYWNpdHkgPSB0aGlzLmZpbGxPcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICB1bmlmb3Jtcy51VHJvaWthRWRnZU9mZnNldC52YWx1ZSA9IGRpc3RhbmNlT2Zmc2V0O1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVBvc2l0aW9uT2Zmc2V0LnZhbHVlLnNldChvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FCbHVyUmFkaXVzLnZhbHVlID0gYmx1clJhZGl1cztcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTdHJva2VXaWR0aC52YWx1ZSA9IHN0cm9rZVdpZHRoO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVN0cm9rZU9wYWNpdHkudmFsdWUgPSBzdHJva2VPcGFjaXR5O1xuICAgICAgdW5pZm9ybXMudVRyb2lrYUZpbGxPcGFjaXR5LnZhbHVlID0gZmlsbE9wYWNpdHkgPT0gbnVsbCA/IDEgOiBmaWxsT3BhY2l0eTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FDdXJ2ZVJhZGl1cy52YWx1ZSA9IHRoaXMuY3VydmVSYWRpdXMgfHwgMDtcblxuICAgICAgbGV0IGNsaXBSZWN0ID0gdGhpcy5jbGlwUmVjdDtcbiAgICAgIGlmIChjbGlwUmVjdCAmJiBBcnJheS5pc0FycmF5KGNsaXBSZWN0KSAmJiBjbGlwUmVjdC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlLmZyb21BcnJheShjbGlwUmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBjbGlwcGluZyAtIGNob29zZSBhIGZpbml0ZSByZWN0IHRoYXQgc2hvdWxkbid0IGV2ZXIgYmUgcmVhY2hlZCBieSBvdmVyZmxvd2luZyBnbHlwaHMgb3Igb3V0bGluZXNcbiAgICAgICAgY29uc3QgcGFkID0gKHRoaXMuZm9udFNpemUgfHwgMC4xKSAqIDEwMDtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlLnNldChcbiAgICAgICAgICBibG9ja0JvdW5kc1swXSAtIHBhZCxcbiAgICAgICAgICBibG9ja0JvdW5kc1sxXSAtIHBhZCxcbiAgICAgICAgICBibG9ja0JvdW5kc1syXSArIHBhZCxcbiAgICAgICAgICBibG9ja0JvdW5kc1szXSArIHBhZFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5nZW9tZXRyeS5hcHBseUNsaXBSZWN0KHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZSk7XG4gICAgfVxuICAgIHVuaWZvcm1zLnVUcm9pa2FTREZEZWJ1Zy52YWx1ZSA9ICEhdGhpcy5kZWJ1Z1NERjtcbiAgICBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0gISF0aGlzLmRlcHRoT2Zmc2V0O1xuICAgIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgPSB0aGlzLmRlcHRoT2Zmc2V0IHx8IDA7XG5cbiAgICAvLyBTaG9ydGN1dCBmb3Igc2V0dGluZyBtYXRlcmlhbCBjb2xvciB2aWEgYGNvbG9yYCBwcm9wIG9uIHRoZSBtZXNoOyB0aGlzIGlzXG4gICAgLy8gYXBwbGllZCBvbmx5IHRvIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvIGF2b2lkIG11dGF0aW5nIGEgc2hhcmVkIGJhc2UgbWF0ZXJpYWwuXG4gICAgY29uc3QgY29sb3IgPSBpc091dGxpbmUgPyAodGhpcy5vdXRsaW5lQ29sb3IgfHwgMCkgOiB0aGlzLmNvbG9yO1xuXG4gICAgaWYgKGNvbG9yID09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSBtYXRlcmlhbC5jb2xvcjsgLy9pbmhlcml0IGZyb20gYmFzZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb2xvck9iaiA9IG1hdGVyaWFsLmhhc093blByb3BlcnR5KCdjb2xvcicpID8gbWF0ZXJpYWwuY29sb3IgOiAobWF0ZXJpYWwuY29sb3IgPSBuZXcgQ29sb3IoKSk7XG4gICAgICBpZiAoY29sb3IgIT09IGNvbG9yT2JqLl9pbnB1dCB8fCB0eXBlb2YgY29sb3IgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbG9yT2JqLnNldChjb2xvck9iai5faW5wdXQgPSBjb2xvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYmFzZSBvcmllbnRhdGlvblxuICAgIGxldCBvcmllbnQgPSB0aGlzLm9yaWVudGF0aW9uIHx8IGRlZmF1bHRPcmllbnQ7XG4gICAgaWYgKG9yaWVudCAhPT0gbWF0ZXJpYWwuX29yaWVudGF0aW9uKSB7XG4gICAgICBsZXQgcm90TWF0ID0gdW5pZm9ybXMudVRyb2lrYU9yaWVudC52YWx1ZTtcbiAgICAgIG9yaWVudCA9IG9yaWVudC5yZXBsYWNlKC9bXi0reHl6XS9nLCAnJyk7XG4gICAgICBsZXQgbWF0Y2ggPSBvcmllbnQgIT09IGRlZmF1bHRPcmllbnQgJiYgb3JpZW50Lm1hdGNoKC9eKFstK10pKFt4eXpdKShbLStdKShbeHl6XSkkLyk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbGV0IFssIGhTaWduLCBoQXhpcywgdlNpZ24sIHZBeGlzXSA9IG1hdGNoO1xuICAgICAgICB0ZW1wVmVjM2Euc2V0KDAsIDAsIDApW2hBeGlzXSA9IGhTaWduID09PSAnLScgPyAxIDogLTE7XG4gICAgICAgIHRlbXBWZWMzYi5zZXQoMCwgMCwgMClbdkF4aXNdID0gdlNpZ24gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgdGVtcE1hdDQubG9va0F0KG9yaWdpbiwgdGVtcFZlYzNhLmNyb3NzKHRlbXBWZWMzYiksIHRlbXBWZWMzYik7XG4gICAgICAgIHJvdE1hdC5zZXRGcm9tTWF0cml4NCh0ZW1wTWF0NCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3RNYXQuaWRlbnRpdHkoKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsLl9vcmllbnRhdGlvbiA9IG9yaWVudDtcbiAgICB9XG4gIH1cblxuICBfcGFyc2VQZXJjZW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKC0/W1xcZC5dKyklJC8pO1xuICAgICAgbGV0IHBjdCA9IG1hdGNoID8gcGFyc2VGbG9hdChtYXRjaFsxXSkgOiBOYU47XG4gICAgICB2YWx1ZSA9IChpc05hTihwY3QpID8gMCA6IHBjdCAvIDEwMCkgKiB0aGlzLmZvbnRTaXplO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgYSBwb2ludCBpbiBsb2NhbCBzcGFjZSB0byBhbiB4L3kgaW4gdGhlIHRleHQgcGxhbmUuXG4gICAqL1xuICBsb2NhbFBvc2l0aW9uVG9UZXh0Q29vcmRzKHBvc2l0aW9uLCB0YXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG4gICAgdGFyZ2V0LmNvcHkocG9zaXRpb24pOyAvL3NpbXBsZSBub24tY3VydmVkIGNhc2UgaXMgMToxXG4gICAgY29uc3QgciA9IHRoaXMuY3VydmVSYWRpdXM7XG4gICAgaWYgKHIpIHsgLy9mbGF0dGVuIHRoZSBjdXJ2ZVxuICAgICAgdGFyZ2V0LnggPSBNYXRoLmF0YW4yKHBvc2l0aW9uLngsIE1hdGguYWJzKHIpIC0gTWF0aC5hYnMocG9zaXRpb24ueikpICogTWF0aC5hYnMocik7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgYSBwb2ludCBpbiB3b3JsZCBzcGFjZSB0byBhbiB4L3kgaW4gdGhlIHRleHQgcGxhbmUuXG4gICAqL1xuICB3b3JsZFBvc2l0aW9uVG9UZXh0Q29vcmRzKHBvc2l0aW9uLCB0YXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG4gICAgdGVtcFZlYzNhLmNvcHkocG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzLmxvY2FsUG9zaXRpb25Ub1RleHRDb29yZHModGhpcy53b3JsZFRvTG9jYWwodGVtcFZlYzNhKSwgdGFyZ2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZSBDdXN0b20gcmF5Y2FzdGluZyB0byB0ZXN0IGFnYWluc3QgdGhlIHdob2xlIHRleHQgYmxvY2sncyBtYXggcmVjdGFuZ3VsYXIgYm91bmRzXG4gICAqIFRPRE8gaXMgdGhlcmUgYW55IHJlYXNvbiB0byBtYWtlIHRoaXMgbW9yZSBncmFudWxhciwgbGlrZSB3aXRoaW4gaW5kaXZpZHVhbCBsaW5lIG9yIGdseXBoIHJlY3RzP1xuICAgKi9cbiAgcmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpIHtcbiAgICBjb25zdCB7dGV4dFJlbmRlckluZm8sIGN1cnZlUmFkaXVzfSA9IHRoaXM7XG4gICAgaWYgKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgICBjb25zdCBib3VuZHMgPSB0ZXh0UmVuZGVySW5mby5ibG9ja0JvdW5kcztcbiAgICAgIGNvbnN0IHJheWNhc3RNZXNoID0gY3VydmVSYWRpdXMgPyBnZXRDdXJ2ZWRSYXljYXN0TWVzaCgpIDogZ2V0RmxhdFJheWNhc3RNZXNoKCk7XG4gICAgICBjb25zdCBnZW9tID0gcmF5Y2FzdE1lc2guZ2VvbWV0cnk7XG4gICAgICBjb25zdCB7cG9zaXRpb24sIHV2fSA9IGdlb20uYXR0cmlidXRlcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXYuY291bnQ7IGkrKykge1xuICAgICAgICBsZXQgeCA9IGJvdW5kc1swXSArICh1di5nZXRYKGkpICogKGJvdW5kc1syXSAtIGJvdW5kc1swXSkpO1xuICAgICAgICBjb25zdCB5ID0gYm91bmRzWzFdICsgKHV2LmdldFkoaSkgKiAoYm91bmRzWzNdIC0gYm91bmRzWzFdKSk7XG4gICAgICAgIGxldCB6ID0gMDtcbiAgICAgICAgaWYgKGN1cnZlUmFkaXVzKSB7XG4gICAgICAgICAgeiA9IGN1cnZlUmFkaXVzIC0gTWF0aC5jb3MoeCAvIGN1cnZlUmFkaXVzKSAqIGN1cnZlUmFkaXVzO1xuICAgICAgICAgIHggPSBNYXRoLnNpbih4IC8gY3VydmVSYWRpdXMpICogY3VydmVSYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24uc2V0WFlaKGksIHgsIHksIHopO1xuICAgICAgfVxuICAgICAgZ2VvbS5ib3VuZGluZ1NwaGVyZSA9IHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmU7XG4gICAgICBnZW9tLmJvdW5kaW5nQm94ID0gdGhpcy5nZW9tZXRyeS5ib3VuZGluZ0JveDtcbiAgICAgIHJheWNhc3RNZXNoLm1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcbiAgICAgIHJheWNhc3RNZXNoLm1hdGVyaWFsLnNpZGUgPSB0aGlzLm1hdGVyaWFsLnNpZGU7XG4gICAgICB0ZW1wQXJyYXkubGVuZ3RoID0gMDtcbiAgICAgIHJheWNhc3RNZXNoLnJheWNhc3QocmF5Y2FzdGVyLCB0ZW1wQXJyYXkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGVtcEFycmF5W2ldLm9iamVjdCA9IHRoaXM7XG4gICAgICAgIGludGVyc2VjdHMucHVzaCh0ZW1wQXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvcHkoc291cmNlKSB7XG4gICAgLy8gUHJldmVudCBjb3B5aW5nIHRoZSBnZW9tZXRyeSByZWZlcmVuY2Ugc28gd2UgZG9uJ3QgZW5kIHVwIHNoYXJpbmcgYXR0cmlidXRlcyBiZXR3ZWVuIGluc3RhbmNlc1xuICAgIGNvbnN0IGdlb20gPSB0aGlzLmdlb21ldHJ5O1xuICAgIHN1cGVyLmNvcHkoc291cmNlKTtcbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbTtcblxuICAgIENPUFlBQkxFX1BST1BTLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICB0aGlzW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpXG4gIH1cbn1cblxuXG4vLyBDcmVhdGUgc2V0dGVycyBmb3IgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0ZXh0IGxheW91dDpcblNZTkNBQkxFX1BST1BTLmZvckVhY2gocHJvcCA9PiB7XG4gIGNvbnN0IHByaXZhdGVLZXkgPSAnX3ByaXZhdGVfJyArIHByb3A7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0LnByb3RvdHlwZSwgcHJvcCwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzW3ByaXZhdGVLZXldXG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdGhpc1twcml2YXRlS2V5XSkge1xuICAgICAgICB0aGlzW3ByaXZhdGVLZXldID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX25lZWRzU3luYyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pO1xuXG5jb25zdCBzeW5jU3RhcnRFdmVudCQxID0geyB0eXBlOiBcInN5bmNzdGFydFwiIH07XG5jb25zdCBzeW5jQ29tcGxldGVFdmVudCQxID0geyB0eXBlOiBcInN5bmNjb21wbGV0ZVwiIH07XG5jb25zdCBtZW1iZXJJbmRleEF0dHJOYW1lID0gXCJhVHJvaWthVGV4dEJhdGNoTWVtYmVySW5kZXhcIjtcblxuXG4vKlxuRGF0YSB0ZXh0dXJlIHBhY2tpbmcgc3RyYXRlZ3k6XG5cbiMgQ29tbW9uOlxuMC0xNTogbWF0cml4XG4xNi0xOTogdVRyb2lrYVRvdGFsQm91bmRzXG4yMC0yMzogdVRyb2lrYUNsaXBSZWN0XG4yNDogZGlmZnVzZSAoY29sb3Ivb3V0bGluZUNvbG9yKVxuMjU6IHVUcm9pa2FGaWxsT3BhY2l0eSAoZmlsbE9wYWNpdHkvb3V0bGluZU9wYWNpdHkpXG4yNjogdVRyb2lrYUN1cnZlUmFkaXVzXG4yNzogPGJsYW5rPlxuXG4jIE1haW46XG4yODogdVRyb2lrYVN0cm9rZVdpZHRoXG4yOTogdVRyb2lrYVN0cm9rZUNvbG9yXG4zMDogdVRyb2lrYVN0cm9rZU9wYWNpdHlcblxuIyBPdXRsaW5lOlxuMjgtMjk6IHVUcm9pa2FQb3NpdGlvbk9mZnNldFxuMzA6IHVUcm9pa2FFZGdlT2Zmc2V0XG4zMTogdVRyb2lrYUJsdXJSYWRpdXNcbiovXG5jb25zdCBmbG9hdHNQZXJNZW1iZXIgPSAzMjtcblxuY29uc3QgdGVtcEJveDMgPSBuZXcgQm94MygpO1xuY29uc3QgdGVtcENvbG9yJDEgPSBuZXcgQ29sb3IoKTtcblxuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKlxuICogQSBzcGVjaWFsaXplZCBgVGV4dGAgaW1wbGVtZW50YXRpb24gdGhhdCBhY2NlcHRzIGFueSBudW1iZXIgb2YgYFRleHRgIGNoaWxkcmVuXG4gKiBhbmQgYXV0b21hdGljYWxseSBiYXRjaGVzIHRoZW0gdG9nZXRoZXIgdG8gcmVuZGVyIGluIGEgc2luZ2xlIGRyYXcgY2FsbC5cbiAqXG4gKiBUaGUgYG1hdGVyaWFsYCBvZiBlYWNoIGNoaWxkIGBUZXh0YCB3aWxsIGJlIGlnbm9yZWQsIGFuZCB0aGUgYG1hdGVyaWFsYCBvZiB0aGVcbiAqIGBCYXRjaGVkVGV4dGAgd2lsbCBiZSB1c2VkIGZvciBhbGwgb2YgdGhlbSBpbnN0ZWFkLlxuICpcbiAqIE5PVEU6IFRoaXMgb25seSB3b3JrcyBpbiBXZWJHTDIgb3Igd2hlcmUgdGhlIE9FU190ZXh0dXJlX2Zsb2F0IGV4dGVuc2lvbiBpcyBhdmFpbGFibGUuXG4gKi9cbmNsYXNzIEJhdGNoZWRUZXh0IGV4dGVuZHMgVGV4dCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUGFja2luZ0luZm9cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggLSB0aGUgcGFja2luZyBvcmRlciBpbmRleCB3aGVuIGxhc3QgcGFja2VkLCBvciAtMVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZGlydHkgLSB3aGV0aGVyIGl0IGhhcyBzeW5jZWQgc2luY2UgbGFzdCBwYWNrXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPFRleHQsIFBhY2tpbmdJbmZvPn1cbiAgICAgKi9cbiAgICB0aGlzLl9tZW1iZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2RhdGFUZXh0dXJlcyA9IHt9O1xuXG4gICAgdGhpcy5fb25NZW1iZXJTeW5jZWQgPSAoZSkgPT4ge1xuICAgICAgdGhpcy5fbWVtYmVycy5nZXQoZS50YXJnZXQpLmRpcnR5ID0gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiBCYXRjaCBhbnkgVGV4dCBvYmplY3RzIGFkZGVkIGFzIGNoaWxkcmVuXG4gICAqL1xuICBhZGQgKC4uLm9iamVjdHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvYmplY3RzW2ldIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICB0aGlzLmFkZFRleHQob2JqZWN0c1tpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlci5hZGQob2JqZWN0c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVtb3ZlICguLi5vYmplY3RzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob2JqZWN0c1tpXSBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVUZXh0KG9iamVjdHNbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIucmVtb3ZlKG9iamVjdHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RleHR9IHRleHRcbiAgICovXG4gIGFkZFRleHQgKHRleHQpIHtcbiAgICBpZiAoIXRoaXMuX21lbWJlcnMuaGFzKHRleHQpKSB7XG4gICAgICB0aGlzLl9tZW1iZXJzLnNldCh0ZXh0LCB7XG4gICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgZ2x5cGhDb3VudDogLTEsXG4gICAgICAgIGRpcnR5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRleHQuYWRkRXZlbnRMaXN0ZW5lcihcInN5bmNjb21wbGV0ZVwiLCB0aGlzLl9vbk1lbWJlclN5bmNlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICAgKi9cbiAgcmVtb3ZlVGV4dCAodGV4dCkge1xuICAgIHRoaXMuX25lZWRzUmVwYWNrID0gdHJ1ZTtcbiAgICB0ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzeW5jY29tcGxldGVcIiwgdGhpcy5fb25NZW1iZXJTeW5jZWQpO1xuICAgIHRoaXMuX21lbWJlcnMuZGVsZXRlKHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGUgY3VzdG9tIGRlcml2YXRpb24gd2l0aCBleHRyYSBiYXRjaGluZyBsb2dpY1xuICAgKi9cbiAgY3JlYXRlRGVyaXZlZE1hdGVyaWFsIChiYXNlTWF0ZXJpYWwpIHtcbiAgICByZXR1cm4gY3JlYXRlQmF0Y2hlZFRleHRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpO1xuICB9XG5cbiAgdXBkYXRlTWF0cml4V29ybGQgKGZvcmNlKSB7XG4gICAgc3VwZXIudXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuICAgIHRoaXMudXBkYXRlQm91bmRzKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBiYXRjaGVkIGdlb21ldHJ5IGJvdW5kcyB0byBob2xkIGFsbCBtZW1iZXJzXG4gICAqL1xuICB1cGRhdGVCb3VuZHMgKCkge1xuICAgIC8vIFVwZGF0ZSBtZW1iZXIgbG9jYWwgbWF0cmljZXMgYW5kIHRoZSBvdmVyYWxsIGJvdW5kc1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xuICAgIHRoaXMuX21lbWJlcnMuZm9yRWFjaCgoXywgdGV4dCkgPT4ge1xuICAgICAgaWYgKHRleHQubWF0cml4QXV0b1VwZGF0ZSkgdGV4dC51cGRhdGVNYXRyaXgoKTsgLy8gaWdub3JlIHdvcmxkIG1hdHJpeFxuICAgICAgdGVtcEJveDMuY29weSh0ZXh0Lmdlb21ldHJ5LmJvdW5kaW5nQm94KS5hcHBseU1hdHJpeDQodGV4dC5tYXRyaXgpO1xuICAgICAgYmJveC51bmlvbih0ZW1wQm94Myk7XG4gICAgfSk7XG4gICAgYmJveC5nZXRCb3VuZGluZ1NwaGVyZSh0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgaGFzT3V0bGluZSgpIHtcbiAgICAvLyBJdGVyYXRvci5zb21lKCkgbm90IHN1cHBvcnRlZCBpbiBTYWZhcmlcbiAgICBmb3IgKGxldCBtZW1iZXIgb2YgdGhpcy5fbWVtYmVycy5rZXlzKCkpIHtcbiAgICAgIGlmIChtZW1iZXIuaGFzT3V0bGluZSgpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiBDb3B5IG1lbWJlciBtYXRyaWNlcyBhbmQgdW5pZm9ybSB2YWx1ZXMgaW50byB0aGUgZGF0YSB0ZXh0dXJlXG4gICAqL1xuICBfcHJlcGFyZUZvclJlbmRlciAobWF0ZXJpYWwpIHtcbiAgICBjb25zdCBpc091dGxpbmUgPSBtYXRlcmlhbC5pc1RleHRPdXRsaW5lTWF0ZXJpYWw7XG4gICAgbWF0ZXJpYWwudW5pZm9ybXMudVRyb2lrYUlzT3V0bGluZS52YWx1ZSA9IGlzT3V0bGluZTtcblxuICAgIC8vIFJlc2l6ZSB0aGUgdGV4dHVyZSB0byBmaXQgaW4gcG93ZXJzIG9mIDJcbiAgICBsZXQgdGV4dHVyZSA9IHRoaXMuX2RhdGFUZXh0dXJlc1tpc091dGxpbmUgPyAnb3V0bGluZScgOiAnbWFpbiddO1xuICAgIGNvbnN0IGRhdGFMZW5ndGggPSBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKHRoaXMuX21lbWJlcnMuc2l6ZSAqIGZsb2F0c1Blck1lbWJlcikpKTtcbiAgICBpZiAoIXRleHR1cmUgfHwgZGF0YUxlbmd0aCAhPT0gdGV4dHVyZS5pbWFnZS5kYXRhLmxlbmd0aCkge1xuICAgICAgLy8gY29uc29sZS5sb2coYHJlc2l6aW5nOiAke2RhdGFMZW5ndGh9YCk7XG4gICAgICBpZiAodGV4dHVyZSkgdGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKGRhdGFMZW5ndGggLyA0LCAxMDI0KTtcbiAgICAgIHRleHR1cmUgPSB0aGlzLl9kYXRhVGV4dHVyZXNbaXNPdXRsaW5lID8gJ291dGxpbmUnIDogJ21haW4nXSA9IG5ldyBEYXRhVGV4dHVyZShcbiAgICAgICAgbmV3IEZsb2F0MzJBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGRhdGFMZW5ndGggLyA0IC8gd2lkdGgsXG4gICAgICAgIFJHQkFGb3JtYXQsXG4gICAgICAgIEZsb2F0VHlwZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXhEYXRhID0gdGV4dHVyZS5pbWFnZS5kYXRhO1xuICAgIGNvbnN0IHNldFRleERhdGEgPSAoaW5kZXgsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHRleERhdGFbaW5kZXhdKSB7XG4gICAgICAgIHRleERhdGFbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fbWVtYmVycy5mb3JFYWNoKCh7IGluZGV4LCBkaXJ0eSB9LCB0ZXh0KSA9PiB7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXggKiBmbG9hdHNQZXJNZW1iZXI7XG5cbiAgICAgICAgLy8gTWF0cml4XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IHRleHQubWF0cml4LmVsZW1lbnRzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICBzZXRUZXhEYXRhKHN0YXJ0SW5kZXggKyBpLCBtYXRyaXhbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGV0IHRoZSBtZW1iZXIgcG9wdWxhdGUgdGhlIHVuaWZvcm1zLCBzaW5jZSB0aGF0IGRvZXMgYWxsIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgICAvLyBsb2dpYyBhbmQgaGFuZGxpbmcgb2YgZGVmYXVsdHMsIGFuZCB3ZSdsbCBqdXN0IGdyYWIgdGhlIHJlc3VsdHMgZnJvbSB0aGVyZVxuICAgICAgICB0ZXh0Ll9wcmVwYXJlRm9yUmVuZGVyKG1hdGVyaWFsKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHVUcm9pa2FUb3RhbEJvdW5kcyxcbiAgICAgICAgICB1VHJvaWthQ2xpcFJlY3QsXG4gICAgICAgICAgdVRyb2lrYVBvc2l0aW9uT2Zmc2V0LFxuICAgICAgICAgIHVUcm9pa2FFZGdlT2Zmc2V0LFxuICAgICAgICAgIHVUcm9pa2FCbHVyUmFkaXVzLFxuICAgICAgICAgIHVUcm9pa2FTdHJva2VXaWR0aCxcbiAgICAgICAgICB1VHJvaWthU3Ryb2tlQ29sb3IsXG4gICAgICAgICAgdVRyb2lrYVN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgdVRyb2lrYUZpbGxPcGFjaXR5LFxuICAgICAgICAgIHVUcm9pa2FDdXJ2ZVJhZGl1cyxcbiAgICAgICAgfSA9IG1hdGVyaWFsLnVuaWZvcm1zO1xuXG4gICAgICAgIC8vIFRvdGFsIGJvdW5kcyBmb3IgdXZcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICBzZXRUZXhEYXRhKHN0YXJ0SW5kZXggKyAxNiArIGksIHVUcm9pa2FUb3RhbEJvdW5kcy52YWx1ZS5nZXRDb21wb25lbnQoaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xpcCByZWN0XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgc2V0VGV4RGF0YShzdGFydEluZGV4ICsgMjAgKyBpLCB1VHJvaWthQ2xpcFJlY3QudmFsdWUuZ2V0Q29tcG9uZW50KGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbG9yXG4gICAgICAgIGxldCBjb2xvciA9IGlzT3V0bGluZSA/ICh0ZXh0Lm91dGxpbmVDb2xvciB8fCAwKSA6IHRleHQuY29sb3I7XG4gICAgICAgIGlmIChjb2xvciA9PSBudWxsKSBjb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICAgIGlmIChjb2xvciA9PSBudWxsKSBjb2xvciA9IHRoaXMubWF0ZXJpYWwuY29sb3I7XG4gICAgICAgIGlmIChjb2xvciA9PSBudWxsKSBjb2xvciA9IDB4ZmZmZmZmO1xuICAgICAgICBzZXRUZXhEYXRhKHN0YXJ0SW5kZXggKyAyNCwgdGVtcENvbG9yJDEuc2V0KGNvbG9yKS5nZXRIZXgoKSk7XG5cbiAgICAgICAgLy8gRmlsbCBvcGFjaXR5IC8gb3V0bGluZSBvcGFjaXR5XG4gICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIDI1LCB1VHJvaWthRmlsbE9wYWNpdHkudmFsdWUpO1xuXG4gICAgICAgIC8vIEN1cnZlIHJhZGl1c1xuICAgICAgICBzZXRUZXhEYXRhKHN0YXJ0SW5kZXggKyAyNiwgdVRyb2lrYUN1cnZlUmFkaXVzLnZhbHVlKTtcblxuICAgICAgICBpZiAoaXNPdXRsaW5lKSB7XG4gICAgICAgICAgLy8gT3V0bGluZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgc2V0VGV4RGF0YShzdGFydEluZGV4ICsgMjgsIHVUcm9pa2FQb3NpdGlvbk9mZnNldC52YWx1ZS54KTtcbiAgICAgICAgICBzZXRUZXhEYXRhKHN0YXJ0SW5kZXggKyAyOSwgdVRyb2lrYVBvc2l0aW9uT2Zmc2V0LnZhbHVlLnkpO1xuICAgICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIDMwLCB1VHJvaWthRWRnZU9mZnNldC52YWx1ZSk7XG4gICAgICAgICAgc2V0VGV4RGF0YShzdGFydEluZGV4ICsgMzEsIHVUcm9pa2FCbHVyUmFkaXVzLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTdHJva2UgcHJvcGVydGllc1xuICAgICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIDI4LCB1VHJvaWthU3Ryb2tlV2lkdGgudmFsdWUpO1xuICAgICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIDI5LCB0ZW1wQ29sb3IkMS5zZXQodVRyb2lrYVN0cm9rZUNvbG9yLnZhbHVlKS5nZXRIZXgoKSk7XG4gICAgICAgICAgc2V0VGV4RGF0YShzdGFydEluZGV4ICsgMzAsIHVUcm9pa2FTdHJva2VPcGFjaXR5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIG1hdGVyaWFsLnNldE1hdHJpeFRleHR1cmUodGV4dHVyZSk7XG5cbiAgICAvLyBGb3IgdGhlIG5vbi1tZW1iZXItc3BlY2lmaWMgdW5pZm9ybXM6XG4gICAgc3VwZXIuX3ByZXBhcmVGb3JSZW5kZXIobWF0ZXJpYWwpO1xuICB9XG5cbiAgc3luYyAoY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBza2lwIG1lbWJlcnMgdXBkYXRpbmcgdGhlaXIgZ2VvbWV0cmllcywganVzdCB1c2UgdGV4dFJlbmRlckluZm8gZGlyZWN0bHlcblxuICAgIC8vIFRyaWdnZXIgc3luYyBvbiBhbGwgbWVtYmVycyB0aGF0IG5lZWQgaXRcbiAgICBsZXQgc3luY1Byb21pc2VzID0gdGhpcy5fbmVlZHNSZXBhY2sgPyBbXSA6IG51bGw7XG4gICAgdGhpcy5fbmVlZHNSZXBhY2sgPSBmYWxzZTtcbiAgICB0aGlzLl9tZW1iZXJzLmZvckVhY2goKHBhY2tpbmdJbmZvLCB0ZXh0KSA9PiB7XG4gICAgICBpZiAocGFja2luZ0luZm8uZGlydHkgfHwgdGV4dC5fbmVlZHNTeW5jKSB7XG4gICAgICAgIHBhY2tpbmdJbmZvLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIChzeW5jUHJvbWlzZXMgfHwgKHN5bmNQcm9taXNlcyA9IFtdKSkucHVzaChuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBpZiAodGV4dC5fbmVlZHNTeW5jKSB7XG4gICAgICAgICAgICB0ZXh0LnN5bmMocmVzb2x2ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIElmIGFueSBuZWVkZWQgc3luY2luZywgd2FpdCBmb3IgdGhlbSBhbmQgdGhlbiByZXBhY2sgdGhlIGJhdGNoZWQgZ2VvbWV0cnlcbiAgICBpZiAoc3luY1Byb21pc2VzKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc3luY1N0YXJ0RXZlbnQkMSk7XG5cbiAgICAgIFByb21pc2UuYWxsKHN5bmNQcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZ2VvbWV0cnkgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGJhdGNoZWRBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICAgICAgbGV0IG1lbWJlckluZGV4ZXMgPSBiYXRjaGVkQXR0cmlidXRlc1ttZW1iZXJJbmRleEF0dHJOYW1lXSAmJiBiYXRjaGVkQXR0cmlidXRlc1ttZW1iZXJJbmRleEF0dHJOYW1lXS5hcnJheSB8fCBuZXcgVWludDE2QXJyYXkoMCk7XG4gICAgICAgIGxldCBiYXRjaGVkR2x5cGhJbmRleGVzID0gYmF0Y2hlZEF0dHJpYnV0ZXNbZ2x5cGhJbmRleEF0dHJOYW1lXSAmJiBiYXRjaGVkQXR0cmlidXRlc1tnbHlwaEluZGV4QXR0ck5hbWVdLmFycmF5IHx8IG5ldyBGbG9hdDMyQXJyYXkoMCk7XG4gICAgICAgIGxldCBiYXRjaGVkR2x5cGhCb3VuZHMgPSBiYXRjaGVkQXR0cmlidXRlc1tnbHlwaEJvdW5kc0F0dHJOYW1lXSAmJiBiYXRjaGVkQXR0cmlidXRlc1tnbHlwaEJvdW5kc0F0dHJOYW1lXS5hcnJheSB8fCBuZXcgRmxvYXQzMkFycmF5KDApO1xuXG4gICAgICAgIC8vIEluaXRpYWwgcGFzcyB0byBjb2xsZWN0IHRvdGFsIGdseXBoIGNvdW50IGFuZCByZXNpemUgdGhlIGFycmF5cyBpZiBuZWVkZWRcbiAgICAgICAgbGV0IHRvdGFsR2x5cGhDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX21lbWJlcnMuZm9yRWFjaCgocGFja2luZ0luZm8sIHsgdGV4dFJlbmRlckluZm8gfSkgPT4ge1xuICAgICAgICAgIGlmICh0ZXh0UmVuZGVySW5mbykge1xuICAgICAgICAgICAgdG90YWxHbHlwaENvdW50ICs9IHRleHRSZW5kZXJJbmZvLmdseXBoQXRsYXNJbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX3RleHRSZW5kZXJJbmZvID0gdGV4dFJlbmRlckluZm87IC8vIFRPRE8gLSBuZWVkIHRoaXMsIGJ1dCBiZSBzbWFydGVyXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRvdGFsR2x5cGhDb3VudCAhPT0gbWVtYmVySW5kZXhlcy5sZW5ndGgpIHtcbiAgICAgICAgICBtZW1iZXJJbmRleGVzID0gY2xvbmVBbmRSZXNpemUobWVtYmVySW5kZXhlcywgdG90YWxHbHlwaENvdW50KTtcbiAgICAgICAgICBiYXRjaGVkR2x5cGhJbmRleGVzID0gY2xvbmVBbmRSZXNpemUoYmF0Y2hlZEdseXBoSW5kZXhlcywgdG90YWxHbHlwaENvdW50KTtcbiAgICAgICAgICBiYXRjaGVkR2x5cGhCb3VuZHMgPSBjbG9uZUFuZFJlc2l6ZShiYXRjaGVkR2x5cGhCb3VuZHMsIHRvdGFsR2x5cGhDb3VudCAqIDQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9wdWxhdGUgYmF0Y2ggYXJyYXlzXG4gICAgICAgIGxldCBtZW1iZXJJbmRleCA9IDA7XG4gICAgICAgIGxldCBnbHlwaEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fbWVtYmVycy5mb3JFYWNoKChwYWNraW5nSW5mbywgeyB0ZXh0UmVuZGVySW5mbyB9KSA9PiB7XG4gICAgICAgICAgaWYgKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgICAgICAgICBjb25zdCBnbHlwaENvdW50ID0gdGV4dFJlbmRlckluZm8uZ2x5cGhBdGxhc0luZGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgbWVtYmVySW5kZXhlcy5maWxsKG1lbWJlckluZGV4LCBnbHlwaEluZGV4LCBnbHlwaEluZGV4ICsgZ2x5cGhDb3VudCk7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gY2FuIHNraXAgdGhlc2UgZm9yIG1lbWJlcnMgdGhhdCBhcmUgbm90IGRpcnR5IG9yIHNoaWZ0aW5nIG92ZXJhbGwgcG9zaXRpb246XG4gICAgICAgICAgICBiYXRjaGVkR2x5cGhJbmRleGVzLnNldCh0ZXh0UmVuZGVySW5mby5nbHlwaEF0bGFzSW5kaWNlcywgZ2x5cGhJbmRleCwgZ2x5cGhJbmRleCArIGdseXBoQ291bnQpO1xuICAgICAgICAgICAgYmF0Y2hlZEdseXBoQm91bmRzLnNldCh0ZXh0UmVuZGVySW5mby5nbHlwaEJvdW5kcywgZ2x5cGhJbmRleCAqIDQsIChnbHlwaEluZGV4ICsgZ2x5cGhDb3VudCkgKiA0KTtcblxuICAgICAgICAgICAgZ2x5cGhJbmRleCArPSBnbHlwaENvdW50O1xuICAgICAgICAgICAgcGFja2luZ0luZm8uaW5kZXggPSBtZW1iZXJJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBnZW9tZXRyeSBhdHRyaWJ1dGVzXG4gICAgICAgIGdlb21ldHJ5LnVwZGF0ZUF0dHJpYnV0ZURhdGEobWVtYmVySW5kZXhBdHRyTmFtZSwgbWVtYmVySW5kZXhlcywgMSk7XG4gICAgICAgIGdlb21ldHJ5LmdldEF0dHJpYnV0ZShtZW1iZXJJbmRleEF0dHJOYW1lKS5zZXRVc2FnZShEeW5hbWljRHJhd1VzYWdlKTtcbiAgICAgICAgZ2VvbWV0cnkudXBkYXRlQXR0cmlidXRlRGF0YShnbHlwaEluZGV4QXR0ck5hbWUsIGJhdGNoZWRHbHlwaEluZGV4ZXMsIDEpO1xuICAgICAgICBnZW9tZXRyeS51cGRhdGVBdHRyaWJ1dGVEYXRhKGdseXBoQm91bmRzQXR0ck5hbWUsIGJhdGNoZWRHbHlwaEJvdW5kcywgNCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc3luY0NvbXBsZXRlRXZlbnQkMSk7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvcHkgKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBCYXRjaGVkVGV4dCkge1xuICAgICAgc3VwZXIuY29weShzb3VyY2UpO1xuICAgICAgdGhpcy5fbWVtYmVycy5mb3JFYWNoKChfLCB0ZXh0KSA9PiB0aGlzLnJlbW92ZVRleHQodGV4dCkpO1xuICAgICAgc291cmNlLl9tZW1iZXJzLmZvckVhY2goKF8sIHRleHQpID0+IHRoaXMuYWRkVGV4dCh0ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGlzcG9zZSAoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5fZGF0YVRleHR1cmVzKS5mb3JFYWNoKHRleCA9PiB0ZXguZGlzcG9zZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZFJlc2l6ZSAoc291cmNlLCBuZXdMZW5ndGgpIHtcbiAgY29uc3QgY29weSA9IG5ldyBzb3VyY2UuY29uc3RydWN0b3IobmV3TGVuZ3RoKTtcbiAgY29weS5zZXQoc291cmNlLnN1YmFycmF5KDAsIG5ld0xlbmd0aCkpO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hlZFRleHRNYXRlcmlhbCAoYmFzZU1hdGVyaWFsKSB7XG4gIGNvbnN0IHRleFVuaWZvcm1OYW1lID0gXCJ1VHJvaWthTWF0cmljZXNUZXh0dXJlXCI7XG4gIGNvbnN0IHRleFNpemVVbmlmb3JtTmFtZSA9IFwidVRyb2lrYU1hdHJpY2VzVGV4dHVyZVNpemVcIjtcblxuICAvLyBEdWUgdG8gaG93IHZlcnRleFRyYW5zZm9ybSBnZXRzIGluamVjdGVkLCB0aGUgbWF0cml4IHRyYW5zZm9ybXMgbXVzdCBoYXBwZW5cbiAgLy8gaW4gdGhlIGJhc2UgbWF0ZXJpYWwgb2YgVGV4dERlcml2ZWRNYXRlcmlhbCwgYnV0IG90aGVyIHRyYW5zZm9ybXMgdG8gaXRzXG4gIC8vIHNoYWRlciBtdXN0IGNvbWUgYWZ0ZXIsIHNvIHdlIHNhbmR3aWNoIGl0IGJldHdlZW4gdHdvIGRlcml2YXRpb25zLlxuXG4gIC8vIFRyYW5zZm9ybSB0aGUgdmVydGV4IHBvc2l0aW9uXG4gIGxldCBiYXRjaE1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCwge1xuICAgIGNoYWluZWQ6IHRydWUsXG4gICAgdW5pZm9ybXM6IHtcbiAgICAgIFt0ZXhTaXplVW5pZm9ybU5hbWVdOiB7IHZhbHVlOiBuZXcgVmVjdG9yMigpIH0sXG4gICAgICBbdGV4VW5pZm9ybU5hbWVdOiB7IHZhbHVlOiBudWxsIH1cbiAgICB9LFxuICAgIC8vIGxhbmd1YWdlPUdMU0xcbiAgICB2ZXJ0ZXhEZWZzOiBgXG4gICAgICB1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCAke3RleFVuaWZvcm1OYW1lfTtcbiAgICAgIHVuaWZvcm0gdmVjMiAke3RleFNpemVVbmlmb3JtTmFtZX07XG4gICAgICBhdHRyaWJ1dGUgZmxvYXQgJHttZW1iZXJJbmRleEF0dHJOYW1lfTtcblxuICAgICAgdmVjNCB0cm9pa2FCYXRjaFRleGVsKGZsb2F0IG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgKz0gJHttZW1iZXJJbmRleEF0dHJOYW1lfSAqICR7ZmxvYXRzUGVyTWVtYmVyLnRvRml4ZWQoMSl9IC8gNC4wO1xuICAgICAgICBmbG9hdCB3ID0gJHt0ZXhTaXplVW5pZm9ybU5hbWV9Lng7XG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihtb2Qob2Zmc2V0LCB3KSwgZmxvb3Iob2Zmc2V0IC8gdykpICsgMC41KSAvICR7dGV4U2l6ZVVuaWZvcm1OYW1lfTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmUyRCgke3RleFVuaWZvcm1OYW1lfSwgdXYpO1xuICAgICAgfVxuICAgIGAsXG4gICAgLy8gbGFuZ3VhZ2U9R0xTTCBwcmVmaXg9XCJ2b2lkIG1haW4oKSB7XCIgc3VmZml4PVwifVwiXG4gICAgdmVydGV4VHJhbnNmb3JtOiBgXG4gICAgICBtYXQ0IG1hdHJpeCA9IG1hdDQoXG4gICAgICAgIHRyb2lrYUJhdGNoVGV4ZWwoMC4wKSxcbiAgICAgICAgdHJvaWthQmF0Y2hUZXhlbCgxLjApLFxuICAgICAgICB0cm9pa2FCYXRjaFRleGVsKDIuMCksXG4gICAgICAgIHRyb2lrYUJhdGNoVGV4ZWwoMy4wKVxuICAgICAgKTtcbiAgICAgIHBvc2l0aW9uLnh5eiA9IChtYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApKS54eXo7XG4gICAgYCxcbiAgfSk7XG5cbiAgLy8gQWRkIHRoZSB0ZXh0IHNoYWRlcnNcbiAgYmF0Y2hNYXRlcmlhbCA9IGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWwoYmF0Y2hNYXRlcmlhbCk7XG5cbiAgLy8gTm93IG1ha2Ugb3RoZXIgY2hhbmdlcyB0byB0aGUgZGVyaXZlZCB0ZXh0IHNoYWRlciBjb2RlXG4gIGJhdGNoTWF0ZXJpYWwgPSBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoYmF0Y2hNYXRlcmlhbCwge1xuICAgIGNoYWluZWQ6IHRydWUsXG4gICAgdW5pZm9ybXM6IHtcbiAgICAgIHVUcm9pa2FJc091dGxpbmU6IHt2YWx1ZTogZmFsc2V9LFxuICAgIH0sXG4gICAgY3VzdG9tUmV3cml0ZXIoc2hhZGVycykge1xuICAgICAgLy8gQ29udmVydCBzb21lIHRleHQgc2hhZGVyIHVuaWZvcm1zIHRvIHZhcnlpbmdzXG4gICAgICBjb25zdCB2YXJ5aW5nVW5pZm9ybXMgPSBbXG4gICAgICAgICd1VHJvaWthVG90YWxCb3VuZHMnLFxuICAgICAgICAndVRyb2lrYUNsaXBSZWN0JyxcbiAgICAgICAgJ3VUcm9pa2FQb3NpdGlvbk9mZnNldCcsXG4gICAgICAgICd1VHJvaWthRWRnZU9mZnNldCcsXG4gICAgICAgICd1VHJvaWthQmx1clJhZGl1cycsXG4gICAgICAgICd1VHJvaWthU3Ryb2tlV2lkdGgnLFxuICAgICAgICAndVRyb2lrYVN0cm9rZUNvbG9yJyxcbiAgICAgICAgJ3VUcm9pa2FTdHJva2VPcGFjaXR5JyxcbiAgICAgICAgJ3VUcm9pa2FGaWxsT3BhY2l0eScsXG4gICAgICAgICd1VHJvaWthQ3VydmVSYWRpdXMnLFxuICAgICAgICAnZGlmZnVzZSdcbiAgICAgIF07XG4gICAgICB2YXJ5aW5nVW5pZm9ybXMuZm9yRWFjaCh1bmlmb3JtTmFtZSA9PiB7XG4gICAgICAgIHNoYWRlcnMgPSB1bmlmb3JtVG9WYXJ5aW5nKHNoYWRlcnMsIHVuaWZvcm1OYW1lKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNoYWRlcnNcbiAgICB9LFxuICAgIC8vIGxhbmd1YWdlPUdMU0xcbiAgICB2ZXJ0ZXhEZWZzOiBgXG4gICAgICB1bmlmb3JtIGJvb2wgdVRyb2lrYUlzT3V0bGluZTtcbiAgICAgIHZlYzMgdHJvaWthRmxvYXRUb0NvbG9yKGZsb2F0IHYpIHtcbiAgICAgICAgcmV0dXJuIG1vZChmbG9vcih2ZWMzKHYgLyA2NTUzNi4wLCB2IC8gMjU2LjAsIHYpKSwgMjU2LjApIC8gMjU2LjA7XG4gICAgICB9XG4gICAgYCxcbiAgICAvLyBsYW5ndWFnZT1HTFNMIHByZWZpeD1cInZvaWQgbWFpbigpIHtcIiBzdWZmaXg9XCJ9XCJcbiAgICB2ZXJ0ZXhUcmFuc2Zvcm06IGBcbiAgICAgIHVUcm9pa2FUb3RhbEJvdW5kcyA9IHRyb2lrYUJhdGNoVGV4ZWwoNC4wKTtcbiAgICAgIHVUcm9pa2FDbGlwUmVjdCA9IHRyb2lrYUJhdGNoVGV4ZWwoNS4wKTtcbiAgICAgIFxuICAgICAgdmVjNCBkYXRhID0gdHJvaWthQmF0Y2hUZXhlbCg2LjApO1xuICAgICAgZGlmZnVzZSA9IHRyb2lrYUZsb2F0VG9Db2xvcihkYXRhLngpO1xuICAgICAgdVRyb2lrYUZpbGxPcGFjaXR5ID0gZGF0YS55O1xuICAgICAgdVRyb2lrYUN1cnZlUmFkaXVzID0gZGF0YS56O1xuICAgICAgXG4gICAgICBkYXRhID0gdHJvaWthQmF0Y2hUZXhlbCg3LjApO1xuICAgICAgaWYgKHVUcm9pa2FJc091dGxpbmUpIHtcbiAgICAgICAgaWYgKGRhdGEgPT0gdmVjNCgwLjApKSB7IC8vIGRlZ2VuZXJhdGUgaWYgemVybyBvdXRsaW5lXG4gICAgICAgICAgcG9zaXRpb24gPSB2ZWMzKDAuMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdVRyb2lrYVBvc2l0aW9uT2Zmc2V0ID0gZGF0YS54eTtcbiAgICAgICAgICB1VHJvaWthRWRnZU9mZnNldCA9IGRhdGEuejtcbiAgICAgICAgICB1VHJvaWthQmx1clJhZGl1cyA9IGRhdGEudztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdVRyb2lrYVN0cm9rZVdpZHRoID0gZGF0YS54O1xuICAgICAgICB1VHJvaWthU3Ryb2tlQ29sb3IgPSB0cm9pa2FGbG9hdFRvQ29sb3IoZGF0YS55KTtcbiAgICAgICAgdVRyb2lrYVN0cm9rZU9wYWNpdHkgPSBkYXRhLno7XG4gICAgICB9XG4gICAgYCxcbiAgfSk7XG5cbiAgYmF0Y2hNYXRlcmlhbC5zZXRNYXRyaXhUZXh0dXJlID0gKHRleHR1cmUpID0+IHtcbiAgICBiYXRjaE1hdGVyaWFsLnVuaWZvcm1zW3RleFVuaWZvcm1OYW1lXS52YWx1ZSA9IHRleHR1cmU7XG4gICAgYmF0Y2hNYXRlcmlhbC51bmlmb3Jtc1t0ZXhTaXplVW5pZm9ybU5hbWVdLnZhbHVlLnNldCh0ZXh0dXJlLmltYWdlLndpZHRoLCB0ZXh0dXJlLmltYWdlLmhlaWdodCk7XG4gIH07XG4gIHJldHVybiBiYXRjaE1hdGVyaWFsO1xufVxuXG4vKipcbiAqIFR1cm4gYSB1bmlmb3JtIGludG8gYSB2YXJ5aW5nL3dyaXRlYWJsZSB2YWx1ZS5cbiAqIC0gSWYgdGhlIHVuaWZvcm0gd2FzIHVzZWQgaW4gdGhlIGZyYWdtZW50IHNoYWRlciwgaXQgd2lsbCBiZWNvbWUgYSB2YXJ5aW5nIGluIGJvdGggc2hhZGVycy5cbiAqIC0gSWYgdGhlIHVuaWZvcm0gd2FzIG9ubHkgdXNlZCBpbiB0aGUgdmVydGV4IHNoYWRlciwgaXQgd2lsbCBiZWNvbWUgYSB3cml0ZWFibGUgdmFyLlxuICovXG5mdW5jdGlvbiB1bmlmb3JtVG9WYXJ5aW5nKHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSwgdW5pZm9ybU5hbWUsIHZhcnlpbmdOYW1lID0gdW5pZm9ybU5hbWUpIHtcbiAgY29uc3QgdW5pZm9ybVJFID0gbmV3IFJlZ0V4cChgdW5pZm9ybVxcXFxzKyhib29sfGZsb2F0fHZlY1syMzRdfG1hdFszNF0pXFxcXHMrJHt1bmlmb3JtTmFtZX1cXFxcYmApO1xuXG4gIGxldCB0eXBlO1xuICBsZXQgaGFkRnJhZ21lbnRVbmlmb3JtID0gZmFsc2U7XG4gIGZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXIucmVwbGFjZSh1bmlmb3JtUkUsICgkMCwgJDEpID0+IHtcbiAgICBoYWRGcmFnbWVudFVuaWZvcm0gPSB0cnVlO1xuICAgIHJldHVybiBgdmFyeWluZyAke3R5cGUgPSAkMX0gJHt2YXJ5aW5nTmFtZX1gXG4gIH0pO1xuXG4gIGxldCBoYWRWZXJ0ZXhVbmlmb3JtID0gZmFsc2U7XG4gIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKHVuaWZvcm1SRSwgKF8sICQxKSA9PiB7XG4gICAgaGFkVmVydGV4VW5pZm9ybSA9IHRydWU7XG4gICAgcmV0dXJuIGAke2hhZEZyYWdtZW50VW5pZm9ybSA/ICd2YXJ5aW5nJyA6ICcnfSAke3R5cGUgPSAkMX0gJHt2YXJ5aW5nTmFtZX1gXG4gIH0pO1xuICBpZiAoIWhhZFZlcnRleFVuaWZvcm0pIHtcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBgJHtoYWRGcmFnbWVudFVuaWZvcm0gPyAndmFyeWluZycgOiAnJ30gJHt0eXBlfSAke3ZhcnlpbmdOYW1lfTtcXG4ke3ZlcnRleFNoYWRlcn1gO1xuICB9XG4gIHJldHVybiB7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn1cbn1cblxuLy89PT0gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBjYXJldHMgYW5kIHNlbGVjdGlvbiByYW5nZXMgPT09Ly9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUZXh0Q2FyZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0geCBwb3NpdGlvbiBvZiB0aGUgY2FyZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0geSBwb3NpdGlvbiBvZiB0aGUgY2FyZXQncyBib3R0b21cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBoZWlnaHQgb2YgdGhlIGNhcmV0XG4gKiBAcHJvcGVydHkge251bWJlcn0gY2hhckluZGV4IC0gdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmcgb2YgdGhpcyBjYXJldCdzIHRhcmdldFxuICogICBjaGFyYWN0ZXI7IHRoZSBjYXJldCB3aWxsIGJlIGZvciB0aGUgcG9zaXRpb24gX2JlZm9yZV8gdGhhdCBjaGFyYWN0ZXIuXG4gKi9cblxuLyoqXG4gKiBHaXZlbiBhIGxvY2FsIHgveSBjb29yZGluYXRlIGluIHRoZSB0ZXh0IGJsb2NrIHBsYW5lLCBmaW5kIHRoZSBuZWFyZXN0IGNhcmV0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm8gLSBhIHJlc3VsdCBvYmplY3QgZnJvbSBUZXh0QnVpbGRlciNnZXRUZXh0UmVuZGVySW5mb1xuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtUZXh0Q2FyZXQgfCBudWxsfVxuICovXG5mdW5jdGlvbiBnZXRDYXJldEF0UG9pbnQodGV4dFJlbmRlckluZm8sIHgsIHkpIHtcbiAgbGV0IGNsb3Nlc3RDYXJldCA9IG51bGw7XG4gIGNvbnN0IHJvd3MgPSBncm91cENhcmV0c0J5Um93KHRleHRSZW5kZXJJbmZvKTtcblxuICAvLyBGaW5kIG5lYXJlc3Qgcm93IGJ5IHkgZmlyc3RcbiAgbGV0IGNsb3Nlc3RSb3cgPSBudWxsO1xuICByb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBpZiAoIWNsb3Nlc3RSb3cgfHwgTWF0aC5hYnMoeSAtIChyb3cudG9wICsgcm93LmJvdHRvbSkgLyAyKSA8IE1hdGguYWJzKHkgLSAoY2xvc2VzdFJvdy50b3AgKyBjbG9zZXN0Um93LmJvdHRvbSkgLyAyKSkge1xuICAgICAgY2xvc2VzdFJvdyA9IHJvdztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRoZW4gZmluZCBjbG9zZXN0IGNhcmV0IGJ5IHggd2l0aGluIHRoYXQgcm93XG4gIGNsb3Nlc3RSb3cuY2FyZXRzLmZvckVhY2goY2FyZXQgPT4ge1xuICAgIGlmICghY2xvc2VzdENhcmV0IHx8IE1hdGguYWJzKHggLSBjYXJldC54KSA8IE1hdGguYWJzKHggLSBjbG9zZXN0Q2FyZXQueCkpIHtcbiAgICAgIGNsb3Nlc3RDYXJldCA9IGNhcmV0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjbG9zZXN0Q2FyZXRcbn1cblxuXG5jb25zdCBfcmVjdHNDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogR2l2ZW4gc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXIgaW5kZXhlcywgcmV0dXJuIGEgbGlzdCBvZiByZWN0YW5nbGVzIGNvdmVyaW5nIGFsbCB0aGVcbiAqIGNoYXJhY3RlcnMgd2l0aGluIHRoYXQgc2VsZWN0aW9uLlxuICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm9cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyIGluIHRoZSBzZWxlY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgLSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhciBhZnRlciB0aGUgc2VsZWN0aW9uXG4gKiBAcmV0dXJuIHtBcnJheTx7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfT4gfCBudWxsfVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25SZWN0cyh0ZXh0UmVuZGVySW5mbywgc3RhcnQsIGVuZCkge1xuICBsZXQgcmVjdHM7XG4gIGlmICh0ZXh0UmVuZGVySW5mbykge1xuICAgIC8vIENoZWNrIGNhY2hlIC0gdGV4dFJlbmRlckluZm8gaXMgZnJvemVuIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSBiYXNlZCBvbiBpdFxuICAgIGxldCBwcmV2UmVzdWx0ID0gX3JlY3RzQ2FjaGUuZ2V0KHRleHRSZW5kZXJJbmZvKTtcbiAgICBpZiAocHJldlJlc3VsdCAmJiBwcmV2UmVzdWx0LnN0YXJ0ID09PSBzdGFydCAmJiBwcmV2UmVzdWx0LmVuZCA9PT0gZW5kKSB7XG4gICAgICByZXR1cm4gcHJldlJlc3VsdC5yZWN0c1xuICAgIH1cblxuICAgIGNvbnN0IHtjYXJldFBvc2l0aW9uc30gPSB0ZXh0UmVuZGVySW5mbztcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgY29uc3QgcyA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICBlbmQgPSBzO1xuICAgIH1cbiAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGNhcmV0UG9zaXRpb25zLmxlbmd0aCArIDEpO1xuXG4gICAgLy8gQnVpbGQgbGlzdCBvZiByZWN0cywgZXhwYW5kaW5nIHRoZSBjdXJyZW50IHJlY3QgZm9yIGFsbCBjaGFyYWN0ZXJzIGluIGEgcnVuIGFuZCBzdGFydGluZ1xuICAgIC8vIGEgbmV3IHJlY3Qgd2hlbmV2ZXIgcmVhY2hpbmcgYSBuZXcgbGluZSBvciBhIG5ldyBiaWRpIGRpcmVjdGlvblxuICAgIHJlY3RzID0gW107XG4gICAgbGV0IGN1cnJlbnRSZWN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgeDEgPSBjYXJldFBvc2l0aW9uc1tpICogNF07XG4gICAgICBjb25zdCB4MiA9IGNhcmV0UG9zaXRpb25zW2kgKiA0ICsgMV07XG4gICAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oeDEsIHgyKTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoeDEsIHgyKTtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IGNhcmV0UG9zaXRpb25zW2kgKiA0ICsgMl07XG4gICAgICBjb25zdCB0b3AgPSBjYXJldFBvc2l0aW9uc1tpICogNCArIDNdO1xuICAgICAgaWYgKCFjdXJyZW50UmVjdCB8fCBib3R0b20gIT09IGN1cnJlbnRSZWN0LmJvdHRvbSB8fCB0b3AgIT09IGN1cnJlbnRSZWN0LnRvcCB8fCBsZWZ0ID4gY3VycmVudFJlY3QucmlnaHQgfHwgcmlnaHQgPCBjdXJyZW50UmVjdC5sZWZ0KSB7XG4gICAgICAgIGN1cnJlbnRSZWN0ID0ge1xuICAgICAgICAgIGxlZnQ6IEluZmluaXR5LFxuICAgICAgICAgIHJpZ2h0OiAtSW5maW5pdHksXG4gICAgICAgICAgYm90dG9tLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVjdHMucHVzaChjdXJyZW50UmVjdCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50UmVjdC5sZWZ0ID0gTWF0aC5taW4obGVmdCwgY3VycmVudFJlY3QubGVmdCk7XG4gICAgICBjdXJyZW50UmVjdC5yaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBjdXJyZW50UmVjdC5yaWdodCk7XG4gICAgfVxuXG4gICAgLy8gTWVyZ2UgYW55IG92ZXJsYXBwaW5nIHJlY3RzLCBlLmcuIHRob3NlIGZvcm1lZCBieSBhZGphY2VudCBiaWRpIHJ1bnNcbiAgICByZWN0cy5zb3J0KChhLCBiKSA9PiBiLmJvdHRvbSAtIGEuYm90dG9tIHx8IGEubGVmdCAtIGIubGVmdCk7XG4gICAgZm9yIChsZXQgaSA9IHJlY3RzLmxlbmd0aCAtIDE7IGktLSA+IDA7KSB7XG4gICAgICBjb25zdCByZWN0QSA9IHJlY3RzW2ldO1xuICAgICAgY29uc3QgcmVjdEIgPSByZWN0c1tpICsgMV07XG4gICAgICBpZiAocmVjdEEuYm90dG9tID09PSByZWN0Qi5ib3R0b20gJiYgcmVjdEEudG9wID09PSByZWN0Qi50b3AgJiYgcmVjdEEubGVmdCA8PSByZWN0Qi5yaWdodCAmJiByZWN0QS5yaWdodCA+PSByZWN0Qi5sZWZ0KSB7XG4gICAgICAgIHJlY3RCLmxlZnQgPSBNYXRoLm1pbihyZWN0Qi5sZWZ0LCByZWN0QS5sZWZ0KTtcbiAgICAgICAgcmVjdEIucmlnaHQgPSBNYXRoLm1heChyZWN0Qi5yaWdodCwgcmVjdEEucmlnaHQpO1xuICAgICAgICByZWN0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3JlY3RzQ2FjaGUuc2V0KHRleHRSZW5kZXJJbmZvLCB7c3RhcnQsIGVuZCwgcmVjdHN9KTtcbiAgfVxuICByZXR1cm4gcmVjdHNcbn1cblxuY29uc3QgX2NhcmV0c0J5Um93Q2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIEdyb3VwIGEgc2V0IG9mIGNhcmV0cyBieSByb3cgb2YgdGV4dCwgY2FjaGluZyB0aGUgcmVzdWx0LiBBIHNpbmdsZSByb3cgb2YgdGV4dCBtYXkgY29udGFpbiBjYXJldHMgb2ZcbiAqIGRpZmZlcmluZyBwb3NpdGlvbnMvaGVpZ2h0cyBpZiBpdCBoYXMgbXVsdGlwbGUgZm9udHMsIGFuZCB0aGV5IG1heSBvdmVybGFwIHNsaWdodGx5IGFjcm9zcyByb3dzLCBzbyB0aGlzXG4gKiB1c2VzIGFuIGFzc3VtcHRpb24gb2YgXCJhdCBsZWFzdCBvdmVybGFwcGluZyBieSBoYWxmXCIgdG8gcHV0IHRoZW0gaW4gdGhlIHNhbWUgcm93LlxuICogQHJldHVybiBBcnJheTx7Ym90dG9tOiBudW1iZXIsIHRvcDogbnVtYmVyLCBjYXJldHM6IFRleHRDYXJldFtdfT5cbiAqL1xuZnVuY3Rpb24gZ3JvdXBDYXJldHNCeVJvdyh0ZXh0UmVuZGVySW5mbykge1xuICAvLyB0ZXh0UmVuZGVySW5mbyBpcyBmcm96ZW4gc28gaXQncyBzYWZlIHRvIGNhY2hlIGJhc2VkIG9uIGl0XG4gIGxldCByb3dzID0gX2NhcmV0c0J5Um93Q2FjaGUuZ2V0KHRleHRSZW5kZXJJbmZvKTtcbiAgaWYgKCFyb3dzKSB7XG4gICAgcm93cyA9IFtdO1xuICAgIGNvbnN0IHtjYXJldFBvc2l0aW9uc30gPSB0ZXh0UmVuZGVySW5mbztcbiAgICBsZXQgY3VyUm93O1xuXG4gICAgY29uc3QgdmlzaXRDYXJldCA9ICh4LCBib3R0b20sIHRvcCwgY2hhckluZGV4KSA9PiB7XG4gICAgICAvLyBuZXcgcm93IGlmIG5vdCBvdmVybGFwcGluZyBieSBhdCBsZWFzdCBoYWxmXG4gICAgICBpZiAoIWN1clJvdyB8fCAodG9wIDwgKGN1clJvdy50b3AgKyBjdXJSb3cuYm90dG9tKSAvIDIpKSB7XG4gICAgICAgIHJvd3MucHVzaChjdXJSb3cgPSB7Ym90dG9tLCB0b3AsIGNhcmV0czogW119KTtcbiAgICAgIH1cbiAgICAgIC8vIGV4cGFuZCB2ZXJ0aWNhbCBsaW1pdHMgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAodG9wID4gY3VyUm93LnRvcCkgY3VyUm93LnRvcCA9IHRvcDtcbiAgICAgIGlmIChib3R0b20gPCBjdXJSb3cuYm90dG9tKSBjdXJSb3cuYm90dG9tID0gYm90dG9tO1xuICAgICAgY3VyUm93LmNhcmV0cy5wdXNoKHtcbiAgICAgICAgeCxcbiAgICAgICAgeTogYm90dG9tLFxuICAgICAgICBoZWlnaHQ6IHRvcCAtIGJvdHRvbSxcbiAgICAgICAgY2hhckluZGV4LFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGNhcmV0UG9zaXRpb25zLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICB2aXNpdENhcmV0KGNhcmV0UG9zaXRpb25zW2ldLCBjYXJldFBvc2l0aW9uc1tpICsgMl0sIGNhcmV0UG9zaXRpb25zW2kgKyAzXSwgaSAvIDQpO1xuICAgIH1cbiAgICAvLyBBZGQgb25lIG1vcmUgY2FyZXQgYWZ0ZXIgdGhlIGZpbmFsIGNoYXJcbiAgICB2aXNpdENhcmV0KGNhcmV0UG9zaXRpb25zW2kgLSAzXSwgY2FyZXRQb3NpdGlvbnNbaSAtIDJdLCBjYXJldFBvc2l0aW9uc1tpIC0gMV0sIGkgLyA0KTtcbiAgfVxuICBfY2FyZXRzQnlSb3dDYWNoZS5zZXQodGV4dFJlbmRlckluZm8sIHJvd3MpO1xuICByZXR1cm4gcm93c1xufVxuXG5leHBvcnQgeyBCYXRjaGVkVGV4dCwgR2x5cGhzR2VvbWV0cnksIFRleHQsIGNvbmZpZ3VyZVRleHRCdWlsZGVyLCBjcmVhdGVUZXh0RGVyaXZlZE1hdGVyaWFsLCBkdW1wU0RGVGV4dHVyZXMsIGZvbnRSZXNvbHZlcldvcmtlck1vZHVsZSwgZ2V0Q2FyZXRBdFBvaW50LCBnZXRTZWxlY3Rpb25SZWN0cywgZ2V0VGV4dFJlbmRlckluZm8sIHByZWxvYWRGb250LCB0eXBlc2V0dGVyV29ya2VyTW9kdWxlIH07XG4iXSwibmFtZXMiOlsiVGV4dHVyZSIsIkxpbmVhckZpbHRlciIsIkNvbG9yIiwiSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkiLCJTcGhlcmUiLCJCb3gzIiwiSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIiwiUGxhbmVHZW9tZXRyeSIsIlZlY3RvcjIiLCJWZWN0b3I0IiwiTWF0cml4MyIsIk1lc2giLCJNZXNoQmFzaWNNYXRlcmlhbCIsIkRvdWJsZVNpZGUiLCJNYXRyaXg0IiwiVmVjdG9yMyIsIkRhdGFUZXh0dXJlIiwiUkdCQUZvcm1hdCIsIkZsb2F0VHlwZSIsIkR5bmFtaWNEcmF3VXNhZ2UiLCJkZWZpbmVXb3JrZXJNb2R1bGUiLCJ0ZXJtaW5hdGVXb3JrZXIiLCJjcmVhdGVTREZHZW5lcmF0b3IiLCJiaWRpRmFjdG9yeSIsImNyZWF0ZURlcml2ZWRNYXRlcmlhbCIsInZvaWRNYWluUmVnRXhwIiwidHlwckZhY3RvcnkiLCJzZWxmIiwid2luZG93IiwiciIsImUiLCJwYXJzZSIsInQiLCJfYmluIiwiYSIsIlVpbnQ4QXJyYXkiLCJyZWFkQVNDSUkiLCJuIiwicmVhZFVzaG9ydCIsIm8iLCJyZWFkVWludCIsInMiLCJpIiwiaCIsInB1c2giLCJfcmVhZEZvbnQiLCJyZWFkRml4ZWQiLCJfZGF0YSIsIl9vZmZzZXQiLCJkIiwiZiIsInUiLCJsIiwib2Zmc2V0IiwibGVuZ3RoIiwidiIsInRyaW0iLCJfdGFiT2Zmc2V0IiwicmVhZEYyZG90MTQiLCJyZWFkU2hvcnQiLCJyZWFkSW50IiwiX3ZpZXciLCJnZXRJbnQzMiIsInJlYWRJbnQ4IiwiZ2V0SW50OCIsImdldEludDE2IiwiZ2V0VWludDE2IiwicmVhZFVzaG9ydHMiLCJnZXRVaW50MzIiLCJyZWFkVWludDY0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwicmVhZFVuaWNvZGUiLCJfdGRlYyIsIlRleHREZWNvZGVyIiwicmVhZFVURjgiLCJkZWNvZGUiLCJyZWFkQnl0ZXMiLCJyZWFkQVNDSUlBcnJheSIsIl9kYXRhVmlldyIsImJ1ZmZlciIsIkRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJfbGN0ZiIsInNjcmlwdExpc3QiLCJyZWFkU2NyaXB0TGlzdCIsImZlYXR1cmVMaXN0IiwicmVhZEZlYXR1cmVMaXN0IiwibG9va3VwTGlzdCIsInJlYWRMb29rdXBMaXN0IiwicmVhZExvb2t1cFRhYmxlIiwidGFicyIsImx0eXBlIiwiZmxhZyIsIm51bU9mT25lcyIsInJlYWRDbGFzc0RlZiIsImdldEludGVydmFsIiwicmVhZENvdmVyYWdlIiwiZm10IiwidGFiIiwiY292ZXJhZ2VJbmRleCIsImluZGV4T2YiLCJyZWFkRmVhdHVyZVRhYmxlIiwidGFnIiwiZmVhdHVyZVBhcmFtcyIsInJlYWRTY3JpcHRUYWJsZSIsImRlZmF1bHQiLCJyZWFkTGFuZ1N5c1RhYmxlIiwicmVxRmVhdHVyZSIsImZlYXR1cmVzIiwiQ0ZGIiwicmVhZEluZGV4IiwicmVhZERpY3QiLCJyZWFkU3VicnMiLCJDaGFyU3RyaW5ncyIsIlJPUyIsIkZEQXJyYXkiLCJjIiwicCIsIl9yZWFkRkRpY3QiLCJGRFNlbGVjdCIsIlUiLCJnIiwiRW5jb2RpbmciLCJyZWFkRW5jb2RpbmciLCJjaGFyc2V0IiwicmVhZENoYXJzZXQiLCJQcml2YXRlIiwiU3VicnMiLCJCaWFzIiwidGFibGVTRSIsImdseXBoQnlVbmljb2RlIiwiZ2x5cGhCeVNFIiwiZ2V0Q2hhclN0cmluZyIsInZhbCIsInNpemUiLCJyZWFkQ2hhclN0cmluZyIsIlMiLCJwYXJzZUZsb2F0IiwiY21hcCIsInRhYmxlcyIsInBhcnNlMCIsInBhcnNlNCIsInBhcnNlNiIsInBhcnNlMTIiLCJjb25zb2xlIiwiZGVidWciLCJmb3JtYXQiLCJtYXAiLCJzZWFyY2hSYW5nZSIsImVudHJ5U2VsZWN0b3IiLCJyYW5nZVNoaWZ0IiwiZW5kQ291bnQiLCJzdGFydENvdW50IiwiaWREZWx0YSIsImlkUmFuZ2VPZmZzZXQiLCJnbHlwaElkQXJyYXkiLCJmaXJzdENvZGUiLCJncm91cHMiLCJnbHlmIiwibWF4cCIsIm51bUdseXBocyIsIl9wYXJzZUdseWYiLCJsb2NhIiwibm9jIiwieE1pbiIsInlNaW4iLCJ4TWF4IiwieU1heCIsImVuZFB0cyIsImluc3RydWN0aW9ucyIsImZsYWdzIiwieHMiLCJ5cyIsInBhcnRzIiwibSIsImIiLCJ0eCIsInR5IiwicDEiLCJwMiIsImdseXBoSW5kZXgiLCJ5IiwiaW5zdHIiLCJHREVGIiwiZ2x5cGhDbGFzc0RlZiIsIkdQT1MiLCJzdWJ0IiwiY292ZXJhZ2UiLCJwb3MiLCJyZWFkVmFsdWVSZWNvcmQiLCJwYWlyc2V0cyIsIlAiLCJ4IiwiZ2lkMiIsInZhbDEiLCJ2YWwyIiwiRiIsIkMiLCJjbGFzc0RlZjEiLCJjbGFzc0RlZjIiLCJtYXRyaXgiLCJfIiwibWFya0NvdmVyYWdlIiwiYmFzZUNvdmVyYWdlIiwibWFya0NsYXNzQ291bnQiLCJtYXJrQXJyYXkiLCJyZWFkTWFya0FycmF5IiwiYmFzZUFycmF5IiwicmVhZEJhc2VBcnJheSIsIm1hcmsxQ292ZXJhZ2UiLCJtYXJrMkNvdmVyYWdlIiwibWFyazFBcnJheSIsIm1hcmsyQXJyYXkiLCJJIiwidyIsInJlYWRBbmNob3JSZWNvcmQiLCJtYXJrQ2xhc3MiLCJHU1VCIiwiZGVsdGEiLCJuZXdnIiwic2VxcyIsInZhbHMiLCJyZWFkTGlnYXR1cmVTZXQiLCJjRGVmIiwic2NzZXQiLCJyZWFkU3ViQ2xhc3NTZXQiLCJiYWNrQ3ZnIiwiaW5wdEN2ZyIsImFoZWRDdmciLCJsb29rdXBSZWMiLCJyZWFkU3Vic3RMb29rdXBSZWNvcmRzIiwicmVhZFN1YkNsYXNzUnVsZSIsImlucHV0Iiwic3Vic3RMb29rdXBSZWNvcmRzIiwicmVhZENoYWluU3ViQ2xhc3NTZXQiLCJyZWFkQ2hhaW5TdWJDbGFzc1J1bGUiLCJzdWJzdCIsInJlYWRMaWdhdHVyZSIsImNoYWluIiwibmdseXBoIiwiaGVhZCIsImZvbnRSZXZpc2lvbiIsInVuaXRzUGVyRW0iLCJjcmVhdGVkIiwibW9kaWZpZWQiLCJtYWNTdHlsZSIsImxvd2VzdFJlY1BQRU0iLCJmb250RGlyZWN0aW9uSGludCIsImluZGV4VG9Mb2NGb3JtYXQiLCJnbHlwaERhdGFGb3JtYXQiLCJoaGVhIiwiYXNjZW5kZXIiLCJkZXNjZW5kZXIiLCJsaW5lR2FwIiwiYWR2YW5jZVdpZHRoTWF4IiwibWluTGVmdFNpZGVCZWFyaW5nIiwibWluUmlnaHRTaWRlQmVhcmluZyIsInhNYXhFeHRlbnQiLCJjYXJldFNsb3BlUmlzZSIsImNhcmV0U2xvcGVSdW4iLCJjYXJldE9mZnNldCIsIm1ldHJpY0RhdGFGb3JtYXQiLCJudW1iZXJPZkhNZXRyaWNzIiwiaG10eCIsImFXaWR0aCIsImxzQmVhcmluZyIsImtlcm4iLCJwYXJzZVYxIiwiZ2x5cGgxIiwicnZhbCIsInJlYWRGb3JtYXQwIiwiZ2x5cGgyIiwibWF4UG9pbnRzIiwibWF4Q29udG91cnMiLCJtYXhDb21wb3NpdGVQb2ludHMiLCJtYXhDb21wb3NpdGVDb250b3VycyIsIm1heFpvbmVzIiwibWF4VHdpbGlnaHRQb2ludHMiLCJtYXhTdG9yYWdlIiwibWF4RnVuY3Rpb25EZWZzIiwibWF4SW5zdHJ1Y3Rpb25EZWZzIiwibWF4U3RhY2tFbGVtZW50cyIsIm1heFNpemVPZkluc3RydWN0aW9ucyIsIm1heENvbXBvbmVudEVsZW1lbnRzIiwibWF4Q29tcG9uZW50RGVwdGgiLCJuYW1lIiwidG9TdHJpbmciLCJfbGFuZyIsInBvc3RTY3JpcHROYW1lIiwidmVyc2lvbjAiLCJ2ZXJzaW9uMSIsInZlcnNpb24yIiwidmVyc2lvbjUiLCJ4QXZnQ2hhcldpZHRoIiwidXNXZWlnaHRDbGFzcyIsInVzV2lkdGhDbGFzcyIsImZzVHlwZSIsInlTdWJzY3JpcHRYU2l6ZSIsInlTdWJzY3JpcHRZU2l6ZSIsInlTdWJzY3JpcHRYT2Zmc2V0IiwieVN1YnNjcmlwdFlPZmZzZXQiLCJ5U3VwZXJzY3JpcHRYU2l6ZSIsInlTdXBlcnNjcmlwdFlTaXplIiwieVN1cGVyc2NyaXB0WE9mZnNldCIsInlTdXBlcnNjcmlwdFlPZmZzZXQiLCJ5U3RyaWtlb3V0U2l6ZSIsInlTdHJpa2VvdXRQb3NpdGlvbiIsInNGYW1pbHlDbGFzcyIsInBhbm9zZSIsInVsVW5pY29kZVJhbmdlMSIsInVsVW5pY29kZVJhbmdlMiIsInVsVW5pY29kZVJhbmdlMyIsInVsVW5pY29kZVJhbmdlNCIsImFjaFZlbmRJRCIsImZzU2VsZWN0aW9uIiwidXNGaXJzdENoYXJJbmRleCIsInVzTGFzdENoYXJJbmRleCIsInNUeXBvQXNjZW5kZXIiLCJzVHlwb0Rlc2NlbmRlciIsInNUeXBvTGluZUdhcCIsInVzV2luQXNjZW50IiwidXNXaW5EZXNjZW50IiwidWxDb2RlUGFnZVJhbmdlMSIsInVsQ29kZVBhZ2VSYW5nZTIiLCJzeEhlaWdodCIsInNDYXBIZWlnaHQiLCJ1c0RlZmF1bHQiLCJ1c0JyZWFrIiwidXNNYXhDb250ZXh0IiwidXNMb3dlck9wdGljYWxQb2ludFNpemUiLCJ1c1VwcGVyT3B0aWNhbFBvaW50U2l6ZSIsInBvc3QiLCJ2ZXJzaW9uIiwiaXRhbGljQW5nbGUiLCJ1bmRlcmxpbmVQb3NpdGlvbiIsInVuZGVybGluZVRoaWNrbmVzcyIsImNvZGVUb0dseXBoIiwicDBlNCIsInAzZTEiLCJwMWUwIiwicDBlMyIsImdseXBoVG9QYXRoIiwiY21kcyIsImNyZHMiLCJTVkciLCJlbnRyaWVzIiwidG9QYXRoIiwic3RhY2siLCJuU3RlbXMiLCJoYXZlV2lkdGgiLCJ3aWR0aCIsImRlZmF1bHRXaWR0aFgiLCJvcGVuIiwiX2RyYXdDRkYiLCJfZHJhd0dseWYiLCJfc2ltcGxlR2x5cGgiLCJfY29tcG9HbHlwaCIsIm1vdmVUbyIsImxpbmVUbyIsInFjdXJ2ZVRvIiwiY2xvc2VQYXRoIiwiX2dldEdseXBoQ2xhc3MiLCJfYXBwbHlTdWJzIiwiX2dsc0NvdmVyZWQiLCJnbHlwaHNUb1BhdGgiLCJnZXRQYWlyQWRqdXN0bWVudCIsImN1cnZlVG8iLCJzaGlmdCIsIm5vbWluYWxXaWR0aFgiLCJwb3AiLCJrIiwiRyIsIk1hdGgiLCJhYnMiLCJPIiwiVCIsIkQiLCJCIiwiQSIsIlIiLCJMIiwiVyIsIk0iLCJWIiwiRSIsImNoYXJBdCIsIlR5cHIiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwid29mZjJvdGZGYWN0b3J5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIkVycm9yIiwiY29kZSIsImNhcHR1cmVTdGFja1RyYWNlIiwibWF4Iiwic2V0Iiwic3ViYXJyYXkiLCJqIiwieiIsInEiLCJIIiwiSiIsIksiLCJOIiwiUSIsIlgiLCJZIiwiWiIsIiQiLCJyciIsImVyIiwibnIiLCJ0ciIsInN0cmVhbSIsImNvbnZlcnRfc3RyZWFtcyIsInNldFVpbnQxNiIsInNldFVpbnQzMiIsInNpZ25hdHVyZSIsImZsYXZvciIsIm51bVRhYmxlcyIsInJlc2VydmVkIiwidG90YWxTZm50U2l6ZSIsIm1ham9yVmVyc2lvbiIsIm1pbm9yVmVyc2lvbiIsIm1ldGFPZmZzZXQiLCJtZXRhTGVuZ3RoIiwibWV0YU9yaWdMZW5ndGgiLCJwcml2T2Zmc2V0IiwicHJpdkxlbmd0aCIsInBvdyIsImNvbXBMZW5ndGgiLCJvcmlnTGVuZ3RoIiwib3JpZ0NoZWNrc3VtIiwicmVkdWNlIiwiZm9yRWFjaCIsIm91dE9mZnNldCIsInNsaWNlIiwicGFyc2VyRmFjdG9yeSIsIndvZmYyb3RmIiwiY21kQXJnTGVuZ3RocyIsImpvaW5pbmdUeXBlUmF3RGF0YSIsIkpUX0xFRlQiLCJKVF9SSUdIVCIsIkpUX0RVQUwiLCJKVF9UUkFOU1BBUkVOVCIsIkpUX0pPSU5fQ0FVU0lORyIsIkpUX05PTl9KT0lOSU5HIiwiam9pbmluZ1R5cGVNYXAiLCJnZXRDaGFySm9pbmluZ1R5cGUiLCJjaCIsIk1hcCIsInR5cGUiLCJsYXN0Q29kZSIsInNwbGl0IiwicmFuZ2UiLCJza2lwIiwic3RlcCIsInBhcnNlSW50IiwiZ2V0IiwiSVNPTCIsIklOSVQiLCJGSU5BIiwiTUVESSIsImZvcm1zVG9GZWF0dXJlcyIsImRldGVjdEpvaW5pbmdGb3JtcyIsInN0ciIsImpvaW5pbmdGb3JtcyIsInByZXZKb2luaW5nVHlwZSIsInByZXZGb3JtIiwicHJldkluZGV4IiwiY29kZVBvaW50QXQiLCJqb2luaW5nVHlwZSIsImZvcm0iLCJzdHJpbmdUb0dseXBocyIsImZvbnQiLCJnbHlwaElkcyIsImNjIiwiZ3N1YiIsInN1cHBvcnRlZEZlYXR1cmVzIiwidXNlZExvb2t1cHMiLCJmZWF0dXJlIiwidGVzdCIsInRpIiwiaXNKb2luaW5nRmVhdHVyZSIsImNpIiwiY2FsY0dseXBoUG9zaXRpb25zIiwicG9zaXRpb25zIiwiSW50MTZBcnJheSIsImdseXBoSWQiLCJncG9zIiwibGxpc3QiLCJsb29rdXAiLCJpbmQiLCJhcHBseVZhbHVlUmVjb3JkIiwiYWRqIiwicHJldkdseXBoSW5kZXgiLCJnZXRQcmV2R2x5cGhJbmRleCIsInJpZ2h0IiwiYzEiLCJjMiIsIm1hcmtBcnJJbmRleCIsImJhc2VHbHlwaEluZGV4IiwiaXNCYXNlR2x5cGgiLCJiYXNlQXJySW5kZXgiLCJtYXJrUmVjb3JkIiwiYmFzZUFuY2hvciIsIm1hcmsxQXJySW5kZXgiLCJwcmV2R2x5cGhJZCIsImdldEdseXBoQ2xhc3MiLCJtYXJrMkFyckluZGV4IiwibWFyazFSZWNvcmQiLCJtYXJrMkFuY2hvciIsImNmZiIsImluZDEiLCJpbmQyIiwiZmlsdGVyIiwic291cmNlIiwiZ2kiLCJjbGFzc0RlZiIsImZpcnN0TnVtIiwiYXJncyIsIndyYXBGb250T2JqIiwidHlwckZvbnQiLCJnbHlwaE1hcCIsImNyZWF0ZSIsIm9zMiIsImZvbnRPYmoiLCJjYXBIZWlnaHQiLCJ4SGVpZ2h0Iiwic3VwcG9ydHNDb2RlUG9pbnQiLCJmb3JFYWNoR2x5cGgiLCJ0ZXh0IiwiZm9udFNpemUiLCJsZXR0ZXJTcGFjaW5nIiwiY2FsbGJhY2siLCJwZW5YIiwiZm9udFNjYWxlIiwiY2hhckluZGV4IiwiZ2x5cGhPYmoiLCJwYXRoIiwiY3Jkc0lkeCIsImxlbiIsIm51bUFyZ3MiLCJJbmZpbml0eSIsImluZGV4IiwiYWR2YW5jZVdpZHRoIiwiY2FsbCIsInBlZWsiLCJ3b3JrZXJNb2R1bGUiLCJkZXBlbmRlbmNpZXMiLCJpbml0IiwidW5pY29kZUZvbnRSZXNvbHZlckNsaWVudEZhY3RvcnkiLCJidWNrZXRzIiwicHJvdG90eXBlIiwiYWRkIiwiaGFzIiwic2VyaWFsaXplIiwiam9pbiIsImRlc2VyaWFsaXplIiwiY2xlYXIiLCJyZXBsYWNlIiwiV2Vha01hcCIsInJhbmdlcyIsImluY2x1ZGVzIiwiU2V0IiwiQ29kZVBvaW50U2V0IiwiY2xlYXJDYWNoZSIsImdldEZvbnRzRm9yU3RyaW5nIiwibGFuZyIsImNhdGVnb3J5Iiwic3R5bGUiLCJ3ZWlnaHQiLCJkYXRhVXJsIiwiQXJyYXkiLCJmZXRjaCIsInRoZW4iLCJvayIsInN0YXR1c1RleHQiLCJqc29uIiwiaXNBcnJheSIsImNhdGNoIiwiZXJyb3IiLCJtZXNzYWdlIiwiZGVsZXRlIiwiUHJvbWlzZSIsImFsbCIsInZhbHVlcyIsIlJlZ0V4cCIsImlkIiwidHlwZWZvcm1zIiwiZm9udFVybHMiLCJmcm9tIiwia2V5cyIsImNoYXJzIiwiY3JlYXRlRm9udFJlc29sdmVyIiwiZm9udFBhcnNlciIsInVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnQiLCJwYXJzZWRGb250cyIsImxvYWRpbmdGb250cyIsImRvTG9hZEZvbnQiLCJ1cmwiLCJvbkVycm9yIiwiZXJyIiwicmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0IiwicmVzcG9uc2VUeXBlIiwib25sb2FkIiwic3RhdHVzIiwicmVzcG9uc2UiLCJzcmMiLCJvbmVycm9yIiwic2VuZCIsImxvYWRGb250IiwiZm9udFVybCIsImNiIiwiZm9udHMiLCJ1c2VyRm9udHMiLCJ1bmljb2RlRm9udHNVUkwiLCJjaGFyUmVzb2x1dGlvbnMiLCJmb250UmVzb2x1dGlvbnMiLCJhbGxEb25lIiwiZm9udEluZGljZXMiLCJmYWxsYmFja1JhbmdlcyIsImRlZiIsInJldmVyc2UiLCJVTktOT1dOIiwiUkVTT0xWRUQiLCJORUVEU19GQUxMQkFDSyIsInByZXZDaGFyUmVzdWx0IiwicmVzb2x2ZVVzZXJGb250cyIsInN0YXJ0SW5kZXgiLCJpTGVuIiwiY29kZVBvaW50IiwiakxlbiIsInVuaWNvZGVSYW5nZSIsImlzQ29kZUluUmFuZ2VzIiwiZm9udEluZGV4IiwicmVzb2x2ZUZhbGxiYWNrcyIsImZhbGxiYWNrU3RyaW5nIiwic3Vic3RyaW5nIiwidW5kZWZpbmVkIiwiZm9udEluZGV4T2Zmc2V0IiwiY2hhcklkeCIsImVuZElkeCIsImxvYWRlZENvdW50Iiwic3RhcnQiLCJlbmQiLCJmb250UmVzb2x2ZXJXb3JrZXJNb2R1bGUiLCJjcmVhdGVUeXBlc2V0dGVyIiwicmVzb2x2ZUZvbnRzIiwiYmlkaSIsIklORiIsIkRFRkFVTFRfSUdOT1JBQkxFX0NIQVJTIiwibGluZUJyZWFraW5nV2hpdGVTcGFjZSIsIkJSRUFLX0FGVEVSX0NIQVJTIiwiY2FsY3VsYXRlRm9udFJ1bnMiLCJwcmVSZXNvbHZlZEZvbnRzIiwib25Eb25lIiwib25SZXNvbHZlZCIsImN1clJ1biIsInByZXZWYWwiLCJydW5zIiwidHlwZXNldCIsInNkZkdseXBoU2l6ZSIsImZvbnRXZWlnaHQiLCJmb250U3R5bGUiLCJsaW5lSGVpZ2h0IiwibWF4V2lkdGgiLCJkaXJlY3Rpb24iLCJ0ZXh0QWxpZ24iLCJ0ZXh0SW5kZW50Iiwid2hpdGVTcGFjZSIsIm92ZXJmbG93V3JhcCIsImFuY2hvclgiLCJhbmNob3JZIiwibWV0cmljc09ubHkiLCJpbmNsdWRlQ2FyZXRQb3NpdGlvbnMiLCJjaHVua2VkQm91bmRzU2l6ZSIsImNvbG9yUmFuZ2VzIiwibWFpblN0YXJ0Iiwibm93IiwidGltaW5ncyIsImZvbnRMb2FkIiwidHlwZXNldHRpbmciLCJpbmZvIiwiaGFzTWF4V2lkdGgiLCJpc0Zpbml0ZSIsImdseXBoRm9udEluZGljZXMiLCJnbHlwaFBvc2l0aW9ucyIsImdseXBoRGF0YSIsImdseXBoQ29sb3JzIiwiY2FyZXRQb3NpdGlvbnMiLCJ2aXNpYmxlQm91bmRzIiwiY2h1bmtlZEJvdW5kcyIsIm1heExpbmVXaWR0aCIsInJlbmRlcmFibGVHbHlwaENvdW50IiwiY2FuV3JhcCIsIm1ldHJpY3NCeUZvbnQiLCJ0eXBlc2V0U3RhcnQiLCJsaW5lWE9mZnNldCIsInByZXZSdW5FbmRYIiwiY3VycmVudExpbmUiLCJUZXh0TGluZSIsImxpbmVzIiwicnVuIiwiZm9udERhdGEiLCJmb250U2l6ZU11bHQiLCJjYWxjTGluZUhlaWdodCIsImhhbGZMZWFkaW5nIiwiY2FyZXRIZWlnaHQiLCJtaW4iLCJjYXJldFRvcCIsImJhc2VsaW5lIiwiY2FyZXRCb3R0b20iLCJydW5UZXh0IiwicHJldkdseXBoWCIsInByZXZHbHlwaE9iaiIsImdseXBoWCIsImdseXBoWSIsImNoYXIiLCJnbHlwaFdpZHRoIiwiY3VyTGluZUNvdW50IiwiY291bnQiLCJuZXh0TGluZSIsImlzV2hpdGVzcGFjZSIsImNhbkJyZWFrQWZ0ZXIiLCJpc0VtcHR5IiwiZ2x5cGhBdCIsInNwbGl0QXQiLCJhZGp1c3RYIiwiaXNTb2Z0V3JhcHBlZCIsImZseSIsInRvdGFsSGVpZ2h0IiwibGluZSIsImlzVHJhaWxpbmdXaGl0ZXNwYWNlIiwiZ2x5cGhJbmZvIiwiYmFzZWxpbmVEaWZmIiwiY2FwIiwiZXgiLCJhbmNob3JYT2Zmc2V0IiwiYW5jaG9yWU9mZnNldCIsInBhcnNlUGVyY2VudCIsImJpZGlMZXZlbHNSZXN1bHQiLCJnZXRFbWJlZGRpbmdMZXZlbHMiLCJGbG9hdDMyQXJyYXkiLCJyZW5kZXJhYmxlR2x5cGhJbmRleCIsInByZXZDaGFySW5kZXgiLCJjb2xvckNoYXJJbmRleCIsImNodW5rIiwiY3VycmVudENvbG9yIiwibGluZUluZGV4IiwibGluZUdseXBoQ291bnQiLCJsaW5lV2lkdGgiLCJ0cmFpbGluZ1doaXRlc3BhY2VDb3VudCIsImp1c3RpZnlBZGp1c3QiLCJ3aGl0ZXNwYWNlQ291bnQiLCJqdXN0aWZ5T2Zmc2V0IiwiZmxpcHMiLCJnZXRSZW9yZGVyU2VnbWVudHMiLCJmaSIsImxlZnQiLCJzdGFydEluTGluZSIsImVuZEluTGluZSIsInNldEdseXBoT2JqIiwicnRsIiwibGV2ZWxzIiwibWlycm9yZWQiLCJnZXRNaXJyb3JlZENoYXJhY3RlciIsImNhcmV0TGVmdCIsImNhcmV0UmlnaHQiLCJsaWdDb3VudCIsImZpbGxMaWdhdHVyZUNhcmV0UG9zaXRpb25zIiwiaGFzT3duUHJvcGVydHkiLCJpZHgiLCJmb250U3JjIiwiZm9udEdseXBoRGF0YSIsInBhdGhCb3VuZHMiLCJ2aXNYMCIsInZpc1kwIiwidmlzWDEiLCJ2aXNZMSIsInJlY3QiLCJjaHVua1JlY3QiLCJ0b3BCYXNlbGluZSIsImJsb2NrQm91bmRzIiwibWVhc3VyZSIsInJlc3VsdCIsIngwIiwieTAiLCJ4MSIsInkxIiwiaGVpZ2h0IiwibWF0Y2giLCJwY3QiLCJOYU4iLCJpc05hTiIsImxpZ1N0YXJ0SW5kZXgiLCJsaWdTdGFydFgiLCJsaWdFbmRYIiwibGlnQm90dG9tIiwibGlnVG9wIiwiZ3Vlc3NlZEFkdmFuY2VYIiwicGVyZm9ybWFuY2UiLCJEYXRlIiwiZGF0YSIsInRleHRMaW5lUHJvcHMiLCJjZWlsIiwiZmx5d2VpZ2h0IiwibmV3TGluZSIsInNwbGljZSIsIm9iaiIsInByb3AiLCJtYWluVGhyZWFkR2VuZXJhdG9yIiwid2FybmVkIiwiZ2VuZXJhdGVTREYiLCJ2aWV3Qm94IiwiZGlzdGFuY2UiLCJleHBvbmVudCIsImNhbnZhcyIsImNoYW5uZWwiLCJ1c2VXZWJHTCIsImdlbmVyYXRlU0RGX0pTX1dvcmtlciIsImdlbmVyYXRlU0RGX0dMIiwid2FybiIsInF1ZXVlIiwiY2h1bmtUaW1lQnVkZ2V0IiwidGltZXIiLCJuZXh0Q2h1bmsiLCJzZXRUaW1lb3V0IiwicmVzb2x2ZSIsInJlamVjdCIsIndlYmdsIiwiZ2VuZXJhdGVJbnRvQ2FudmFzIiwidGltaW5nIiwidGhyZWFkQ291bnQiLCJpZGxlVGltZW91dCIsInRocmVhZHMiLCJjYWxsTnVtIiwid29ya2VySWQiLCJ0aHJlYWQiLCJfY3JlYXRlU0RGR2VuZXJhdG9yIiwiZ2VuZXJhdGUiLCJqYXZhc2NyaXB0IiwidGV4dHVyZURhdGEiLCJnZXRUcmFuc2ZlcmFibGVzIiwicmVxdWVzdHMiLCJpZGxlVGltZXIiLCJjbGVhclRpbWVvdXQiLCJpbWFnZURhdGEiLCJ3ZWJnbFV0aWxzIiwicmVuZGVySW1hZ2VEYXRhIiwid2FybVVwU0RGQ2FudmFzIiwiX3dhcm0iLCJpc1N1cHBvcnRlZCIsInJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nIiwiQ09ORklHIiwiZGVmYXVsdEZvbnRVUkwiLCJzZGZNYXJnaW4iLCJzZGZFeHBvbmVudCIsInRleHR1cmVXaWR0aCIsInVzZVdvcmtlciIsInRlbXBDb2xvciIsImhhc1JlcXVlc3RlZCIsIm5vdyQxIiwiY29uZmlndXJlVGV4dEJ1aWxkZXIiLCJjb25maWciLCJhc3NpZ24iLCJhdGxhc2VzIiwiZ2V0VGV4dFJlbmRlckluZm8iLCJ0b3RhbFN0YXJ0IiwibGFiZWwiLCJ0b0Fic29sdXRlVVJMIiwiY29sb3JzIiwia2V5IiwiZ2V0SGV4IiwiZnJlZXplIiwiZ2x5cGhzUGVyUm93IiwiYXRsYXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJnbHlwaENvdW50Iiwic2RmQ2FudmFzIiwic2RmVGV4dHVyZSIsImNvbnRleHRMb3N0IiwiZ2x5cGhzQnlGb250IiwiZ2VuZXJhdGVNaXBtYXBzIiwiaW5pdENvbnRleHRMb3NzSGFuZGxpbmciLCJ0eXBlc2V0SW5Xb3JrZXIiLCJ0eXBlc2V0T25NYWluVGhyZWFkIiwibmVlZGVkU0RGcyIsImdseXBoQm91bmRzIiwiYm91bmRzSWR4IiwicG9zaXRpb25zSWR4IiwicXVhZHNTdGFydCIsImZvbnRHbHlwaE1hcHMiLCJmb250VW5pdHNNYXJnaW4iLCJhdGxhc0luZGV4Iiwic2RmVmlld0JveCIsInBvc1giLCJwb3NZIiwicXVhZHMiLCJzZGZTdGFydCIsInNkZiIsImN1cnJlbnRIZWlnaHQiLCJuZWVkZWRSb3dzIiwibmVlZGVkSGVpZ2h0IiwibG9nMiIsImRpc3Bvc2UiLCJnZW5lcmF0ZUdseXBoU0RGIiwiZ3B1QWNjZWxlcmF0ZVNERiIsInNhZmFyaVByZTE1V29ya2Fyb3VuZCIsIm5lZWRzVXBkYXRlIiwic2RmVG90YWwiLCJ0b3RhbCIsInBhcmFtZXRlcnMiLCJnbHlwaEF0bGFzSW5kaWNlcyIsInVzZUdQVSIsIm1heERpc3QiLCJzcXVhcmVJbmRleCIsImZsb29yIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwibG9nIiwicHJldmVudERlZmF1bHQiLCJwcm9taXNlcyIsImdseXBoIiwicHJlbG9hZEZvbnQiLCJjaGFyYWN0ZXJzIiwidG9PYmoiLCJmcm9tT2JqIiwibGlua0VsIiwiaHJlZiIsImNyZWF0ZUltYWdlQml0bWFwIiwiZ2wiLCJnZXRDb250ZXh0IiwicGl4ZWxzIiwiaW1hZ2UiLCJmbGlwWSIsImlzRGF0YVRleHR1cmUiLCJyZWFkUGl4ZWxzIiwiUkdCQSIsIlVOU0lHTkVEX0JZVEUiLCJ0eXBlc2V0dGVyV29ya2VyTW9kdWxlIiwiZm9udFJlc29sdmVyIiwidHlwZXNldHRlciIsInRyYW5zZmVyYWJsZXMiLCJvbk1haW5UaHJlYWQiLCJkdW1wU0RGVGV4dHVyZXMiLCJ0b0RhdGFVUkwiLCJ0ZW1wbGF0ZUdlb21ldHJpZXMiLCJnZXRUZW1wbGF0ZUdlb21ldHJ5IiwiZGV0YWlsIiwiZ2VvbSIsInRyYW5zbGF0ZSIsImdseXBoQm91bmRzQXR0ck5hbWUiLCJnbHlwaEluZGV4QXR0ck5hbWUiLCJnbHlwaENvbG9yQXR0ck5hbWUiLCJHbHlwaHNHZW9tZXRyeSIsImNvbnN0cnVjdG9yIiwiY3VydmVSYWRpdXMiLCJtYXRlcmlhbEluZGV4IiwiYm91bmRpbmdTcGhlcmUiLCJib3VuZGluZ0JveCIsImNvbXB1dGVCb3VuZGluZ1NwaGVyZSIsImNvbXB1dGVCb3VuZGluZ0JveCIsIl9kZXRhaWwiLCJ0cGwiLCJhdHRyIiwiYXR0cmlidXRlcyIsImNsb25lIiwic2V0SW5kZXgiLCJnZXRJbmRleCIsIl9jdXJ2ZVJhZGl1cyIsIl91cGRhdGVCb3VuZHMiLCJ1cGRhdGVHbHlwaHMiLCJ1cGRhdGVBdHRyaWJ1dGVEYXRhIiwiX2Jsb2NrQm91bmRzIiwiX2NodW5rZWRCb3VuZHMiLCJpbnN0YW5jZUNvdW50IiwiYm91bmRzIiwiYmJveCIsIlBJIiwic2luIiwiY29zIiwiaGFsZlBpIiwidHdvUGkiLCJhYnNSIiwibGVmdEFuZ2xlIiwicmlnaHRBbmdsZSIsIm1pblgiLCJtYXhYIiwibWF4WiIsImdldEJvdW5kaW5nU3BoZXJlIiwiYXBwbHlDbGlwUmVjdCIsImNsaXBSZWN0IiwiZ2V0QXR0cmlidXRlIiwiY2h1bmtzIiwiYXR0ck5hbWUiLCJuZXdBcnJheSIsIml0ZW1TaXplIiwiYXJyYXkiLCJzZXRBdHRyaWJ1dGUiLCJfbWF4SW5zdGFuY2VDb3VudCIsImRlbGV0ZUF0dHJpYnV0ZSIsIlZFUlRFWF9ERUZTIiwiVkVSVEVYX1RSQU5TRk9STSIsIkZSQUdNRU5UX0RFRlMiLCJGUkFHTUVOVF9UUkFOU0ZPUk0iLCJjcmVhdGVUZXh0RGVyaXZlZE1hdGVyaWFsIiwiYmFzZU1hdGVyaWFsIiwidGV4dE1hdGVyaWFsIiwiY2hhaW5lZCIsImV4dGVuc2lvbnMiLCJkZXJpdmF0aXZlcyIsInVuaWZvcm1zIiwidVRyb2lrYVNERlRleHR1cmUiLCJ1VHJvaWthU0RGVGV4dHVyZVNpemUiLCJ1VHJvaWthU0RGR2x5cGhTaXplIiwidVRyb2lrYVNERkV4cG9uZW50IiwidVRyb2lrYVRvdGFsQm91bmRzIiwidVRyb2lrYUNsaXBSZWN0IiwidVRyb2lrYUVkZ2VPZmZzZXQiLCJ1VHJvaWthRmlsbE9wYWNpdHkiLCJ1VHJvaWthUG9zaXRpb25PZmZzZXQiLCJ1VHJvaWthQ3VydmVSYWRpdXMiLCJ1VHJvaWthQmx1clJhZGl1cyIsInVUcm9pa2FTdHJva2VXaWR0aCIsInVUcm9pa2FTdHJva2VDb2xvciIsInVUcm9pa2FTdHJva2VPcGFjaXR5IiwidVRyb2lrYU9yaWVudCIsInVUcm9pa2FVc2VHbHlwaENvbG9ycyIsInVUcm9pa2FTREZEZWJ1ZyIsInZlcnRleERlZnMiLCJ2ZXJ0ZXhUcmFuc2Zvcm0iLCJmcmFnbWVudERlZnMiLCJmcmFnbWVudENvbG9yVHJhbnNmb3JtIiwiY3VzdG9tUmV3cml0ZXIiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsInVEaWZmdXNlUkUiLCJ0cmFuc3BhcmVudCIsImZvcmNlU2luZ2xlUGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJpc1Ryb2lrYVRleHRNYXRlcmlhbCIsInNoYWRvd1NpZGUiLCJzaWRlIiwiZGVmYXVsdE1hdGVyaWFsIiwiY29sb3IiLCJkZWZhdWx0U3Ryb2tlQ29sb3IiLCJ0ZW1wTWF0NCIsInRlbXBWZWMzYSIsInRlbXBWZWMzYiIsInRlbXBBcnJheSIsIm9yaWdpbiIsImRlZmF1bHRPcmllbnQiLCJmaXJzdCIsImdldEZsYXRSYXljYXN0TWVzaCIsIm1lc2giLCJnZXRDdXJ2ZWRSYXljYXN0TWVzaCIsInN5bmNTdGFydEV2ZW50Iiwic3luY0NvbXBsZXRlRXZlbnQiLCJTWU5DQUJMRV9QUk9QUyIsIkNPUFlBQkxFX1BST1BTIiwiY29uY2F0IiwiVGV4dCIsImdlb21ldHJ5IiwibWF0ZXJpYWwiLCJvdXRsaW5lV2lkdGgiLCJvdXRsaW5lQ29sb3IiLCJvdXRsaW5lT3BhY2l0eSIsIm91dGxpbmVCbHVyIiwib3V0bGluZU9mZnNldFgiLCJvdXRsaW5lT2Zmc2V0WSIsInN0cm9rZVdpZHRoIiwic3Ryb2tlQ29sb3IiLCJzdHJva2VPcGFjaXR5IiwiZmlsbE9wYWNpdHkiLCJkZXB0aE9mZnNldCIsIm9yaWVudGF0aW9uIiwiZ2x5cGhHZW9tZXRyeURldGFpbCIsImRlYnVnU0RGIiwic3luYyIsIl9uZWVkc1N5bmMiLCJfaXNTeW5jaW5nIiwiX3F1ZXVlZFN5bmNzIiwiZGlzcGF0Y2hFdmVudCIsInRleHRSZW5kZXJJbmZvIiwiX3RleHRSZW5kZXJJbmZvIiwicXVldWVkIiwiZm4iLCJvbkJlZm9yZVJlbmRlciIsInJlbmRlcmVyIiwic2NlbmUiLCJjYW1lcmEiLCJncm91cCIsIl9wcmVwYXJlRm9yUmVuZGVyIiwiZGVyaXZlZE1hdGVyaWFsIiwiX2Rlcml2ZWRNYXRlcmlhbCIsIl9iYXNlTWF0ZXJpYWwiLCJfZGVmYXVsdE1hdGVyaWFsIiwiaXNEZXJpdmVkRnJvbSIsIm9uRGlzcG9zZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYXNPdXRsaW5lIiwib3V0bGluZU1hdGVyaWFsIiwiX291dGxpbmVNdGwiLCJpc1RleHRPdXRsaW5lTWF0ZXJpYWwiLCJkZXB0aFdyaXRlIiwiY3VzdG9tRGVwdGhNYXRlcmlhbCIsImdldERlcHRoTWF0ZXJpYWwiLCJjdXN0b21EaXN0YW5jZU1hdGVyaWFsIiwiZ2V0RGlzdGFuY2VNYXRlcmlhbCIsImlzT3V0bGluZSIsInRleHRJbmZvIiwiZnJvbUFycmF5IiwiZGlzdGFuY2VPZmZzZXQiLCJibHVyUmFkaXVzIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJfcGFyc2VQZXJjZW50IiwicGFkIiwicG9seWdvbk9mZnNldCIsInBvbHlnb25PZmZzZXRGYWN0b3IiLCJwb2x5Z29uT2Zmc2V0VW5pdHMiLCJjb2xvck9iaiIsIl9pbnB1dCIsIm9yaWVudCIsIl9vcmllbnRhdGlvbiIsInJvdE1hdCIsImhTaWduIiwiaEF4aXMiLCJ2U2lnbiIsInZBeGlzIiwibG9va0F0IiwiY3Jvc3MiLCJzZXRGcm9tTWF0cml4NCIsImlkZW50aXR5IiwibG9jYWxQb3NpdGlvblRvVGV4dENvb3JkcyIsInBvc2l0aW9uIiwidGFyZ2V0IiwiY29weSIsImF0YW4yIiwid29ybGRQb3NpdGlvblRvVGV4dENvb3JkcyIsIndvcmxkVG9Mb2NhbCIsInJheWNhc3QiLCJyYXljYXN0ZXIiLCJpbnRlcnNlY3RzIiwicmF5Y2FzdE1lc2giLCJ1diIsImdldFgiLCJnZXRZIiwic2V0WFlaIiwibWF0cml4V29ybGQiLCJvYmplY3QiLCJwcml2YXRlS2V5Iiwic3luY1N0YXJ0RXZlbnQkMSIsInN5bmNDb21wbGV0ZUV2ZW50JDEiLCJtZW1iZXJJbmRleEF0dHJOYW1lIiwiZmxvYXRzUGVyTWVtYmVyIiwidGVtcEJveDMiLCJ0ZW1wQ29sb3IkMSIsIkJhdGNoZWRUZXh0IiwiX21lbWJlcnMiLCJfZGF0YVRleHR1cmVzIiwiX29uTWVtYmVyU3luY2VkIiwiZGlydHkiLCJvYmplY3RzIiwiYWRkVGV4dCIsInJlbW92ZSIsInJlbW92ZVRleHQiLCJfbmVlZHNSZXBhY2siLCJjcmVhdGVCYXRjaGVkVGV4dE1hdGVyaWFsIiwidXBkYXRlTWF0cml4V29ybGQiLCJmb3JjZSIsInVwZGF0ZUJvdW5kcyIsIm1ha2VFbXB0eSIsIm1hdHJpeEF1dG9VcGRhdGUiLCJ1cGRhdGVNYXRyaXgiLCJhcHBseU1hdHJpeDQiLCJ1bmlvbiIsIm1lbWJlciIsInVUcm9pa2FJc091dGxpbmUiLCJ0ZXh0dXJlIiwiZGF0YUxlbmd0aCIsInRleERhdGEiLCJzZXRUZXhEYXRhIiwiZWxlbWVudHMiLCJnZXRDb21wb25lbnQiLCJzZXRNYXRyaXhUZXh0dXJlIiwic3luY1Byb21pc2VzIiwicGFja2luZ0luZm8iLCJiYXRjaGVkQXR0cmlidXRlcyIsIm1lbWJlckluZGV4ZXMiLCJiYXRjaGVkR2x5cGhJbmRleGVzIiwiYmF0Y2hlZEdseXBoQm91bmRzIiwidG90YWxHbHlwaENvdW50IiwiY2xvbmVBbmRSZXNpemUiLCJtZW1iZXJJbmRleCIsImZpbGwiLCJzZXRVc2FnZSIsInRleCIsIm5ld0xlbmd0aCIsInRleFVuaWZvcm1OYW1lIiwidGV4U2l6ZVVuaWZvcm1OYW1lIiwiYmF0Y2hNYXRlcmlhbCIsInRvRml4ZWQiLCJzaGFkZXJzIiwidmFyeWluZ1VuaWZvcm1zIiwidW5pZm9ybU5hbWUiLCJ1bmlmb3JtVG9WYXJ5aW5nIiwidmFyeWluZ05hbWUiLCJ1bmlmb3JtUkUiLCJoYWRGcmFnbWVudFVuaWZvcm0iLCIkMCIsIiQxIiwiaGFkVmVydGV4VW5pZm9ybSIsImdldENhcmV0QXRQb2ludCIsImNsb3Nlc3RDYXJldCIsInJvd3MiLCJncm91cENhcmV0c0J5Um93IiwiY2xvc2VzdFJvdyIsInJvdyIsInRvcCIsImJvdHRvbSIsImNhcmV0cyIsImNhcmV0IiwiX3JlY3RzQ2FjaGUiLCJnZXRTZWxlY3Rpb25SZWN0cyIsInJlY3RzIiwicHJldlJlc3VsdCIsImN1cnJlbnRSZWN0IiwieDIiLCJzb3J0IiwicmVjdEEiLCJyZWN0QiIsIl9jYXJldHNCeVJvd0NhY2hlIiwiY3VyUm93IiwidmlzaXRDYXJldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-text/dist/troika-three-text.esm.js\n");

/***/ })

};
;